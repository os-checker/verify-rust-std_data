{
  "file": "alloc/src/sync.rs",
  "name": "<sync::Arc<core::ffi::CStr> as core::clone::Clone>::clone",
  "hash": "2293411815895459956924592876051786298",
  "hash_direct": "88260630073855929589000286112854624648",
  "src": "fn clone(&self) -> Arc<T, A> {\n        // Using a relaxed ordering is alright here, as knowledge of the\n        // original reference prevents other threads from erroneously deleting\n        // the object.\n        //\n        // As explained in the [Boost documentation][1], Increasing the\n        // reference counter can always be done with memory_order_relaxed: New\n        // references to an object can only be formed from an existing\n        // reference, and passing an existing reference from one thread to\n        // another must already provide any required synchronization.\n        //\n        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n        let old_size = self.inner().strong.fetch_add(1, Relaxed);\n\n        // However we need to guard against massive refcounts in case someone is `mem::forget`ing\n        // Arcs. If we don't do this the count can overflow and users will use-after free. This\n        // branch will never be taken in any realistic program. We abort because such a program is\n        // incredibly degenerate, and we don't care to support it.\n        //\n        // This check is not 100% water-proof: we error when the refcount grows beyond `isize::MAX`.\n        // But we do that check *after* having done the increment, so there is a chance here that\n        // the worst already happened and we actually do overflow the `usize` counter. However, that\n        // requires the counter to grow from `isize::MAX` to `usize::MAX` between the increment\n        // above and the `abort` below, which seems exceedingly unlikely.\n        //\n        // This is a global invariant, and also applies when using a compare-exchange loop to increment\n        // counters in other methods.\n        // Otherwise, the counter could be brought to an almost-overflow using a compare-exchange loop,\n        // and then overflow using a few `fetch_add`s.\n        if old_size > MAX_REFCOUNT {\n            abort();\n        }\n\n        unsafe { Self::from_inner_in(self.ptr, self.alloc.clone()) }\n    }",
  "callees": [
    "188618813038227315415644954775386001916",
    "971899185071274138910883585656191302733",
    "11921452687239992626301204965072789134",
    "158747230981247343143494172806960768280",
    "9297248957046646963852108909260076771",
    "866660375846977150517443284944234904555",
    "93947219591448812237225817182988509148",
    "967584774343011619817436161228886113688",
    "33132583010935775514672836188377634070"
  ]
}
