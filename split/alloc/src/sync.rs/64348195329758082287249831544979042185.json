{
  "file": "alloc/src/sync.rs",
  "name": "<sync::Arc<[u8; 0]> as core::clone::Clone>::clone",
  "hash": "64348195329758082287249831544979042185",
  "hash_direct": "178685916006018751448690372029022073757",
  "src": "fn clone(&self) -> Arc<T, A> {\n        // Using a relaxed ordering is alright here, as knowledge of the\n        // original reference prevents other threads from erroneously deleting\n        // the object.\n        //\n        // As explained in the [Boost documentation][1], Increasing the\n        // reference counter can always be done with memory_order_relaxed: New\n        // references to an object can only be formed from an existing\n        // reference, and passing an existing reference from one thread to\n        // another must already provide any required synchronization.\n        //\n        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n        let old_size = self.inner().strong.fetch_add(1, Relaxed);\n\n        // However we need to guard against massive refcounts in case someone is `mem::forget`ing\n        // Arcs. If we don't do this the count can overflow and users will use-after free. This\n        // branch will never be taken in any realistic program. We abort because such a program is\n        // incredibly degenerate, and we don't care to support it.\n        //\n        // This check is not 100% water-proof: we error when the refcount grows beyond `isize::MAX`.\n        // But we do that check *after* having done the increment, so there is a chance here that\n        // the worst already happened and we actually do overflow the `usize` counter. However, that\n        // requires the counter to grow from `isize::MAX` to `usize::MAX` between the increment\n        // above and the `abort` below, which seems exceedingly unlikely.\n        //\n        // This is a global invariant, and also applies when using a compare-exchange loop to increment\n        // counters in other methods.\n        // Otherwise, the counter could be brought to an almost-overflow using a compare-exchange loop,\n        // and then overflow using a few `fetch_add`s.\n        if old_size > MAX_REFCOUNT {\n            abort();\n        }\n\n        unsafe { Self::from_inner_in(self.ptr, self.alloc.clone()) }\n    }",
  "callees": [
    "188618813038227315415644954775386001916",
    "1652753943271577916710107606911841884446",
    "240284918586192427212854706508833155105",
    "158747230981247343143494172806960768280",
    "376526777678464966011645488991752646498",
    "129992252964979751614212823444326117946",
    "169542236484290019156557396311353846741",
    "967584774343011619817436161228886113688",
    "33132583010935775514672836188377634070"
  ]
}
