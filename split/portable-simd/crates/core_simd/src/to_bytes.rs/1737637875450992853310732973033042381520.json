{
  "file": "core/src/../../portable-simd/crates/core_simd/src/to_bytes.rs",
  "name": "<core_simd::vector::Simd<u16, 2> as core_simd::to_bytes::ToBytes>::from_be_bytes",
  "hash": "1737637875450992853310732973033042381520",
  "hash_direct": "531843793027225236511385407212988005791",
  "src": "fn from_be_bytes(bytes: Self::Bytes) -> Self {\n                let ret = Self::from_ne_bytes(bytes);\n                if cfg!(target_endian = \"big\") {\n                    ret\n                } else {\n                    swap_bytes!($ty, ret)\n                }\n            }",
  "macro_backtrace": [
    {
      "callsite": "impl_to_bytes! { $ty, 2  * [1, 2, 4, 8, 16, 32] }",
      "defsite": "macro_rules! impl_to_bytes {\n    { $ty:tt, 1  } => { impl_to_bytes! { $ty, 1  * [1, 2, 4, 8, 16, 32, 64] } };\n    { $ty:tt, 2  } => { impl_to_bytes! { $ty, 2  * [1, 2, 4, 8, 16, 32] } };\n    { $ty:tt, 4  } => { impl_to_bytes! { $ty, 4  * [1, 2, 4, 8, 16] } };\n    { $ty:tt, 8  } => { impl_to_bytes! { $ty, 8  * [1, 2, 4, 8] } };\n    { $ty:tt, 16 } => { impl_to_bytes! { $ty, 16 * [1, 2, 4] } };\n    { $ty:tt, 32 } => { impl_to_bytes! { $ty, 32 * [1, 2] } };\n    { $ty:tt, 64 } => { impl_to_bytes! { $ty, 64 * [1] } };\n\n    { $ty:tt, $size:literal * [$($elems:literal),*] } => {\n        $(\n        impl ToBytes for Simd<$ty, $elems> {\n            type Bytes = Simd<u8, { $size * $elems }>;\n\n            #[inline]\n            fn to_ne_bytes(self) -> Self::Bytes {\n                // Safety: transmuting between vectors is safe\n                unsafe {\n                    #![allow(clippy::useless_transmute)]\n                    core::mem::transmute(self)\n                }\n            }\n\n            #[inline]\n            fn to_be_bytes(mut self) -> Self::Bytes {\n                if !cfg!(target_endian = \"big\") {\n                    self = swap_bytes!($ty, self);\n                }\n                self.to_ne_bytes()\n            }\n\n            #[inline]\n            fn to_le_bytes(mut self) -> Self::Bytes {\n                if !cfg!(target_endian = \"little\") {\n                    self = swap_bytes!($ty, self);\n                }\n                self.to_ne_bytes()\n            }\n\n            #[inline]\n            fn from_ne_bytes(bytes: Self::Bytes) -> Self {\n                // Safety: transmuting between vectors is safe\n                unsafe {\n                    #![allow(clippy::useless_transmute)]\n                    core::mem::transmute(bytes)\n                }\n            }\n\n            #[inline]\n            fn from_be_bytes(bytes: Self::Bytes) -> Self {\n                let ret = Self::from_ne_bytes(bytes);\n                if cfg!(target_endian = \"big\") {\n                    ret\n                } else {\n                    swap_bytes!($ty, ret)\n                }\n            }\n\n            #[inline]\n            fn from_le_bytes(bytes: Self::Bytes) -> Self {\n                let ret = Self::from_ne_bytes(bytes);\n                if cfg!(target_endian = \"little\") {\n                    ret\n                } else {\n                    swap_bytes!($ty, ret)\n                }\n            }\n        }\n        )*\n    }\n}"
    },
    {
      "callsite": "impl_to_bytes! { u16, 2 }",
      "defsite": "macro_rules! impl_to_bytes {\n    { $ty:tt, 1  } => { impl_to_bytes! { $ty, 1  * [1, 2, 4, 8, 16, 32, 64] } };\n    { $ty:tt, 2  } => { impl_to_bytes! { $ty, 2  * [1, 2, 4, 8, 16, 32] } };\n    { $ty:tt, 4  } => { impl_to_bytes! { $ty, 4  * [1, 2, 4, 8, 16] } };\n    { $ty:tt, 8  } => { impl_to_bytes! { $ty, 8  * [1, 2, 4, 8] } };\n    { $ty:tt, 16 } => { impl_to_bytes! { $ty, 16 * [1, 2, 4] } };\n    { $ty:tt, 32 } => { impl_to_bytes! { $ty, 32 * [1, 2] } };\n    { $ty:tt, 64 } => { impl_to_bytes! { $ty, 64 * [1] } };\n\n    { $ty:tt, $size:literal * [$($elems:literal),*] } => {\n        $(\n        impl ToBytes for Simd<$ty, $elems> {\n            type Bytes = Simd<u8, { $size * $elems }>;\n\n            #[inline]\n            fn to_ne_bytes(self) -> Self::Bytes {\n                // Safety: transmuting between vectors is safe\n                unsafe {\n                    #![allow(clippy::useless_transmute)]\n                    core::mem::transmute(self)\n                }\n            }\n\n            #[inline]\n            fn to_be_bytes(mut self) -> Self::Bytes {\n                if !cfg!(target_endian = \"big\") {\n                    self = swap_bytes!($ty, self);\n                }\n                self.to_ne_bytes()\n            }\n\n            #[inline]\n            fn to_le_bytes(mut self) -> Self::Bytes {\n                if !cfg!(target_endian = \"little\") {\n                    self = swap_bytes!($ty, self);\n                }\n                self.to_ne_bytes()\n            }\n\n            #[inline]\n            fn from_ne_bytes(bytes: Self::Bytes) -> Self {\n                // Safety: transmuting between vectors is safe\n                unsafe {\n                    #![allow(clippy::useless_transmute)]\n                    core::mem::transmute(bytes)\n                }\n            }\n\n            #[inline]\n            fn from_be_bytes(bytes: Self::Bytes) -> Self {\n                let ret = Self::from_ne_bytes(bytes);\n                if cfg!(target_endian = \"big\") {\n                    ret\n                } else {\n                    swap_bytes!($ty, ret)\n                }\n            }\n\n            #[inline]\n            fn from_le_bytes(bytes: Self::Bytes) -> Self {\n                let ret = Self::from_ne_bytes(bytes);\n                if cfg!(target_endian = \"little\") {\n                    ret\n                } else {\n                    swap_bytes!($ty, ret)\n                }\n            }\n        }\n        )*\n    }\n}"
    }
  ],
  "callees": [
    "1268763688140058598946978475405067809",
    "5437828708708127223217124954144100575"
  ]
}
