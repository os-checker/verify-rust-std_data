{
  "file": "core/src/../../portable-simd/crates/core_simd/src/masks.rs",
  "name": "core_simd::masks::<impl core_simd::masks::sealed::Sealed for i8>::eq",
  "hash": "92327261733944438294876611177505795514",
  "hash_direct": "40169998146156321779807449188089686426",
  "src": "fn eq(self, other: Self) -> bool { self == other }",
  "macro_backtrace": [
    {
      "callsite": "impl_element! { i8, u8 }",
      "defsite": "macro_rules! impl_element {\n    { $ty:ty, $unsigned:ty } => {\n        impl Sealed for $ty {\n            #[inline]\n            fn valid<const N: usize>(value: Simd<Self, N>) -> bool\n            where\n                LaneCount<N>: SupportedLaneCount,\n            {\n                // We can't use `Simd` directly, because `Simd`'s functions call this function and\n                // we will end up with an infinite loop.\n                // Safety: `value` is an integer vector\n                unsafe {\n                    use core::intrinsics::simd;\n                    let falses: Simd<Self, N> = simd::simd_eq(value, Simd::splat(0 as _));\n                    let trues: Simd<Self, N> = simd::simd_eq(value, Simd::splat(-1 as _));\n                    let valid: Simd<Self, N> = simd::simd_or(falses, trues);\n                    simd::simd_reduce_all(valid)\n                }\n            }\n\n            #[inline]\n            fn eq(self, other: Self) -> bool { self == other }\n\n            #[inline]\n            fn to_usize(self) -> usize {\n                self as usize\n            }\n\n            #[inline]\n            fn max_unsigned() -> u64 {\n                <$unsigned>::MAX as u64\n            }\n\n            type Unsigned = $unsigned;\n\n            const TRUE: Self = -1;\n            const FALSE: Self = 0;\n        }\n\n        // Safety: this is a valid mask element type\n        unsafe impl MaskElement for $ty {}\n    }\n}"
    }
  ]
}
