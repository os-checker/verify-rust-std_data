{
  "file": "core/src/../../portable-simd/crates/core_simd/src/simd/num/int.rs",
  "name": "<core_simd::vector::Simd<i64, 8> as core_simd::simd::num::int::SimdInt>::swap_bytes",
  "hash": "74001557005088841451940134239108048066",
  "hash_direct": "182659957338006994346070351529657769446",
  "src": "fn swap_bytes(self) -> Self {\n                // Safety: `self` is an integer vector\n                unsafe { core::intrinsics::simd::simd_bswap(self) }\n            }",
  "macro_backtrace": [
    {
      "callsite": "impl_trait! { i8 (u8), i16 (u16), i32 (u32), i64 (u64), isize (usize) }",
      "defsite": "macro_rules! impl_trait {\n    { $($ty:ident ($unsigned:ident)),* } => {\n        $(\n        impl<const N: usize> Sealed for Simd<$ty, N>\n        where\n            LaneCount<N>: SupportedLaneCount,\n        {\n        }\n\n        impl<const N: usize> SimdInt for Simd<$ty, N>\n        where\n            LaneCount<N>: SupportedLaneCount,\n        {\n            type Mask = Mask<<$ty as SimdElement>::Mask, N>;\n            type Scalar = $ty;\n            type Unsigned = Simd<$unsigned, N>;\n            type Cast<T: SimdElement> = Simd<T, N>;\n\n            #[inline]\n            fn cast<T: SimdCast>(self) -> Self::Cast<T> {\n                // Safety: supported types are guaranteed by SimdCast\n                unsafe { core::intrinsics::simd::simd_as(self) }\n            }\n\n            #[inline]\n            fn saturating_add(self, second: Self) -> Self {\n                // Safety: `self` is a vector\n                unsafe { core::intrinsics::simd::simd_saturating_add(self, second) }\n            }\n\n            #[inline]\n            fn saturating_sub(self, second: Self) -> Self {\n                // Safety: `self` is a vector\n                unsafe { core::intrinsics::simd::simd_saturating_sub(self, second) }\n            }\n\n            #[inline]\n            fn abs(self) -> Self {\n                const SHR: $ty = <$ty>::BITS as $ty - 1;\n                let m = self >> Simd::splat(SHR);\n                (self^m) - m\n            }\n\n            #[inline]\n            fn abs_diff(self, second: Self) -> Self::Unsigned {\n                let max = self.simd_max(second);\n                let min = self.simd_min(second);\n                (max - min).cast()\n            }\n\n            #[inline]\n            fn saturating_abs(self) -> Self {\n                // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n                const SHR: $ty = <$ty>::BITS as $ty - 1;\n                let m = self >> Simd::splat(SHR);\n                (self^m).saturating_sub(m)\n            }\n\n            #[inline]\n            fn saturating_neg(self) -> Self {\n                Self::splat(0).saturating_sub(self)\n            }\n\n            #[inline]\n            fn is_positive(self) -> Self::Mask {\n                self.simd_gt(Self::splat(0))\n            }\n\n            #[inline]\n            fn is_negative(self) -> Self::Mask {\n                self.simd_lt(Self::splat(0))\n            }\n\n            #[inline]\n            fn signum(self) -> Self {\n                self.is_positive().select(\n                    Self::splat(1),\n                    self.is_negative().select(Self::splat(-1), Self::splat(0))\n                )\n            }\n\n            #[inline]\n            fn reduce_sum(self) -> Self::Scalar {\n                // Safety: `self` is an integer vector\n                unsafe { core::intrinsics::simd::simd_reduce_add_ordered(self, 0) }\n            }\n\n            #[inline]\n            fn reduce_product(self) -> Self::Scalar {\n                // Safety: `self` is an integer vector\n                unsafe { core::intrinsics::simd::simd_reduce_mul_ordered(self, 1) }\n            }\n\n            #[inline]\n            fn reduce_max(self) -> Self::Scalar {\n                // Safety: `self` is an integer vector\n                unsafe { core::intrinsics::simd::simd_reduce_max(self) }\n            }\n\n            #[inline]\n            fn reduce_min(self) -> Self::Scalar {\n                // Safety: `self` is an integer vector\n                unsafe { core::intrinsics::simd::simd_reduce_min(self) }\n            }\n\n            #[inline]\n            fn reduce_and(self) -> Self::Scalar {\n                // Safety: `self` is an integer vector\n                unsafe { core::intrinsics::simd::simd_reduce_and(self) }\n            }\n\n            #[inline]\n            fn reduce_or(self) -> Self::Scalar {\n                // Safety: `self` is an integer vector\n                unsafe { core::intrinsics::simd::simd_reduce_or(self) }\n            }\n\n            #[inline]\n            fn reduce_xor(self) -> Self::Scalar {\n                // Safety: `self` is an integer vector\n                unsafe { core::intrinsics::simd::simd_reduce_xor(self) }\n            }\n\n            #[inline]\n            fn swap_bytes(self) -> Self {\n                // Safety: `self` is an integer vector\n                unsafe { core::intrinsics::simd::simd_bswap(self) }\n            }\n\n            #[inline]\n            fn reverse_bits(self) -> Self {\n                // Safety: `self` is an integer vector\n                unsafe { core::intrinsics::simd::simd_bitreverse(self) }\n            }\n\n            #[inline]\n            fn count_ones(self) -> Self::Unsigned {\n                self.cast::<$unsigned>().count_ones()\n            }\n\n            #[inline]\n            fn count_zeros(self) -> Self::Unsigned {\n                self.cast::<$unsigned>().count_zeros()\n            }\n\n            #[inline]\n            fn leading_zeros(self) -> Self::Unsigned {\n                self.cast::<$unsigned>().leading_zeros()\n            }\n\n            #[inline]\n            fn trailing_zeros(self) -> Self::Unsigned {\n                self.cast::<$unsigned>().trailing_zeros()\n            }\n\n            #[inline]\n            fn leading_ones(self) -> Self::Unsigned {\n                self.cast::<$unsigned>().leading_ones()\n            }\n\n            #[inline]\n            fn trailing_ones(self) -> Self::Unsigned {\n                self.cast::<$unsigned>().trailing_ones()\n            }\n        }\n        )*\n    }\n}"
    }
  ]
}
