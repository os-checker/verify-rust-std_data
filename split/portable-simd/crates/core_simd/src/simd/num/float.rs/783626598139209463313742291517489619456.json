{
  "file": "core/src/../../portable-simd/crates/core_simd/src/simd/num/float.rs",
  "name": "<core_simd::vector::Simd<f32, N> as core_simd::simd::num::float::SimdFloat>::cast::{constant#3}",
  "hash": "783626598139209463313742291517489619456",
  "hash_direct": "101167939395149917214585079933347281963",
  "src": "16",
  "macro_backtrace": [
    {
      "callsite": "impl_trait! { f32 { bits: u32, mask: i32 }, f64 { bits: u64, mask: i64 } }",
      "defsite": "macro_rules! impl_trait {\n    { $($ty:ty { bits: $bits_ty:ty, mask: $mask_ty:ty }),* } => {\n        $(\n        impl<const N: usize> Sealed for Simd<$ty, N>\n        where\n            LaneCount<N>: SupportedLaneCount,\n        {\n        }\n\n        impl<const N: usize> SimdFloat for Simd<$ty, N>\n        where\n            LaneCount<N>: SupportedLaneCount,\n        {\n            type Mask = Mask<<$mask_ty as SimdElement>::Mask, N>;\n            type Scalar = $ty;\n            type Bits = Simd<$bits_ty, N>;\n            type Cast<T: SimdElement> = Simd<T, N>;\n\n            #[cfg(not(target_arch = \"aarch64\"))]\n            #[inline]\n            fn cast<T: SimdCast>(self) -> Self::Cast<T>\n            {\n                // Safety: supported types are guaranteed by SimdCast\n                unsafe { core::intrinsics::simd::simd_as(self) }\n            }\n\n            // workaround for https://github.com/llvm/llvm-project/issues/94694 (fixed in LLVM 20)\n            // tracked in: https://github.com/rust-lang/rust/issues/135982\n            #[cfg(target_arch = \"aarch64\")]\n            #[inline]\n            fn cast<T: SimdCast>(self) -> Self::Cast<T>\n            {\n                const { assert!(N <= 64) };\n                if N <= 2 || N == 4 || N == 8 || N == 16 || N == 32 || N == 64 {\n                    // Safety: supported types are guaranteed by SimdCast\n                    unsafe { core::intrinsics::simd::simd_as(self) }\n                } else if N < 4 {\n                    let x = self.resize::<4>(Default::default()).cast();\n                    x.resize::<N>(x[0])\n                } else if N < 8 {\n                    let x = self.resize::<8>(Default::default()).cast();\n                    x.resize::<N>(x[0])\n                } else if N < 16 {\n                    let x = self.resize::<16>(Default::default()).cast();\n                    x.resize::<N>(x[0])\n                } else if N < 32 {\n                    let x = self.resize::<32>(Default::default()).cast();\n                    x.resize::<N>(x[0])\n                } else {\n                    let x = self.resize::<64>(Default::default()).cast();\n                    x.resize::<N>(x[0])\n                }\n            }\n\n            #[inline]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            unsafe fn to_int_unchecked<I: SimdCast>(self) -> Self::Cast<I>\n            where\n                Self::Scalar: core::convert::FloatToInt<I>,\n            {\n                // Safety: supported types are guaranteed by SimdCast, the caller is responsible for the extra invariants\n                unsafe { core::intrinsics::simd::simd_cast(self) }\n            }\n\n            #[inline]\n            fn to_bits(self) -> Simd<$bits_ty, N> {\n                assert_eq!(size_of::<Self>(), size_of::<Self::Bits>());\n                // Safety: transmuting between vector types is safe\n                unsafe { core::mem::transmute_copy(&self) }\n            }\n\n            #[inline]\n            fn from_bits(bits: Simd<$bits_ty, N>) -> Self {\n                assert_eq!(size_of::<Self>(), size_of::<Self::Bits>());\n                // Safety: transmuting between vector types is safe\n                unsafe { core::mem::transmute_copy(&bits) }\n            }\n\n            #[inline]\n            fn abs(self) -> Self {\n                // Safety: `self` is a float vector\n                unsafe { core::intrinsics::simd::simd_fabs(self) }\n            }\n\n            #[inline]\n            fn recip(self) -> Self {\n                Self::splat(1.0) / self\n            }\n\n            #[inline]\n            fn to_degrees(self) -> Self {\n                // to_degrees uses a special constant for better precision, so extract that constant\n                self * Self::splat(Self::Scalar::to_degrees(1.))\n            }\n\n            #[inline]\n            fn to_radians(self) -> Self {\n                self * Self::splat(Self::Scalar::to_radians(1.))\n            }\n\n            #[inline]\n            fn is_sign_positive(self) -> Self::Mask {\n                !self.is_sign_negative()\n            }\n\n            #[inline]\n            fn is_sign_negative(self) -> Self::Mask {\n                let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n                sign_bits.simd_gt(Simd::splat(0))\n            }\n\n            #[inline]\n            fn is_nan(self) -> Self::Mask {\n                self.simd_ne(self)\n            }\n\n            #[inline]\n            fn is_infinite(self) -> Self::Mask {\n                self.abs().simd_eq(Self::splat(Self::Scalar::INFINITY))\n            }\n\n            #[inline]\n            fn is_finite(self) -> Self::Mask {\n                self.abs().simd_lt(Self::splat(Self::Scalar::INFINITY))\n            }\n\n            #[inline]\n            fn is_subnormal(self) -> Self::Mask {\n                // On some architectures (e.g. armv7 and some ppc) subnormals are flushed to zero,\n                // so this comparison must be done with integers.\n                let not_zero = self.abs().to_bits().simd_ne(Self::splat(0.0).to_bits());\n                not_zero & (self.to_bits() & Self::splat(Self::Scalar::INFINITY).to_bits()).simd_eq(Simd::splat(0))\n            }\n\n            #[inline]\n            fn is_normal(self) -> Self::Mask {\n                !(self.abs().simd_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n            }\n\n            #[inline]\n            fn signum(self) -> Self {\n                self.is_nan().select(Self::splat(Self::Scalar::NAN), Self::splat(1.0).copysign(self))\n            }\n\n            #[inline]\n            fn copysign(self, sign: Self) -> Self {\n                let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n                let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n                Self::from_bits(sign_bit | magnitude)\n            }\n\n            #[inline]\n            fn simd_min(self, other: Self) -> Self {\n                // Safety: `self` and `other` are float vectors\n                unsafe { core::intrinsics::simd::simd_fmin(self, other) }\n            }\n\n            #[inline]\n            fn simd_max(self, other: Self) -> Self {\n                // Safety: `self` and `other` are floating point vectors\n                unsafe { core::intrinsics::simd::simd_fmax(self, other) }\n            }\n\n            #[inline]\n            fn simd_clamp(self, min: Self, max: Self) -> Self {\n                assert!(\n                    min.simd_le(max).all(),\n                    \"each element in `min` must be less than or equal to the corresponding element in `max`\",\n                );\n                let mut x = self;\n                x = x.simd_lt(min).select(min, x);\n                x = x.simd_gt(max).select(max, x);\n                x\n            }\n\n            #[inline]\n            fn reduce_sum(self) -> Self::Scalar {\n                // LLVM sum is inaccurate on i586\n                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                    self.as_array().iter().sum()\n                } else {\n                    // Safety: `self` is a float vector\n                    unsafe { core::intrinsics::simd::simd_reduce_add_ordered(self, -0.) }\n                }\n            }\n\n            #[inline]\n            fn reduce_product(self) -> Self::Scalar {\n                // LLVM product is inaccurate on i586\n                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                    self.as_array().iter().product()\n                } else {\n                    // Safety: `self` is a float vector\n                    unsafe { core::intrinsics::simd::simd_reduce_mul_ordered(self, 1.) }\n                }\n            }\n\n            #[inline]\n            fn reduce_max(self) -> Self::Scalar {\n                // Safety: `self` is a float vector\n                unsafe { core::intrinsics::simd::simd_reduce_max(self) }\n            }\n\n            #[inline]\n            fn reduce_min(self) -> Self::Scalar {\n                // Safety: `self` is a float vector\n                unsafe { core::intrinsics::simd::simd_reduce_min(self) }\n            }\n        }\n        )*\n    }\n}"
    }
  ]
}
