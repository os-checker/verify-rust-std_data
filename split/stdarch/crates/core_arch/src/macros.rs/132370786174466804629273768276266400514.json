{
  "file": "core/src/../../stdarch/crates/core_arch/src/macros.rs",
  "name": "<core_arch::arm_shared::neon::float16x8_t as clone::Clone>::clone",
  "hash": "132370786174466804629273768276266400514",
  "hash_direct": "54004487250234431013850722814761340627",
  "src": "Clone",
  "macro_backtrace": [
    {
      "callsite": "Clone",
      "defsite": "pub macro Clone($item:item) {\n    /* compiler built-in */\n}"
    },
    {
      "callsite": "types! {\n        $(\n            #![$stability_more]\n        )*\n\n        $(\n            $(#[$doc])*\n            $(stability: [$stability_already])*\n            stability: [$stability_first]\n            pub struct $name($len x $v $elem_type);\n        )*\n    }",
      "defsite": "macro_rules! types {\n    (\n        #![$stability_first:meta]\n        $(\n            #![$stability_more:meta]\n        )*\n\n        $(\n            $(#[$doc:meta])*\n            $(stability: [$stability_already: meta])*\n            pub struct $name:ident($len:literal x $v:vis $elem_type:ty);\n        )*\n    ) => (types! {\n        $(\n            #![$stability_more]\n        )*\n\n        $(\n            $(#[$doc])*\n            $(stability: [$stability_already])*\n            stability: [$stability_first]\n            pub struct $name($len x $v $elem_type);\n        )*\n    });\n\n    (\n        $(\n            $(#[$doc:meta])*\n            $(stability: [$stability: meta])+\n            pub struct $name:ident($len:literal x $v:vis $elem_type:ty);\n        )*\n    ) => ($(\n        $(#[$doc])*\n        $(#[$stability])+\n        #[derive(Copy, Clone)]\n        #[allow(non_camel_case_types)]\n        #[repr(simd)]\n        #[allow(clippy::missing_inline_in_public_items)]\n        pub struct $name($v [$elem_type; $len]);\n\n        impl $name {\n            /// Using `my_simd([x; N])` seemingly fails tests,\n            /// so use this internal helper for it instead.\n            #[inline(always)]\n            $v fn splat(value: $elem_type) -> $name {\n                #[derive(Copy, Clone)]\n                #[repr(simd)]\n                struct JustOne([$elem_type; 1]);\n                let one = JustOne([value]);\n                // SAFETY: 0 is always in-bounds because we're shuffling\n                // a simd type with exactly one element.\n                unsafe { simd_shuffle!(one, one, [0; $len]) }\n            }\n\n            /// Returns an array reference containing the entire SIMD vector.\n            $v const fn as_array(&self) -> &[$elem_type; $len] {\n                // SAFETY: this type is just an overaligned `[T; N]` with\n                // potential padding at the end, so pointer casting to a\n                // `&[T; N]` is safe.\n                //\n                // NOTE: This deliberately doesn't just use `&self.0` because it may soon be banned\n                // see https://github.com/rust-lang/compiler-team/issues/838\n                unsafe { &*(self as *const Self as *const [$elem_type; $len]) }\n\n            }\n\n            /// Returns a mutable array reference containing the entire SIMD vector.\n            #[inline]\n            $v fn as_mut_array(&mut self) -> &mut [$elem_type; $len] {\n                // SAFETY: this type is just an overaligned `[T; N]` with\n                // potential padding at the end, so pointer casting to a\n                // `&mut [T; N]` is safe.\n                //\n                // NOTE: This deliberately doesn't just use `&mut self.0` because it may soon be banned\n                // see https://github.com/rust-lang/compiler-team/issues/838\n                unsafe { &mut *(self as *mut Self as *mut [$elem_type; $len]) }\n            }\n        }\n\n        $(#[$stability])+\n        impl crate::fmt::Debug for $name {\n            #[inline]\n            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n                crate::core_arch::simd::debug_simd_finish(f, stringify!($name), self.as_array())\n            }\n        }\n    )*);\n}"
    },
    {
      "callsite": "types! {\n    #![unstable(feature = \"stdarch_neon_f16\", issue = \"136306\")]\n\n    /// Arm-specific 64-bit wide vector of four packed `f16`.\n    pub struct float16x4_t(4 x pub(crate) f16);\n    /// Arm-specific 128-bit wide vector of eight packed `f16`.\n    pub struct float16x8_t(8 x pub(crate) f16);\n}",
      "defsite": "macro_rules! types {\n    (\n        #![$stability_first:meta]\n        $(\n            #![$stability_more:meta]\n        )*\n\n        $(\n            $(#[$doc:meta])*\n            $(stability: [$stability_already: meta])*\n            pub struct $name:ident($len:literal x $v:vis $elem_type:ty);\n        )*\n    ) => (types! {\n        $(\n            #![$stability_more]\n        )*\n\n        $(\n            $(#[$doc])*\n            $(stability: [$stability_already])*\n            stability: [$stability_first]\n            pub struct $name($len x $v $elem_type);\n        )*\n    });\n\n    (\n        $(\n            $(#[$doc:meta])*\n            $(stability: [$stability: meta])+\n            pub struct $name:ident($len:literal x $v:vis $elem_type:ty);\n        )*\n    ) => ($(\n        $(#[$doc])*\n        $(#[$stability])+\n        #[derive(Copy, Clone)]\n        #[allow(non_camel_case_types)]\n        #[repr(simd)]\n        #[allow(clippy::missing_inline_in_public_items)]\n        pub struct $name($v [$elem_type; $len]);\n\n        impl $name {\n            /// Using `my_simd([x; N])` seemingly fails tests,\n            /// so use this internal helper for it instead.\n            #[inline(always)]\n            $v fn splat(value: $elem_type) -> $name {\n                #[derive(Copy, Clone)]\n                #[repr(simd)]\n                struct JustOne([$elem_type; 1]);\n                let one = JustOne([value]);\n                // SAFETY: 0 is always in-bounds because we're shuffling\n                // a simd type with exactly one element.\n                unsafe { simd_shuffle!(one, one, [0; $len]) }\n            }\n\n            /// Returns an array reference containing the entire SIMD vector.\n            $v const fn as_array(&self) -> &[$elem_type; $len] {\n                // SAFETY: this type is just an overaligned `[T; N]` with\n                // potential padding at the end, so pointer casting to a\n                // `&[T; N]` is safe.\n                //\n                // NOTE: This deliberately doesn't just use `&self.0` because it may soon be banned\n                // see https://github.com/rust-lang/compiler-team/issues/838\n                unsafe { &*(self as *const Self as *const [$elem_type; $len]) }\n\n            }\n\n            /// Returns a mutable array reference containing the entire SIMD vector.\n            #[inline]\n            $v fn as_mut_array(&mut self) -> &mut [$elem_type; $len] {\n                // SAFETY: this type is just an overaligned `[T; N]` with\n                // potential padding at the end, so pointer casting to a\n                // `&mut [T; N]` is safe.\n                //\n                // NOTE: This deliberately doesn't just use `&mut self.0` because it may soon be banned\n                // see https://github.com/rust-lang/compiler-team/issues/838\n                unsafe { &mut *(self as *mut Self as *mut [$elem_type; $len]) }\n            }\n        }\n\n        $(#[$stability])+\n        impl crate::fmt::Debug for $name {\n            #[inline]\n            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n                crate::core_arch::simd::debug_simd_finish(f, stringify!($name), self.as_array())\n            }\n        }\n    )*);\n}"
    }
  ]
}
