{
  "file": "core/src/../../stdarch/crates/core_arch/src/macros.rs",
  "name": "core_arch::arm_shared::neon::poly16x4_t::splat::JustOne::0::{constant#0}",
  "hash": "66632138527046794576074251482387591321",
  "hash_direct": "173781562109404162007557102226230645903",
  "src": "1",
  "macro_backtrace": [
    {
      "callsite": "types! {\n        $(\n            #![$stability_more]\n        )*\n\n        $(\n            $(#[$doc])*\n            $(stability: [$stability_already])*\n            stability: [$stability_first]\n            pub struct $name($len x $v $elem_type);\n        )*\n    }",
      "defsite": "macro_rules! types {\n    (\n        #![$stability_first:meta]\n        $(\n            #![$stability_more:meta]\n        )*\n\n        $(\n            $(#[$doc:meta])*\n            $(stability: [$stability_already: meta])*\n            pub struct $name:ident($len:literal x $v:vis $elem_type:ty);\n        )*\n    ) => (types! {\n        $(\n            #![$stability_more]\n        )*\n\n        $(\n            $(#[$doc])*\n            $(stability: [$stability_already])*\n            stability: [$stability_first]\n            pub struct $name($len x $v $elem_type);\n        )*\n    });\n\n    (\n        $(\n            $(#[$doc:meta])*\n            $(stability: [$stability: meta])+\n            pub struct $name:ident($len:literal x $v:vis $elem_type:ty);\n        )*\n    ) => ($(\n        $(#[$doc])*\n        $(#[$stability])+\n        #[derive(Copy, Clone)]\n        #[allow(non_camel_case_types)]\n        #[repr(simd)]\n        #[allow(clippy::missing_inline_in_public_items)]\n        pub struct $name($v [$elem_type; $len]);\n\n        impl $name {\n            /// Using `my_simd([x; N])` seemingly fails tests,\n            /// so use this internal helper for it instead.\n            #[inline(always)]\n            $v fn splat(value: $elem_type) -> $name {\n                #[derive(Copy, Clone)]\n                #[repr(simd)]\n                struct JustOne([$elem_type; 1]);\n                let one = JustOne([value]);\n                // SAFETY: 0 is always in-bounds because we're shuffling\n                // a simd type with exactly one element.\n                unsafe { simd_shuffle!(one, one, [0; $len]) }\n            }\n\n            /// Returns an array reference containing the entire SIMD vector.\n            $v const fn as_array(&self) -> &[$elem_type; $len] {\n                // SAFETY: this type is just an overaligned `[T; N]` with\n                // potential padding at the end, so pointer casting to a\n                // `&[T; N]` is safe.\n                //\n                // NOTE: This deliberately doesn't just use `&self.0` because it may soon be banned\n                // see https://github.com/rust-lang/compiler-team/issues/838\n                unsafe { &*(self as *const Self as *const [$elem_type; $len]) }\n\n            }\n\n            /// Returns a mutable array reference containing the entire SIMD vector.\n            #[inline]\n            $v fn as_mut_array(&mut self) -> &mut [$elem_type; $len] {\n                // SAFETY: this type is just an overaligned `[T; N]` with\n                // potential padding at the end, so pointer casting to a\n                // `&mut [T; N]` is safe.\n                //\n                // NOTE: This deliberately doesn't just use `&mut self.0` because it may soon be banned\n                // see https://github.com/rust-lang/compiler-team/issues/838\n                unsafe { &mut *(self as *mut Self as *mut [$elem_type; $len]) }\n            }\n        }\n\n        $(#[$stability])+\n        impl crate::fmt::Debug for $name {\n            #[inline]\n            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n                crate::core_arch::simd::debug_simd_finish(f, stringify!($name), self.as_array())\n            }\n        }\n    )*);\n}"
    },
    {
      "callsite": "types! {\n        $(\n            #![$stability_more]\n        )*\n\n        $(\n            $(#[$doc])*\n            $(stability: [$stability_already])*\n            stability: [$stability_first]\n            pub struct $name($len x $v $elem_type);\n        )*\n    }",
      "defsite": "macro_rules! types {\n    (\n        #![$stability_first:meta]\n        $(\n            #![$stability_more:meta]\n        )*\n\n        $(\n            $(#[$doc:meta])*\n            $(stability: [$stability_already: meta])*\n            pub struct $name:ident($len:literal x $v:vis $elem_type:ty);\n        )*\n    ) => (types! {\n        $(\n            #![$stability_more]\n        )*\n\n        $(\n            $(#[$doc])*\n            $(stability: [$stability_already])*\n            stability: [$stability_first]\n            pub struct $name($len x $v $elem_type);\n        )*\n    });\n\n    (\n        $(\n            $(#[$doc:meta])*\n            $(stability: [$stability: meta])+\n            pub struct $name:ident($len:literal x $v:vis $elem_type:ty);\n        )*\n    ) => ($(\n        $(#[$doc])*\n        $(#[$stability])+\n        #[derive(Copy, Clone)]\n        #[allow(non_camel_case_types)]\n        #[repr(simd)]\n        #[allow(clippy::missing_inline_in_public_items)]\n        pub struct $name($v [$elem_type; $len]);\n\n        impl $name {\n            /// Using `my_simd([x; N])` seemingly fails tests,\n            /// so use this internal helper for it instead.\n            #[inline(always)]\n            $v fn splat(value: $elem_type) -> $name {\n                #[derive(Copy, Clone)]\n                #[repr(simd)]\n                struct JustOne([$elem_type; 1]);\n                let one = JustOne([value]);\n                // SAFETY: 0 is always in-bounds because we're shuffling\n                // a simd type with exactly one element.\n                unsafe { simd_shuffle!(one, one, [0; $len]) }\n            }\n\n            /// Returns an array reference containing the entire SIMD vector.\n            $v const fn as_array(&self) -> &[$elem_type; $len] {\n                // SAFETY: this type is just an overaligned `[T; N]` with\n                // potential padding at the end, so pointer casting to a\n                // `&[T; N]` is safe.\n                //\n                // NOTE: This deliberately doesn't just use `&self.0` because it may soon be banned\n                // see https://github.com/rust-lang/compiler-team/issues/838\n                unsafe { &*(self as *const Self as *const [$elem_type; $len]) }\n\n            }\n\n            /// Returns a mutable array reference containing the entire SIMD vector.\n            #[inline]\n            $v fn as_mut_array(&mut self) -> &mut [$elem_type; $len] {\n                // SAFETY: this type is just an overaligned `[T; N]` with\n                // potential padding at the end, so pointer casting to a\n                // `&mut [T; N]` is safe.\n                //\n                // NOTE: This deliberately doesn't just use `&mut self.0` because it may soon be banned\n                // see https://github.com/rust-lang/compiler-team/issues/838\n                unsafe { &mut *(self as *mut Self as *mut [$elem_type; $len]) }\n            }\n        }\n\n        $(#[$stability])+\n        impl crate::fmt::Debug for $name {\n            #[inline]\n            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n                crate::core_arch::simd::debug_simd_finish(f, stringify!($name), self.as_array())\n            }\n        }\n    )*);\n}"
    },
    {
      "callsite": "types! {\n    #![cfg_attr(not(target_arch = \"arm\"), stable(feature = \"neon_intrinsics\", since = \"1.59.0\"))]\n    #![cfg_attr(target_arch = \"arm\", unstable(feature = \"stdarch_arm_neon_intrinsics\", issue = \"111800\"))]\n\n    /// Arm-specific 64-bit wide vector of eight packed `i8`.\n    pub struct int8x8_t(8 x pub(crate) i8);\n    /// Arm-specific 64-bit wide vector of eight packed `u8`.\n    pub struct uint8x8_t(8 x pub(crate) u8);\n    /// Arm-specific 64-bit wide polynomial vector of eight packed `p8`.\n    pub struct poly8x8_t(8 x pub(crate) p8);\n    /// Arm-specific 64-bit wide vector of four packed `i16`.\n    pub struct int16x4_t(4 x pub(crate) i16);\n    /// Arm-specific 64-bit wide vector of four packed `u16`.\n    pub struct uint16x4_t(4 x pub(crate) u16);\n    /// Arm-specific 64-bit wide vector of four packed `p16`.\n    pub struct poly16x4_t(4 x pub(crate) p16);\n    /// Arm-specific 64-bit wide vector of two packed `i32`.\n    pub struct int32x2_t(2 x pub(crate) i32);\n    /// Arm-specific 64-bit wide vector of two packed `u32`.\n    pub struct uint32x2_t(2 x pub(crate) u32);\n    /// Arm-specific 64-bit wide vector of two packed `f32`.\n    pub struct float32x2_t(2 x pub(crate) f32);\n    /// Arm-specific 64-bit wide vector of one packed `i64`.\n    pub struct int64x1_t(1 x pub(crate) i64);\n    /// Arm-specific 64-bit wide vector of one packed `u64`.\n    pub struct uint64x1_t(1 x pub(crate) u64);\n    /// Arm-specific 64-bit wide vector of one packed `p64`.\n    pub struct poly64x1_t(1 x pub(crate) p64);\n\n    /// Arm-specific 128-bit wide vector of sixteen packed `i8`.\n    pub struct int8x16_t(16 x pub(crate) i8);\n    /// Arm-specific 128-bit wide vector of sixteen packed `u8`.\n    pub struct uint8x16_t(16 x pub(crate) u8);\n    /// Arm-specific 128-bit wide vector of sixteen packed `p8`.\n    pub struct poly8x16_t(16 x pub(crate) p8);\n    /// Arm-specific 128-bit wide vector of eight packed `i16`.\n    pub struct int16x8_t(8 x pub(crate) i16);\n    /// Arm-specific 128-bit wide vector of eight packed `u16`.\n    pub struct uint16x8_t(8 x pub(crate) u16);\n    /// Arm-specific 128-bit wide vector of eight packed `p16`.\n    pub struct poly16x8_t(8 x pub(crate) p16);\n    /// Arm-specific 128-bit wide vector of four packed `i32`.\n    pub struct int32x4_t(4 x pub(crate) i32);\n    /// Arm-specific 128-bit wide vector of four packed `u32`.\n    pub struct uint32x4_t(4 x pub(crate) u32);\n    /// Arm-specific 128-bit wide vector of four packed `f32`.\n    pub struct float32x4_t(4 x pub(crate) f32);\n    /// Arm-specific 128-bit wide vector of two packed `i64`.\n    pub struct int64x2_t(2 x pub(crate) i64);\n    /// Arm-specific 128-bit wide vector of two packed `u64`.\n    pub struct uint64x2_t(2 x pub(crate) u64);\n    /// Arm-specific 128-bit wide vector of two packed `p64`.\n    pub struct poly64x2_t(2 x pub(crate) p64);\n}",
      "defsite": "macro_rules! types {\n    (\n        #![$stability_first:meta]\n        $(\n            #![$stability_more:meta]\n        )*\n\n        $(\n            $(#[$doc:meta])*\n            $(stability: [$stability_already: meta])*\n            pub struct $name:ident($len:literal x $v:vis $elem_type:ty);\n        )*\n    ) => (types! {\n        $(\n            #![$stability_more]\n        )*\n\n        $(\n            $(#[$doc])*\n            $(stability: [$stability_already])*\n            stability: [$stability_first]\n            pub struct $name($len x $v $elem_type);\n        )*\n    });\n\n    (\n        $(\n            $(#[$doc:meta])*\n            $(stability: [$stability: meta])+\n            pub struct $name:ident($len:literal x $v:vis $elem_type:ty);\n        )*\n    ) => ($(\n        $(#[$doc])*\n        $(#[$stability])+\n        #[derive(Copy, Clone)]\n        #[allow(non_camel_case_types)]\n        #[repr(simd)]\n        #[allow(clippy::missing_inline_in_public_items)]\n        pub struct $name($v [$elem_type; $len]);\n\n        impl $name {\n            /// Using `my_simd([x; N])` seemingly fails tests,\n            /// so use this internal helper for it instead.\n            #[inline(always)]\n            $v fn splat(value: $elem_type) -> $name {\n                #[derive(Copy, Clone)]\n                #[repr(simd)]\n                struct JustOne([$elem_type; 1]);\n                let one = JustOne([value]);\n                // SAFETY: 0 is always in-bounds because we're shuffling\n                // a simd type with exactly one element.\n                unsafe { simd_shuffle!(one, one, [0; $len]) }\n            }\n\n            /// Returns an array reference containing the entire SIMD vector.\n            $v const fn as_array(&self) -> &[$elem_type; $len] {\n                // SAFETY: this type is just an overaligned `[T; N]` with\n                // potential padding at the end, so pointer casting to a\n                // `&[T; N]` is safe.\n                //\n                // NOTE: This deliberately doesn't just use `&self.0` because it may soon be banned\n                // see https://github.com/rust-lang/compiler-team/issues/838\n                unsafe { &*(self as *const Self as *const [$elem_type; $len]) }\n\n            }\n\n            /// Returns a mutable array reference containing the entire SIMD vector.\n            #[inline]\n            $v fn as_mut_array(&mut self) -> &mut [$elem_type; $len] {\n                // SAFETY: this type is just an overaligned `[T; N]` with\n                // potential padding at the end, so pointer casting to a\n                // `&mut [T; N]` is safe.\n                //\n                // NOTE: This deliberately doesn't just use `&mut self.0` because it may soon be banned\n                // see https://github.com/rust-lang/compiler-team/issues/838\n                unsafe { &mut *(self as *mut Self as *mut [$elem_type; $len]) }\n            }\n        }\n\n        $(#[$stability])+\n        impl crate::fmt::Debug for $name {\n            #[inline]\n            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n                crate::core_arch::simd::debug_simd_finish(f, stringify!($name), self.as_array())\n            }\n        }\n    )*);\n}"
    }
  ]
}
