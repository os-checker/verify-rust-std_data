{
  "file": "core/src/array/iter.rs",
  "name": "array::iter::<impl iter::traits::collect::IntoIterator for [usize; 2]>::into_iter",
  "hash": "25157582980489959215611460069903422136",
  "hash_direct": "4453128896151771715643891338108521580",
  "src": "fn into_iter(self) -> Self::IntoIter {\n        // SAFETY: The transmute here is actually safe. The docs of `MaybeUninit`\n        // promise:\n        //\n        // > `MaybeUninit<T>` is guaranteed to have the same size and alignment\n        // > as `T`.\n        //\n        // The docs even show a transmute from an array of `MaybeUninit<T>` to\n        // an array of `T`.\n        //\n        // With that, this initialization satisfies the invariants.\n        //\n        // FIXME: If normal `transmute` ever gets smart enough to allow this\n        // directly, use it instead of `transmute_unchecked`.\n        let data: [MaybeUninit<T>; N] = unsafe { transmute_unchecked(self) };\n        // SAFETY: The original array was entirely initialized and the the alive\n        // range we're passing here represents that fact.\n        let inner = unsafe { InnerSized::new_unchecked(IndexRange::zero_to(N), data) };\n        IntoIter { inner }\n    }",
  "callees": [
    "129934805316762061352056491888055415965",
    "97912592448095803783191936410021855138"
  ]
}
