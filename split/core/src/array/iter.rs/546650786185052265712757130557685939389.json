{
  "file": "core/src/array/iter.rs",
  "name": "array::iter::<impl iter::traits::collect::IntoIterator for [bool; 32]>::into_iter",
  "hash": "546650786185052265712757130557685939389",
  "hash_direct": "101366486869422854541435355315328014915",
  "src": "fn into_iter(self) -> Self::IntoIter {\n        // SAFETY: The transmute here is actually safe. The docs of `MaybeUninit`\n        // promise:\n        //\n        // > `MaybeUninit<T>` is guaranteed to have the same size and alignment\n        // > as `T`.\n        //\n        // The docs even show a transmute from an array of `MaybeUninit<T>` to\n        // an array of `T`.\n        //\n        // With that, this initialization satisfies the invariants.\n        //\n        // FIXME: If normal `transmute` ever gets smart enough to allow this\n        // directly, use it instead of `transmute_unchecked`.\n        let data: [MaybeUninit<T>; N] = unsafe { transmute_unchecked(self) };\n        // SAFETY: The original array was entirely initialized and the the alive\n        // range we're passing here represents that fact.\n        let inner = unsafe { InnerSized::new_unchecked(IndexRange::zero_to(N), data) };\n        IntoIter { inner }\n    }",
  "callees": [
    "1522192272304705738915760941586159311447",
    "97912592448095803783191936410021855138"
  ]
}
