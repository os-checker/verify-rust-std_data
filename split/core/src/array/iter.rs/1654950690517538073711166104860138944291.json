{
  "file": "core/src/array/iter.rs",
  "name": "array::iter::<impl iter::traits::collect::IntoIterator for [u8; 16]>::into_iter",
  "hash": "1654950690517538073711166104860138944291",
  "hash_direct": "1405313808825552600814100763890335290830",
  "src": "fn into_iter(self) -> Self::IntoIter {\n        // SAFETY: The transmute here is actually safe. The docs of `MaybeUninit`\n        // promise:\n        //\n        // > `MaybeUninit<T>` is guaranteed to have the same size and alignment\n        // > as `T`.\n        //\n        // The docs even show a transmute from an array of `MaybeUninit<T>` to\n        // an array of `T`.\n        //\n        // With that, this initialization satisfies the invariants.\n        //\n        // FIXME: If normal `transmute` ever gets smart enough to allow this\n        // directly, use it instead of `transmute_unchecked`.\n        let data: [MaybeUninit<T>; N] = unsafe { transmute_unchecked(self) };\n        // SAFETY: The original array was entirely initialized and the the alive\n        // range we're passing here represents that fact.\n        let inner = unsafe { InnerSized::new_unchecked(IndexRange::zero_to(N), data) };\n        IntoIter { inner }\n    }",
  "callees": [
    "1533343645350966936911467293851075966530",
    "807459588385208510417001782946551009910"
  ]
}
