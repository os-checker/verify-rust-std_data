{
  "file": "core/src/ptr/mut_ptr.rs",
  "name": "ptr::mut_ptr::verify::check_mut_offset_tuple_4::{constant#0}",
  "hash": "77650580618723884366059087750902530431",
  "hash_direct": "84924338814569838124177438912410038752",
  "src": "BUF_SIZE",
  "macro_backtrace": [
    {
      "callsite": "generate_single_arithmetic_harness!($ty, $offset_fn_name, offset, isize)",
      "defsite": "macro_rules! generate_single_arithmetic_harness {\n        ($ty:ty, $proof_name:ident, $fn_name:ident, $count_ty:ty) => {\n            #[kani::proof_for_contract(<*mut $ty>::$fn_name)]\n            pub fn $proof_name() {\n                // 200 bytes are large enough to cover all pointee types used for testing\n                const BUF_SIZE: usize = 200;\n                let mut generator = kani::PointerGenerator::<BUF_SIZE>::new();\n                let test_ptr: *mut $ty = generator.any_in_bounds().ptr;\n                let count: $count_ty = kani::any();\n                unsafe {\n                    test_ptr.$fn_name(count);\n                }\n            }\n        };\n    }"
    },
    {
      "callsite": "generate_arithmetic_harnesses!(\n        (i8, u16, i32, u64, isize),\n        check_mut_add_tuple_4,\n        check_mut_sub_tuple_4,\n        check_mut_offset_tuple_4\n    )",
      "defsite": "macro_rules! generate_arithmetic_harnesses {\n        ($ty:ty, $add_fn_name:ident, $sub_fn_name:ident, $offset_fn_name:ident) => {\n            generate_single_arithmetic_harness!($ty, $add_fn_name, add, usize);\n            generate_single_arithmetic_harness!($ty, $sub_fn_name, sub, usize);\n            generate_single_arithmetic_harness!($ty, $offset_fn_name, offset, isize);\n        };\n    }"
    }
  ]
}
