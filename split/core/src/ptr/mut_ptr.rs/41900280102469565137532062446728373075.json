{
  "file": "core/src/ptr/mut_ptr.rs",
  "name": "ptr::mut_ptr::<impl *mut u32>::offset",
  "hash": "41900280102469565137532062446728373075",
  "hash_direct": "310816349693825664412950867317593942938",
  "src": "pub const unsafe fn offset(self, count: isize) -> *mut T\n    where\n        T: Sized,\n    {\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_offset_nowrap(this: *const (), count: isize, size: usize) -> bool {\n            // We can use const_eval_select here because this is only for UB checks.\n            const_eval_select!(\n                @capture { this: *const (), count: isize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    // `size` is the size of a Rust type, so we know that\n                    // `size <= isize::MAX` and thus `as` cast here is not lossy.\n                    let Some(byte_offset) = count.checked_mul(size as isize) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add_signed(byte_offset);\n                    !overflow\n                }\n            )\n        }\n\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset requires the address calculation to not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: isize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_offset_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // The obtained pointer is valid for writes since the caller must\n        // guarantee that it points to the same allocation as `self`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
  "callees": [
    "258820287469578611817448591488600041899",
    "588974892899239543415856878986124229421",
    "690438059002452523915046149102377829082",
    "17421822894816687532325615181214565887",
    "54154472898647204275063978094886352344",
    "23815256893174302637797703719499456373",
    "99603598099498707762068107842012164044",
    "23965720822326553157987339842804223213",
    "100741573661083166254739259634530598920",
    "125312877505429677902664359715729802479",
    "134048071163561259015400767089042556532",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "478753423337745817613297159272845606672",
    "3658730781980743391697756456907208995",
    "176386771705132260856587306647620489942",
    "1196818748413488714617327481547726400252",
    "102984949158583100726881210630296696920",
    "739520556846959085018120036998133255835"
  ]
}
