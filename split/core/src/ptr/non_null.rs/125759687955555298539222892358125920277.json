{
  "file": "core/src/ptr/non_null.rs",
  "name": "ptr::non_null::verify::non_null_check_write_bytes_u32::ARR_SIZE",
  "hash": "125759687955555298539222892358125920277",
  "hash_direct": "104595128207475961829572983969361799013",
  "src": "const ARR_SIZE: usize = mem::size_of::<$type>() * 10;",
  "macro_backtrace": [
    {
      "callsite": "generate_write_bytes_harness!(u32, non_null_check_write_bytes_u32)",
      "defsite": "macro_rules! generate_write_bytes_harness {\n        ($type:ty, $harness_name:ident) => {\n            #[kani::proof_for_contract(NonNull::write_bytes)]\n            pub fn $harness_name() {\n                // Create a pointer generator for the given type with appropriate byte size\n                const ARR_SIZE: usize = mem::size_of::<$type>() * 10;\n                let mut generator = kani::PointerGenerator::<ARR_SIZE>::new();\n\n                // Get a raw pointer from the generator\n                let raw_ptr: *mut $type = generator.any_in_bounds().ptr;\n\n                // Create a non-null pointer from the raw pointer\n                let ptr = NonNull::new(raw_ptr).unwrap();\n\n                // Create a non-deterministic value to write\n                let val: u8 = kani::any();\n\n                // Create a non-deterministic count\n                let count: usize = kani::any();\n\n                unsafe {\n                    // Perform the volatile write operation\n                    ptr.write_bytes(val, count);\n\n                    // Create a non-deterministic count\n                    let i: usize = kani::any_where(|&x| x < count * mem::size_of::<$type>());\n                    let ptr_byte = ptr.as_ptr() as *const u8;\n\n                    // Read back the value and assert it's correct\n                    assert_eq!(*ptr_byte.add(i), val);\n                }\n            }\n        };\n    }"
    }
  ],
  "callees": [
    "107365534946901948286099583667090509800"
  ]
}
