{
  "file": "core/src/ffi/c_str.rs",
  "name": "core::ffi::CStr::from_bytes_with_nul_unchecked",
  "hash": "156185049005844516004618515819961803783",
  "hash_direct": "148172767246780937415905991104827224396",
  "src": "pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n        const_eval_select!(\n            @capture { bytes: &[u8] } -> &CStr:\n            if const {\n                // Saturating so that an empty slice panics in the assert with a good\n                // message, not here due to underflow.\n                let mut i = bytes.len().saturating_sub(1);\n                assert!(!bytes.is_empty() && bytes[i] == 0, \"input was not nul-terminated\");\n\n                // Ending nul byte exists, skip to the rest.\n                while i != 0 {\n                    i -= 1;\n                    let byte = bytes[i];\n                    assert!(byte != 0, \"input contained interior nul\");\n                }\n\n                // SAFETY: See runtime cast comment below.\n                unsafe { &*(bytes as *const [u8] as *const CStr) }\n            } else {\n                // Chance at catching some UB at runtime with debug builds.\n                debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n\n                // SAFETY: Casting to CStr is safe because its internal representation\n                // is a [u8] too (safe only inside std).\n                // Dereferencing the obtained pointer is safe because it comes from a\n                // reference. Making a reference is then safe because its lifetime\n                // is bound by the lifetime of the given `bytes`.\n                unsafe { &*(bytes as *const [u8] as *const CStr) }\n            }\n        )\n    }",
  "callees": [
    "12281449246394340237926324936375242532",
    "1490027963559579749512597231717514721000",
    "986792852990965178117440249555081278778",
    "90818112465881722349174357944217011292",
    "170281423934441608902372914597711355436",
    "146612017564224181584303574960223420416",
    "9611486168658861280835191277977503500"
  ]
}
