{
  "file": "core/src/ffi/c_str.rs",
  "name": "ffi::c_str::CStr::from_bytes_with_nul_unchecked",
  "hash": "1415910049690716785513886528048196455006",
  "hash_direct": "1023844074989221990511750510789778884378",
  "src": "pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n        const_eval_select!(\n            @capture { bytes: &[u8] } -> &CStr:\n            if const {\n                // Saturating so that an empty slice panics in the assert with a good\n                // message, not here due to underflow.\n                let mut i = bytes.len().saturating_sub(1);\n                assert!(!bytes.is_empty() && bytes[i] == 0, \"input was not nul-terminated\");\n\n                // Ending nul byte exists, skip to the rest.\n                while i != 0 {\n                    i -= 1;\n                    let byte = bytes[i];\n                    assert!(byte != 0, \"input contained interior nul\");\n                }\n\n                // SAFETY: See runtime cast comment below.\n                unsafe { &*(bytes as *const [u8] as *const CStr) }\n            } else {\n                // Chance at catching some UB at runtime with debug builds.\n                debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n\n                // SAFETY: Casting to CStr is safe because its internal representation\n                // is a [u8] too (safe only inside std).\n                // Dereferencing the obtained pointer is safe because it comes from a\n                // reference. Making a reference is then safe because its lifetime\n                // is bound by the lifetime of the given `bytes`.\n                unsafe { &*(bytes as *const [u8] as *const CStr) }\n            }\n        )\n    }",
  "callees": [
    "258820287469578611817448591488600041899",
    "720060476441237402215515899558286829373",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "243931809744896974812513529918607549579",
    "1752989996936949203916036071159051010960",
    "497499364745128359314402117207900903418"
  ]
}
