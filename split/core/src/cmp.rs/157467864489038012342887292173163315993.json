{
  "file": "core/src/cmp.rs",
  "name": "cmp::impls::<impl cmp::PartialOrd for f64>::__chaining_le",
  "hash": "157467864489038012342887292173163315993",
  "hash_direct": "163317999705726505105347925974282247914",
  "src": "fn __chaining_le(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs <= rhs) }\n            }",
  "macro_backtrace": [
    {
      "callsite": "partial_ord_methods_primitive_impl!()",
      "defsite": "macro_rules! partial_ord_methods_primitive_impl {\n        () => {\n            #[inline(always)]\n            fn lt(&self, other: &Self) -> bool { *self <  *other }\n            #[inline(always)]\n            fn le(&self, other: &Self) -> bool { *self <= *other }\n            #[inline(always)]\n            fn gt(&self, other: &Self) -> bool { *self >  *other }\n            #[inline(always)]\n            fn ge(&self, other: &Self) -> bool { *self >= *other }\n\n            // These implementations are the same for `Ord` or `PartialOrd` types\n            // because if either is NAN the `==` test will fail so we end up in\n            // the `Break` case and the comparison will correctly return `false`.\n\n            #[inline]\n            fn __chaining_lt(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs < rhs) }\n            }\n            #[inline]\n            fn __chaining_le(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs <= rhs) }\n            }\n            #[inline]\n            fn __chaining_gt(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs > rhs) }\n            }\n            #[inline]\n            fn __chaining_ge(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs >= rhs) }\n            }\n        };\n    }"
    },
    {
      "callsite": "partial_ord_impl! { f16 f32 f64 f128 }",
      "defsite": "macro_rules! partial_ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n                    match (*self <= *other, *self >= *other) {\n                        (false, false) => None,\n                        (false, true) => Some(Greater),\n                        (true, false) => Some(Less),\n                        (true, true) => Some(Equal),\n                    }\n                }\n\n                partial_ord_methods_primitive_impl!();\n            }\n        )*)\n    }"
    }
  ]
}
