{
  "file": "core/src/cmp.rs",
  "name": "cmp::impls::<impl cmp::PartialOrd for bool>::__chaining_le",
  "hash": "177529187826170619114976296329021118707",
  "hash_direct": "41631026053793516338903787124260899015",
  "src": "fn __chaining_le(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs <= rhs) }\n            }",
  "macro_backtrace": [
    {
      "callsite": "partial_ord_methods_primitive_impl!()",
      "defsite": "macro_rules! partial_ord_methods_primitive_impl {\n        () => {\n            #[inline(always)]\n            fn lt(&self, other: &Self) -> bool { *self <  *other }\n            #[inline(always)]\n            fn le(&self, other: &Self) -> bool { *self <= *other }\n            #[inline(always)]\n            fn gt(&self, other: &Self) -> bool { *self >  *other }\n            #[inline(always)]\n            fn ge(&self, other: &Self) -> bool { *self >= *other }\n\n            // These implementations are the same for `Ord` or `PartialOrd` types\n            // because if either is NAN the `==` test will fail so we end up in\n            // the `Break` case and the comparison will correctly return `false`.\n\n            #[inline]\n            fn __chaining_lt(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs < rhs) }\n            }\n            #[inline]\n            fn __chaining_le(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs <= rhs) }\n            }\n            #[inline]\n            fn __chaining_gt(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs > rhs) }\n            }\n            #[inline]\n            fn __chaining_ge(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs >= rhs) }\n            }\n        };\n    }"
    }
  ]
}
