{
  "file": "core/src/panicking.rs",
  "name": "panicking::panic_const::panic_const_rem_overflow",
  "hash": "1112274134915535276716097379666871971188",
  "hash_direct": "938965432495862039117131287861221995007",
  "src": "pub const fn $lang() -> ! {\n                // Use Arguments::new_const instead of format_args!(\"{expr}\") to potentially\n                // reduce size overhead. The format_args! macro uses str's Display trait to\n                // write expr, which calls Formatter::pad, which must accommodate string\n                // truncation and padding (even though none is used here). Using\n                // Arguments::new_const may allow the compiler to omit Formatter::pad from the\n                // output binary, saving up to a few kilobytes.\n                panic_fmt(fmt::Arguments::new_const(&[$message]));\n            }",
  "macro_backtrace": [
    {
      "callsite": "panic_const! {\n        panic_const_add_overflow = \"attempt to add with overflow\",\n        panic_const_sub_overflow = \"attempt to subtract with overflow\",\n        panic_const_mul_overflow = \"attempt to multiply with overflow\",\n        panic_const_div_overflow = \"attempt to divide with overflow\",\n        panic_const_rem_overflow = \"attempt to calculate the remainder with overflow\",\n        panic_const_neg_overflow = \"attempt to negate with overflow\",\n        panic_const_shr_overflow = \"attempt to shift right with overflow\",\n        panic_const_shl_overflow = \"attempt to shift left with overflow\",\n        panic_const_div_by_zero = \"attempt to divide by zero\",\n        panic_const_rem_by_zero = \"attempt to calculate the remainder with a divisor of zero\",\n        panic_const_coroutine_resumed = \"coroutine resumed after completion\",\n        panic_const_async_fn_resumed = \"`async fn` resumed after completion\",\n        panic_const_async_gen_fn_resumed = \"`async gen fn` resumed after completion\",\n        panic_const_gen_fn_none = \"`gen fn` should just keep returning `None` after completion\",\n        panic_const_coroutine_resumed_panic = \"coroutine resumed after panicking\",\n        panic_const_async_fn_resumed_panic = \"`async fn` resumed after panicking\",\n        panic_const_async_gen_fn_resumed_panic = \"`async gen fn` resumed after panicking\",\n        panic_const_gen_fn_none_panic = \"`gen fn` should just keep returning `None` after panicking\",\n    }",
      "defsite": "macro_rules! panic_const {\n    ($($lang:ident = $message:expr,)+) => {\n        $(\n            /// This is a panic called with a message that's a result of a MIR-produced Assert.\n            //\n            // never inline unless panic_immediate_abort to avoid code\n            // bloat at the call sites as much as possible\n            #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n            #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n            #[track_caller]\n            #[rustc_const_stable_indirect] // must follow stable const rules since it is exposed to stable\n            #[lang = stringify!($lang)]\n            pub const fn $lang() -> ! {\n                // Use Arguments::new_const instead of format_args!(\"{expr}\") to potentially\n                // reduce size overhead. The format_args! macro uses str's Display trait to\n                // write expr, which calls Formatter::pad, which must accommodate string\n                // truncation and padding (even though none is used here). Using\n                // Arguments::new_const may allow the compiler to omit Formatter::pad from the\n                // output binary, saving up to a few kilobytes.\n                panic_fmt(fmt::Arguments::new_const(&[$message]));\n            }\n        )+\n    }\n}"
    }
  ],
  "callees": [
    "258820287469578611817448591488600041899",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "1752989996936949203916036071159051010960"
  ]
}
