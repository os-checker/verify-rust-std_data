{
  "file": "core/src/fmt/num.rs",
  "name": "fmt::num::<impl fmt::Binary for usize>::fmt::MAX_DIG_N",
  "hash": "22221866844457811210485443430561793081",
  "hash_direct": "91332229750293510357528398605532925903",
  "src": "const MAX_DIG_N: usize = $Unsigned::MAX.ilog(BASE) as usize + 1;",
  "macro_backtrace": [
    {
      "callsite": "radix_integer! { fmt::Binary   for $Signed and $Unsigned, \"0b\", b\"01\" }",
      "defsite": "macro_rules! radix_integer {\n    (fmt::$Trait:ident for $Signed:ident and $Unsigned:ident, $prefix:literal, $dig_tab:literal) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::$Trait for $Unsigned {\n            /// Format unsigned integers in the radix.\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                // Check macro arguments at compile time.\n                const {\n                    assert!($Unsigned::MIN == 0, \"need unsigned\");\n                    assert!($dig_tab.is_ascii(), \"need single-byte entries\");\n                }\n\n                // ASCII digits in ascending order are used as a lookup table.\n                const DIG_TAB: &[u8] = $dig_tab;\n                const BASE: $Unsigned = DIG_TAB.len() as $Unsigned;\n                const MAX_DIG_N: usize = $Unsigned::MAX.ilog(BASE) as usize + 1;\n\n                // Buffer digits of self with right alignment.\n                let mut buf = [MaybeUninit::<u8>::uninit(); MAX_DIG_N];\n                // Count the number of bytes in buf that are not initialized.\n                let mut offset = buf.len();\n\n                // Accumulate each digit of the number from the least\n                // significant to the most significant figure.\n                let mut remain = *self;\n                loop {\n                    let digit = remain % BASE;\n                    remain /= BASE;\n\n                    offset -= 1;\n                    // SAFETY: `remain` will reach 0 and we will break before `offset` wraps\n                    unsafe { core::hint::assert_unchecked(offset < buf.len()) }\n                    buf[offset].write(DIG_TAB[digit as usize]);\n                    if remain == 0 {\n                        break;\n                    }\n                }\n\n                // SAFETY: Starting from `offset`, all elements of the slice have been set.\n                let digits = unsafe { slice_buffer_to_str(&buf, offset) };\n                f.pad_integral(true, $prefix, digits)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::$Trait for $Signed {\n            /// Format signed integers in the twoâ€™s-complement form.\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt::$Trait::fmt(&self.cast_unsigned(), f)\n            }\n        }\n    };\n}"
    },
    {
      "callsite": "radix_integers! { isize, usize }",
      "defsite": "macro_rules! radix_integers {\n    ($Signed:ident, $Unsigned:ident) => {\n        radix_integer! { fmt::Binary   for $Signed and $Unsigned, \"0b\", b\"01\" }\n        radix_integer! { fmt::Octal    for $Signed and $Unsigned, \"0o\", b\"01234567\" }\n        radix_integer! { fmt::LowerHex for $Signed and $Unsigned, \"0x\", b\"0123456789abcdef\" }\n        radix_integer! { fmt::UpperHex for $Signed and $Unsigned, \"0x\", b\"0123456789ABCDEF\" }\n    };\n}"
    }
  ],
  "callees": [
    "258820287469578611817448591488600041899",
    "161471355705627237862978749312689296849",
    "158246978011874018401184128103796590386",
    "177450053108937244256024058949791559633",
    "50186211171463953727684864518369695334",
    "113105628410323550903289764020827107190",
    "7890666119737191484082000720043292310",
    "34410515695185066949979771014252260096",
    "72490371355961874097123965084721395404",
    "82673335129552629317708046730690637448",
    "63508941524203719206996976005100287210",
    "1676806814539779643518083197252466559589",
    "1509394244843405577312733053705693096857",
    "157682230385057029222012884580308215814",
    "50583337313053329404845503660603560676",
    "1387049698665817112911212442041530342318",
    "150614045265181541127113376896708745784",
    "110569385689116215472222297445961327594",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "1752989996936949203916036071159051010960"
  ]
}
