{
  "file": "core/src/fmt/num.rs",
  "name": "core::fmt::num::<impl u128>::_fmt_inner",
  "hash": "1647661894342132915511682461261599936511",
  "hash_direct": "3736264842198867080178979170113553195",
  "src": "unsafe fn _fmt_inner(self, buf: &mut [MaybeUninit<u8>]) -> usize {\n        // Optimize common-case zero, which would also need special treatment due to\n        // its \"leading\" zero.\n        if self == 0 {\n            let offset = buf.len() - 1;\n            buf[offset].write(b'0');\n            return offset;\n        }\n        // Take the 16 least-significant decimals.\n        let (quot_1e16, mod_1e16) = div_rem_1e16(self);\n        let (mut remain, mut offset) = if quot_1e16 == 0 {\n            (mod_1e16, U128_MAX_DEC_N)\n        } else {\n            // Write digits at buf[23..39].\n            enc_16lsd::<{ U128_MAX_DEC_N - 16 }>(buf, mod_1e16);\n\n            // Take another 16 decimals.\n            let (quot2, mod2) = div_rem_1e16(quot_1e16);\n            if quot2 == 0 {\n                (mod2, U128_MAX_DEC_N - 16)\n            } else {\n                // Write digits at buf[7..23].\n                enc_16lsd::<{ U128_MAX_DEC_N - 32 }>(buf, mod2);\n                // Quot2 has at most 7 decimals remaining after two 1e16 divisions.\n                (quot2 as u64, U128_MAX_DEC_N - 32)\n            }\n        };\n\n        // Format per four digits from the lookup table.\n        while remain > 999 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the while condition ensures at least 4 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 4) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 4;\n\n            // pull two pairs\n            let quad = remain % 1_00_00;\n            remain /= 1_00_00;\n            let pair1 = (quad / 100) as usize;\n            let pair2 = (quad % 100) as usize;\n            buf[offset + 0].write(DEC_DIGITS_LUT[pair1 * 2 + 0]);\n            buf[offset + 1].write(DEC_DIGITS_LUT[pair1 * 2 + 1]);\n            buf[offset + 2].write(DEC_DIGITS_LUT[pair2 * 2 + 0]);\n            buf[offset + 3].write(DEC_DIGITS_LUT[pair2 * 2 + 1]);\n        }\n\n        // Format per two digits from the lookup table.\n        if remain > 9 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the if condition ensures at least 2 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 2) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 2;\n\n            let pair = (remain % 100) as usize;\n            remain /= 100;\n            buf[offset + 0].write(DEC_DIGITS_LUT[pair * 2 + 0]);\n            buf[offset + 1].write(DEC_DIGITS_LUT[pair * 2 + 1]);\n        }\n\n        // Format the last remaining digit, if any.\n        if remain != 0 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the if condition ensures (at least) 1 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 1) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 1;\n\n            // Either the compiler sees that remain < 10, or it prevents\n            // a boundary check up next.\n            let last = (remain & 15) as usize;\n            buf[offset].write(DEC_DIGITS_LUT[last * 2 + 1]);\n            // not used: remain = 0;\n        }\n        offset\n    }",
  "callees": [
    "1760151968317278624513482005825546212798",
    "880347923830951464018056501778113268352",
    "1715385450526401173613789923354548545737",
    "159107826280106441007536910513904739607",
    "12281449246394340237926324936375242532",
    "1511275866077199755612412536318849312657",
    "515486415817055195118014195310921268556",
    "865650104295848903112749528189008460635",
    "56234286929832465845177810217708365466",
    "1680344847910503610811390711953062113319",
    "920980127064672019717947646353794366525",
    "237214894484340491810317590408953069357",
    "181267529910573756716102767087485333561",
    "1824545319189397521315695847785602896178",
    "25554929025457378716042267507361008869",
    "175902738860881228615483607864010986597",
    "129027694980846849712294755095785889196",
    "163079746810750480252313458600207514496",
    "145589541181952283159784619082887052114",
    "222725598122421332810622840183709038894",
    "146105268075378471708202374381697028730",
    "1783063548588688153116995795572290282049",
    "150383753068814596569264868079480481094",
    "3714502462799217998678305421388049861",
    "128930257668633610949042071217647527954",
    "1837487256702924366516621837105674076094",
    "1280882188983045088011313959657552301821",
    "833383471550491847117525988933795166554",
    "167910853247077084511525459714317297900",
    "8358020412969843293369480817801214853",
    "1483436051876589682917815592106303415640",
    "986792852990965178117440249555081278778",
    "90818112465881722349174357944217011292",
    "63085389524472853348886374617170044294",
    "8787952082428538504365079471726452107",
    "180635224128130815714204029673366671286",
    "112989397975222255532054380452996322405"
  ]
}
