{
  "file": "core/src/fmt/num.rs",
  "name": "fmt::num::<impl u128>::_fmt_inner",
  "hash": "149028898773389889316671473901339999257",
  "hash_direct": "1052093314282269772915426377115322280839",
  "src": "unsafe fn _fmt_inner(self, buf: &mut [MaybeUninit<u8>]) -> usize {\n        // Optimize common-case zero, which would also need special treatment due to\n        // its \"leading\" zero.\n        if self == 0 {\n            let offset = buf.len() - 1;\n            buf[offset].write(b'0');\n            return offset;\n        }\n        // Take the 16 least-significant decimals.\n        let (quot_1e16, mod_1e16) = div_rem_1e16(self);\n        let (mut remain, mut offset) = if quot_1e16 == 0 {\n            (mod_1e16, U128_MAX_DEC_N)\n        } else {\n            // Write digits at buf[23..39].\n            enc_16lsd::<{ U128_MAX_DEC_N - 16 }>(buf, mod_1e16);\n\n            // Take another 16 decimals.\n            let (quot2, mod2) = div_rem_1e16(quot_1e16);\n            if quot2 == 0 {\n                (mod2, U128_MAX_DEC_N - 16)\n            } else {\n                // Write digits at buf[7..23].\n                enc_16lsd::<{ U128_MAX_DEC_N - 32 }>(buf, mod2);\n                // Quot2 has at most 7 decimals remaining after two 1e16 divisions.\n                (quot2 as u64, U128_MAX_DEC_N - 32)\n            }\n        };\n\n        // Format per four digits from the lookup table.\n        while remain > 999 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the while condition ensures at least 4 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 4) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 4;\n\n            // pull two pairs\n            let quad = remain % 1_00_00;\n            remain /= 1_00_00;\n            let pair1 = (quad / 100) as usize;\n            let pair2 = (quad % 100) as usize;\n            buf[offset + 0].write(DEC_DIGITS_LUT[pair1 * 2 + 0]);\n            buf[offset + 1].write(DEC_DIGITS_LUT[pair1 * 2 + 1]);\n            buf[offset + 2].write(DEC_DIGITS_LUT[pair2 * 2 + 0]);\n            buf[offset + 3].write(DEC_DIGITS_LUT[pair2 * 2 + 1]);\n        }\n\n        // Format per two digits from the lookup table.\n        if remain > 9 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the if condition ensures at least 2 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 2) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 2;\n\n            let pair = (remain % 100) as usize;\n            remain /= 100;\n            buf[offset + 0].write(DEC_DIGITS_LUT[pair * 2 + 0]);\n            buf[offset + 1].write(DEC_DIGITS_LUT[pair * 2 + 1]);\n        }\n\n        // Format the last remaining digit, if any.\n        if remain != 0 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the if condition ensures (at least) 1 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 1) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 1;\n\n            // Either the compiler sees that remain < 10, or it prevents\n            // a boundary check up next.\n            let last = (remain & 15) as usize;\n            buf[offset].write(DEC_DIGITS_LUT[last * 2 + 1]);\n            // not used: remain = 0;\n        }\n        offset\n    }",
  "callees": [
    "155146884437592745449279657258619050520",
    "174302085048697978214413762393835295720",
    "26628196080497732386784756501221452934",
    "1282137949575380123615915439870569752282",
    "258820287469578611817448591488600041899",
    "6962362284417680556415378392413733050",
    "1049863653024822663415096848776233585763",
    "56064935532181582357217772644767711324",
    "1215867595331634964412092261842216784704",
    "96480950455274538863936471544432656148",
    "1424635015723676172711879731863681352571",
    "241158160377170312612713914729750498491",
    "17421822894816687532325615181214565887",
    "23815256893174302637797703719499456373",
    "167165721111217593893743718785627578467",
    "111893148674317480745590608994062193214",
    "2266474927748722104589482484269181849",
    "106331898439077953744539516180016762298",
    "117885714964136718011412517610531756244",
    "24502394795559680767584204508227377419",
    "90771261734924938883465308637020449641",
    "507116607738930391111587036035165972673",
    "1605633131122579720611961448336401474874",
    "899089149104620122910782754756910095497",
    "564177479688813429716564910718645657356",
    "126601631307930206616972114137702790273",
    "17848087583919573713734014073660267158",
    "137225128760155526151671631170232111377",
    "25753467031478257716949736687562054564",
    "1204668293620499224013336883119093261459",
    "171593739300022194915526452191835401234",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "478753423337745817613297159272845606672",
    "36990817497430174858508344623774643994",
    "621698472431332816417792581602959129152",
    "739520556846959085018120036998133255835"
  ]
}
