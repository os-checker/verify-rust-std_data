{
  "file": "core/src/fmt/num.rs",
  "name": "fmt::num::_",
  "hash": "106092759864761577445116387610199634000",
  "hash_direct": "182832579444701321363303677855828210465",
  "src": "const _: () = assert!($T::MIN == 0, \"need unsigned\");",
  "macro_backtrace": [
    {
      "callsite": "impl_Exp!(i128, u128; as u128 into exp_u128)",
      "defsite": "macro_rules! impl_Exp {\n    ($($Signed:ident, $Unsigned:ident),* ; as $T:ident into $fmt_fn:ident) => {\n        const _: () = assert!($T::MIN == 0, \"need unsigned\");\n\n        fn $fmt_fn(\n            f: &mut fmt::Formatter<'_>,\n            n: $T,\n            is_nonnegative: bool,\n            letter_e: u8\n        ) -> fmt::Result {\n            debug_assert!(letter_e.is_ascii_alphabetic(), \"single-byte character\");\n\n            // Print the integer as a coefficient in range (-10, 10).\n            let mut exp = n.checked_ilog10().unwrap_or(0) as usize;\n            debug_assert!(n / (10 as $T).pow(exp as u32) < 10);\n\n            // Precisison is counted as the number of digits in the fraction.\n            let mut coef_prec = exp;\n            // Keep the digits as an integer (paired with its coef_prec count).\n            let mut coef = n;\n\n            // A Formatter may set the precision to a fixed number of decimals.\n            let more_prec = match f.precision() {\n                None => {\n                    // Omit any and all trailing zeroes.\n                    while coef_prec != 0 && coef % 10 == 0 {\n                        coef /= 10;\n                        coef_prec -= 1;\n                    }\n                    0\n                },\n\n                Some(fmt_prec) if fmt_prec >= coef_prec => {\n                    // Count the number of additional zeroes needed.\n                    fmt_prec - coef_prec\n                },\n\n                Some(fmt_prec) => {\n                    // Count the number of digits to drop.\n                    let less_prec = coef_prec - fmt_prec;\n                    assert!(less_prec > 0);\n                    // Scale down the coefficient/precision pair. For example,\n                    // coef 123456 gets coef_prec 5 (to make 1.23456). To format\n                    // the number with 2 decimals, i.e., fmt_prec 2, coef should\n                    // be scaled by 10⁵⁻²=1000 to get coef 123 with coef_prec 2.\n\n                    // SAFETY: Any precision less than coef_prec will cause a\n                    // power of ten below the coef value.\n                    let scale = unsafe {\n                        (10 as $T).checked_pow(less_prec as u32).unwrap_unchecked()\n                    };\n                    let floor = coef / scale;\n                    // Round half to even conform documentation.\n                    let over = coef % scale;\n                    let half = scale / 2;\n                    let round_up = if over < half {\n                        0\n                    } else if over > half {\n                        1\n                    } else {\n                        floor & 1 // round odd up to even\n                    };\n                    // Adding one to a scale down of at least 10 won't overflow.\n                    coef = floor + round_up;\n                    coef_prec = fmt_prec;\n\n                    // The round_up may have caused the coefficient to reach 10\n                    // (which is not permitted). For example, anything in range\n                    // [9.95, 10) becomes 10.0 when adjusted to precision 1.\n                    if round_up != 0 && coef.checked_ilog10().unwrap_or(0) as usize > coef_prec {\n                        debug_assert_eq!(coef, (10 as $T).pow(coef_prec as u32 + 1));\n                        coef /= 10; // drop one trailing zero\n                        exp += 1;   // one power of ten higher\n                    }\n                    0\n                },\n            };\n\n            // Allocate a text buffer with lazy initialization.\n            const MAX_DEC_N: usize = $T::MAX.ilog10() as usize + 1;\n            const MAX_COEF_LEN: usize = MAX_DEC_N + \".\".len();\n            const MAX_TEXT_LEN: usize = MAX_COEF_LEN + \"e99\".len();\n            let mut buf = [MaybeUninit::<u8>::uninit(); MAX_TEXT_LEN];\n\n            // Encode the coefficient in buf[..coef_len].\n            let (lead_dec, coef_len) = if coef_prec == 0 && more_prec == 0 {\n                (coef, 1_usize) // single digit; no fraction\n            } else {\n                buf[1].write(b'.');\n                let fraction_range = 2..(2 + coef_prec);\n\n                // Consume the least-significant decimals from a working copy.\n                let mut remain = coef;\n                #[cfg(feature = \"optimize_for_size\")] {\n                    for i in fraction_range.clone().rev() {\n                        let digit = (remain % 10) as usize;\n                        remain /= 10;\n                        buf[i].write(b'0' + digit as u8);\n                    }\n                }\n                #[cfg(not(feature = \"optimize_for_size\"))] {\n                    // Write digits per two at a time with a lookup table.\n                    for i in fraction_range.clone().skip(1).rev().step_by(2) {\n                        let pair = (remain % 100) as usize;\n                        remain /= 100;\n                        buf[i - 1].write(DECIMAL_PAIRS[pair * 2 + 0]);\n                        buf[i - 0].write(DECIMAL_PAIRS[pair * 2 + 1]);\n                    }\n                    // An odd number of digits leave one digit remaining.\n                    if coef_prec & 1 != 0 {\n                        let digit = (remain % 10) as usize;\n                        remain /= 10;\n                        buf[fraction_range.start].write(b'0' + digit as u8);\n                    }\n                }\n\n                (remain, fraction_range.end)\n            };\n            debug_assert!(lead_dec < 10);\n            debug_assert!(lead_dec != 0 || coef == 0, \"significant digits only\");\n            buf[0].write(b'0' + lead_dec as u8);\n\n            // SAFETY: The number of decimals is limited, captured by MAX.\n            unsafe { core::hint::assert_unchecked(coef_len <= MAX_COEF_LEN) }\n            // Encode the scale factor in buf[coef_len..text_len].\n            buf[coef_len].write(letter_e);\n            let text_len: usize = match exp {\n                ..10 => {\n                    buf[coef_len + 1].write(b'0' + exp as u8);\n                    coef_len + 2\n                },\n                10..100 => {\n                    #[cfg(feature = \"optimize_for_size\")] {\n                        buf[coef_len + 1].write(b'0' + (exp / 10) as u8);\n                        buf[coef_len + 2].write(b'0' + (exp % 10) as u8);\n                    }\n                    #[cfg(not(feature = \"optimize_for_size\"))] {\n                        buf[coef_len + 1].write(DECIMAL_PAIRS[exp * 2 + 0]);\n                        buf[coef_len + 2].write(DECIMAL_PAIRS[exp * 2 + 1]);\n                    }\n                    coef_len + 3\n                },\n                _ => {\n                    const { assert!($T::MAX.ilog10() < 100) };\n                    // SAFETY: A `u256::MAX` would get exponent 77.\n                    unsafe { core::hint::unreachable_unchecked() }\n                }\n            };\n            // SAFETY: All bytes up until text_len have been set.\n            let text = unsafe { buf[..text_len].assume_init_ref() };\n\n            if more_prec == 0 {\n                // SAFETY: Text is set with ASCII exclusively: either a decimal,\n                // or a LETTER_E, or a dot. ASCII implies valid UTF-8.\n                let as_str = unsafe { str::from_utf8_unchecked(text) };\n                f.pad_integral(is_nonnegative, \"\", as_str)\n            } else {\n                let parts = &[\n                    numfmt::Part::Copy(&text[..coef_len]),\n                    numfmt::Part::Zero(more_prec),\n                    numfmt::Part::Copy(&text[coef_len..]),\n                ];\n                let sign = if !is_nonnegative {\n                    \"-\"\n                } else if f.sign_plus() {\n                    \"+\"\n                } else {\n                    \"\"\n                };\n                // SAFETY: Text is set with ASCII exclusively: either a decimal,\n                // or a LETTER_E, or a dot. ASCII implies valid UTF-8.\n                unsafe { f.pad_formatted_parts(&numfmt::Formatted { sign, parts }) }\n            }\n        }\n\n        $(\n        const _: () = {\n            assert!($Signed::MIN < 0, \"need signed\");\n            assert!($Unsigned::MIN == 0, \"need unsigned\");\n            assert!($Signed::BITS == $Unsigned::BITS, \"need counterparts\");\n            assert!($Signed::BITS <= $T::BITS, \"need lossless conversion\");\n            assert!($Unsigned::BITS <= $T::BITS, \"need lossless conversion\");\n        };\n        #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n        impl fmt::LowerExp for $Signed {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                $fmt_fn(f, self.unsigned_abs() as $T, *self >= 0, b'e')\n            }\n        }\n        #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n        impl fmt::LowerExp for $Unsigned {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                $fmt_fn(f, *self as $T, true, b'e')\n            }\n        }\n        #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n        impl fmt::UpperExp for $Signed {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                $fmt_fn(f, self.unsigned_abs() as $T, *self >= 0, b'E')\n            }\n        }\n        #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n        impl fmt::UpperExp for $Unsigned {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                $fmt_fn(f, *self as $T, true, b'E')\n            }\n        }\n        )*\n\n    };\n}"
    }
  ],
  "callees": [
    "258820287469578611817448591488600041899",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "1752989996936949203916036071159051010960"
  ]
}
