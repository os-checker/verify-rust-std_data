{
  "file": "core/src/fmt/num.rs",
  "name": "fmt::num::imp::<impl fmt::Display for i64>::fmt::MAX_DEC_N",
  "hash": "142345251111335733087729815593180884586",
  "hash_direct": "100212072467338204232526257166163798544",
  "src": "const MAX_DEC_N: usize = $unsigned::MAX.ilog10() as usize + 1;",
  "macro_backtrace": [
    {
      "callsite": "impl_Display!(\n        i8, u8,\n        i16, u16,\n        i32, u32,\n        i64, u64,\n        isize, usize,\n        ; as u64 via to_u64 named fmt_u64\n    )",
      "defsite": "macro_rules! impl_Display {\n    ($($signed:ident, $unsigned:ident,)* ; as $u:ident via $conv_fn:ident named $gen_name:ident) => {\n\n        $(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::Display for $unsigned {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                {\n                    const MAX_DEC_N: usize = $unsigned::MAX.ilog10() as usize + 1;\n                    // Buffer decimals for $unsigned with right alignment.\n                    let mut buf = [MaybeUninit::<u8>::uninit(); MAX_DEC_N];\n\n                    // SAFETY: `buf` is always big enough to contain all the digits.\n                    unsafe { f.pad_integral(true, \"\", self._fmt(&mut buf)) }\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    $gen_name(self.$conv_fn(), true, f)\n                }\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::Display for $signed {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                {\n                    const MAX_DEC_N: usize = $unsigned::MAX.ilog10() as usize + 1;\n                    // Buffer decimals for $unsigned with right alignment.\n                    let mut buf = [MaybeUninit::<u8>::uninit(); MAX_DEC_N];\n\n                    // SAFETY: `buf` is always big enough to contain all the digits.\n                    unsafe { f.pad_integral(*self >= 0, \"\", self.unsigned_abs()._fmt(&mut buf)) }\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    return $gen_name(self.unsigned_abs().$conv_fn(), *self >= 0, f);\n                }\n            }\n        }\n\n        #[cfg(not(feature = \"optimize_for_size\"))]\n        impl $unsigned {\n            #[doc(hidden)]\n            #[unstable(\n                feature = \"fmt_internals\",\n                reason = \"specialized method meant to only be used by `SpecToString` implementation\",\n                issue = \"none\"\n            )]\n            pub unsafe fn _fmt<'a>(self, buf: &'a mut [MaybeUninit::<u8>]) -> &'a str {\n                // SAFETY: `buf` will always be big enough to contain all digits.\n                let offset = unsafe { self._fmt_inner(buf) };\n                // SAFETY: Starting from `offset`, all elements of the slice have been set.\n                unsafe { slice_buffer_to_str(buf, offset) }\n            }\n\n            unsafe fn _fmt_inner(self, buf: &mut [MaybeUninit::<u8>]) -> usize {\n                // Count the number of bytes in buf that are not initialized.\n                let mut offset = buf.len();\n                // Consume the least-significant decimals from a working copy.\n                let mut remain = self;\n\n                // Format per four digits from the lookup table.\n                // Four digits need a 16-bit $unsigned or wider.\n                while size_of::<Self>() > 1 && remain > 999.try_into().expect(\"branch is not hit for types that cannot fit 999 (u8)\") {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the while condition ensures at least 4 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 4) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 4;\n\n                    // pull two pairs\n                    let scale: Self = 1_00_00.try_into().expect(\"branch is not hit for types that cannot fit 1E4 (u8)\");\n                    let quad = remain % scale;\n                    remain /= scale;\n                    let pair1 = (quad / 100) as usize;\n                    let pair2 = (quad % 100) as usize;\n                    buf[offset + 0].write(DEC_DIGITS_LUT[pair1 * 2 + 0]);\n                    buf[offset + 1].write(DEC_DIGITS_LUT[pair1 * 2 + 1]);\n                    buf[offset + 2].write(DEC_DIGITS_LUT[pair2 * 2 + 0]);\n                    buf[offset + 3].write(DEC_DIGITS_LUT[pair2 * 2 + 1]);\n                }\n\n                // Format per two digits from the lookup table.\n                if remain > 9 {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the if condition ensures at least 2 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 2) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 2;\n\n                    let pair = (remain % 100) as usize;\n                    remain /= 100;\n                    buf[offset + 0].write(DEC_DIGITS_LUT[pair * 2 + 0]);\n                    buf[offset + 1].write(DEC_DIGITS_LUT[pair * 2 + 1]);\n                }\n\n                // Format the last remaining digit, if any.\n                if remain != 0 || self == 0 {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the if condition ensures (at least) 1 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 1) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 1;\n\n                    // Either the compiler sees that remain < 10, or it prevents\n                    // a boundary check up next.\n                    let last = (remain & 15) as usize;\n                    buf[offset].write(DEC_DIGITS_LUT[last * 2 + 1]);\n                    // not used: remain = 0;\n                }\n\n                offset\n            }\n        }\n\n        impl $signed {\n            /// Allows users to write an integer (in signed decimal format) into a variable `buf` of\n            /// type [`NumBuffer`] that is passed by the caller by mutable reference.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(int_format_into)]\n            /// use core::fmt::NumBuffer;\n            ///\n            #[doc = concat!(\"let n = 0\", stringify!($signed), \";\")]\n            /// let mut buf = NumBuffer::new();\n            /// assert_eq!(n.format_into(&mut buf), \"0\");\n            ///\n            #[doc = concat!(\"let n1 = 32\", stringify!($signed), \";\")]\n            /// assert_eq!(n1.format_into(&mut buf), \"32\");\n            ///\n            #[doc = concat!(\"let n2 = \", stringify!($signed::MAX), \";\")]\n            #[doc = concat!(\"assert_eq!(n2.format_into(&mut buf), \", stringify!($signed::MAX), \".to_string());\")]\n            /// ```\n            #[unstable(feature = \"int_format_into\", issue = \"138215\")]\n            pub fn format_into(self, buf: &mut NumBuffer<Self>) -> &str {\n                let mut offset;\n\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                // SAFETY: `buf` will always be big enough to contain all digits.\n                unsafe {\n                    offset = self.unsigned_abs()._fmt_inner(&mut buf.buf);\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    offset = ${concat(_inner_slow_integer_to_str, $gen_name)}(self.unsigned_abs().$conv_fn(), &mut buf.buf);\n                }\n                // Only difference between signed and unsigned are these 4 lines.\n                if self < 0 {\n                    offset -= 1;\n                    buf.buf[offset].write(b'-');\n                }\n                // SAFETY: Starting from `offset`, all elements of the slice have been set.\n                unsafe { slice_buffer_to_str(&buf.buf, offset) }\n            }\n        }\n\n        impl $unsigned {\n            /// Allows users to write an integer (in signed decimal format) into a variable `buf` of\n            /// type [`NumBuffer`] that is passed by the caller by mutable reference.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(int_format_into)]\n            /// use core::fmt::NumBuffer;\n            ///\n            #[doc = concat!(\"let n = 0\", stringify!($unsigned), \";\")]\n            /// let mut buf = NumBuffer::new();\n            /// assert_eq!(n.format_into(&mut buf), \"0\");\n            ///\n            #[doc = concat!(\"let n1 = 32\", stringify!($unsigned), \";\")]\n            /// assert_eq!(n1.format_into(&mut buf), \"32\");\n            ///\n            #[doc = concat!(\"let n2 = \", stringify!($unsigned::MAX), \";\")]\n            #[doc = concat!(\"assert_eq!(n2.format_into(&mut buf), \", stringify!($unsigned::MAX), \".to_string());\")]\n            /// ```\n            #[unstable(feature = \"int_format_into\", issue = \"138215\")]\n            pub fn format_into(self, buf: &mut NumBuffer<Self>) -> &str {\n                let offset;\n\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                // SAFETY: `buf` will always be big enough to contain all digits.\n                unsafe {\n                    offset = self._fmt_inner(&mut buf.buf);\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    offset = ${concat(_inner_slow_integer_to_str, $gen_name)}(self.$conv_fn(), &mut buf.buf);\n                }\n                // SAFETY: Starting from `offset`, all elements of the slice have been set.\n                unsafe { slice_buffer_to_str(&buf.buf, offset) }\n            }\n        }\n\n\n        )*\n\n        #[cfg(feature = \"optimize_for_size\")]\n        fn ${concat(_inner_slow_integer_to_str, $gen_name)}(mut n: $u, buf: &mut [MaybeUninit::<u8>]) -> usize {\n            let mut curr = buf.len();\n\n            // SAFETY: To show that it's OK to copy into `buf_ptr`, notice that at the beginning\n            // `curr == buf.len() == 39 > log(n)` since `n < 2^128 < 10^39`, and at\n            // each step this is kept the same as `n` is divided. Since `n` is always\n            // non-negative, this means that `curr > 0` so `buf_ptr[curr..curr + 1]`\n            // is safe to access.\n            loop {\n                curr -= 1;\n                buf[curr].write((n % 10) as u8 + b'0');\n                n /= 10;\n\n                if n == 0 {\n                    break;\n                }\n            }\n            curr\n        }\n\n        #[cfg(feature = \"optimize_for_size\")]\n        fn $gen_name(n: $u, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            const MAX_DEC_N: usize = $u::MAX.ilog(10) as usize + 1;\n            let mut buf = [MaybeUninit::<u8>::uninit(); MAX_DEC_N];\n\n            let offset = ${concat(_inner_slow_integer_to_str, $gen_name)}(n, &mut buf);\n            // SAFETY: Starting from `offset`, all elements of the slice have been set.\n            let buf_slice = unsafe { slice_buffer_to_str(&buf, offset) };\n            f.pad_integral(is_nonnegative, \"\", buf_slice)\n        }\n    };\n}"
    }
  ],
  "callees": [
    "47323665595455568617290020941376774286",
    "469731897247902151615947250155763551554",
    "17669494056957649145896081724806188101",
    "54066239791891785914691895834688847933",
    "1783210845261203538713498935807640544288",
    "25182688384539420013607163022734998294",
    "86149906497652422709198706302615219549",
    "18125598672352641865454477834971730060",
    "3366338629265279481107319459380984488",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "1243847030362955698517207199029174369810"
  ]
}
