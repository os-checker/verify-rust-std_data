{
  "file": "core/src/fmt/num.rs",
  "name": "fmt::num::imp::exp_u64::{constant#1}",
  "hash": "157485018582241819381191627122170515120",
  "hash_direct": "104724147066034101981353650316050472673",
  "src": "3",
  "macro_backtrace": [
    {
      "callsite": "impl_Exp!(\n        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n            as u64 via to_u64 named exp_u64\n    )",
      "defsite": "macro_rules! impl_Exp {\n    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n        fn $name(\n            mut n: $u,\n            is_nonnegative: bool,\n            upper: bool,\n            f: &mut fmt::Formatter<'_>\n        ) -> fmt::Result {\n            let (mut n, mut exponent, trailing_zeros, added_precision) = {\n                let mut exponent = 0;\n                // count and remove trailing decimal zeroes\n                while n % 10 == 0 && n >= 10 {\n                    n /= 10;\n                    exponent += 1;\n                }\n                let (added_precision, subtracted_precision) = match f.precision() {\n                    Some(fmt_prec) => {\n                        // number of decimal digits minus 1\n                        let mut tmp = n;\n                        let mut prec = 0;\n                        while tmp >= 10 {\n                            tmp /= 10;\n                            prec += 1;\n                        }\n                        (fmt_prec.saturating_sub(prec), prec.saturating_sub(fmt_prec))\n                    }\n                    None => (0, 0)\n                };\n                for _ in 1..subtracted_precision {\n                    n /= 10;\n                    exponent += 1;\n                }\n                if subtracted_precision != 0 {\n                    let rem = n % 10;\n                    n /= 10;\n                    exponent += 1;\n                    // round up last digit, round to even on a tie\n                    if rem > 5 || (rem == 5 && (n % 2 != 0 || subtracted_precision > 1 )) {\n                        n += 1;\n                        // if the digit is rounded to the next power\n                        // instead adjust the exponent\n                        if n.ilog10() > (n - 1).ilog10() {\n                            n /= 10;\n                            exponent += 1;\n                        }\n                    }\n                }\n                (n, exponent, exponent, added_precision)\n            };\n\n            // Since `curr` always decreases by the number of digits copied, this means\n            // that `curr >= 0`.\n            let mut buf = [MaybeUninit::<u8>::uninit(); 40];\n            let mut curr = buf.len(); //index for buf\n            let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n            // decode 2 chars at a time\n            while n >= 100 {\n                let d1 = ((n % 100) as usize) << 1;\n                curr -= 2;\n                // SAFETY: `d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since\n                // `DEC_DIGITS_LUT` has a length of 200.\n                unsafe {\n                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n                }\n                n /= 100;\n                exponent += 2;\n            }\n            // n is <= 99, so at most 2 chars long\n            let mut n = n as isize; // possibly reduce 64bit math\n            // decode second-to-last character\n            if n >= 10 {\n                curr -= 1;\n                // SAFETY: Safe since `40 > curr >= 0` (see comment)\n                unsafe {\n                    *buf_ptr.add(curr) = (n as u8 % 10_u8) + b'0';\n                }\n                n /= 10;\n                exponent += 1;\n            }\n            // add decimal point iff >1 mantissa digit will be printed\n            if exponent != trailing_zeros || added_precision != 0 {\n                curr -= 1;\n                // SAFETY: Safe since `40 > curr >= 0`\n                unsafe {\n                    *buf_ptr.add(curr) = b'.';\n                }\n            }\n\n            // SAFETY: Safe since `40 > curr >= 0`\n            let buf_slice = unsafe {\n                // decode last character\n                curr -= 1;\n                *buf_ptr.add(curr) = (n as u8) + b'0';\n\n                let len = buf.len() - curr as usize;\n                slice::from_raw_parts(buf_ptr.add(curr), len)\n            };\n\n            // stores 'e' (or 'E') and the up to 2-digit exponent\n            let mut exp_buf = [MaybeUninit::<u8>::uninit(); 3];\n            let exp_ptr = MaybeUninit::slice_as_mut_ptr(&mut exp_buf);\n            // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`\n            // is contained within `exp_buf` since `len <= 3`.\n            let exp_slice = unsafe {\n                *exp_ptr.add(0) = if upper { b'E' } else { b'e' };\n                let len = if exponent < 10 {\n                    *exp_ptr.add(1) = (exponent as u8) + b'0';\n                    2\n                } else {\n                    let off = exponent << 1;\n                    ptr::copy_nonoverlapping(lut_ptr.add(off), exp_ptr.add(1), 2);\n                    3\n                };\n                slice::from_raw_parts(exp_ptr, len)\n            };\n\n            let parts = &[\n                numfmt::Part::Copy(buf_slice),\n                numfmt::Part::Zero(added_precision),\n                numfmt::Part::Copy(exp_slice),\n            ];\n            let sign = if !is_nonnegative {\n                \"-\"\n            } else if f.sign_plus() {\n                \"+\"\n            } else {\n                \"\"\n            };\n            let formatted = numfmt::Formatted { sign, parts };\n            // SAFETY: `buf_slice` and `exp_slice` contain only ASCII characters.\n            unsafe { f.pad_formatted_parts(&formatted) }\n        }\n\n        $(\n            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n            impl fmt::LowerExp for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    let is_nonnegative = *self >= 0;\n                    let n = if is_nonnegative {\n                        self.$conv_fn()\n                    } else {\n                        // convert the negative num to positive by summing 1 to its 2s complement\n                        (!self.$conv_fn()).wrapping_add(1)\n                    };\n                    $name(n, is_nonnegative, false, f)\n                }\n            })*\n        $(\n            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n            impl fmt::UpperExp for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    let is_nonnegative = *self >= 0;\n                    let n = if is_nonnegative {\n                        self.$conv_fn()\n                    } else {\n                        // convert the negative num to positive by summing 1 to its 2s complement\n                        (!self.$conv_fn()).wrapping_add(1)\n                    };\n                    $name(n, is_nonnegative, true, f)\n                }\n            })*\n    };\n}"
    }
  ]
}
