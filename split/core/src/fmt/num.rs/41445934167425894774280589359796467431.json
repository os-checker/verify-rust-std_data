{
  "file": "core/src/fmt/num.rs",
  "name": "fmt::num::imp::<impl fmt::Display for usize>::fmt::MAX_DEC_N",
  "hash": "41445934167425894774280589359796467431",
  "hash_direct": "631388725705849882917378096653481028546",
  "src": "const MAX_DEC_N: usize = $Unsigned::MAX.ilog10() as usize + 1;",
  "macro_backtrace": [
    {
      "callsite": "impl_Display!(i8, u8, i16, u16, i32, u32, i64, u64, isize, usize; as u64 into display_u64)",
      "defsite": "macro_rules! impl_Display {\n    ($($Signed:ident, $Unsigned:ident),* ; as $T:ident into $fmt_fn:ident) => {\n\n        $(\n        const _: () = {\n            assert!($Signed::MIN < 0, \"need signed\");\n            assert!($Unsigned::MIN == 0, \"need unsigned\");\n            assert!($Signed::BITS == $Unsigned::BITS, \"need counterparts\");\n            assert!($Signed::BITS <= $T::BITS, \"need lossless conversion\");\n            assert!($Unsigned::BITS <= $T::BITS, \"need lossless conversion\");\n        };\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::Display for $Unsigned {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                {\n                    const MAX_DEC_N: usize = $Unsigned::MAX.ilog10() as usize + 1;\n                    // Buffer decimals for self with right alignment.\n                    let mut buf = [MaybeUninit::<u8>::uninit(); MAX_DEC_N];\n\n                    // SAFETY: `buf` is always big enough to contain all the digits.\n                    unsafe { f.pad_integral(true, \"\", self._fmt(&mut buf)) }\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    // Lossless conversion (with as) is asserted at the top of\n                    // this macro.\n                    ${concat($fmt_fn, _small)}(*self as $T, true, f)\n                }\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::Display for $Signed {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                {\n                    const MAX_DEC_N: usize = $Unsigned::MAX.ilog10() as usize + 1;\n                    // Buffer decimals for self with right alignment.\n                    let mut buf = [MaybeUninit::<u8>::uninit(); MAX_DEC_N];\n\n                    // SAFETY: `buf` is always big enough to contain all the digits.\n                    unsafe { f.pad_integral(*self >= 0, \"\", self.unsigned_abs()._fmt(&mut buf)) }\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    // Lossless conversion (with as) is asserted at the top of\n                    // this macro.\n                    return ${concat($fmt_fn, _small)}(self.unsigned_abs() as $T, *self >= 0, f);\n                }\n            }\n        }\n\n        #[cfg(not(feature = \"optimize_for_size\"))]\n        impl $Unsigned {\n            #[doc(hidden)]\n            #[unstable(\n                feature = \"fmt_internals\",\n                reason = \"specialized method meant to only be used by `SpecToString` implementation\",\n                issue = \"none\"\n            )]\n            pub unsafe fn _fmt<'a>(self, buf: &'a mut [MaybeUninit::<u8>]) -> &'a str {\n                // SAFETY: `buf` will always be big enough to contain all digits.\n                let offset = unsafe { self._fmt_inner(buf) };\n                // SAFETY: Starting from `offset`, all elements of the slice have been set.\n                unsafe { slice_buffer_to_str(buf, offset) }\n            }\n\n            unsafe fn _fmt_inner(self, buf: &mut [MaybeUninit::<u8>]) -> usize {\n                // Count the number of bytes in buf that are not initialized.\n                let mut offset = buf.len();\n                // Consume the least-significant decimals from a working copy.\n                let mut remain = self;\n\n                // Format per four digits from the lookup table.\n                // Four digits need a 16-bit $Unsigned or wider.\n                while size_of::<Self>() > 1 && remain > 999.try_into().expect(\"branch is not hit for types that cannot fit 999 (u8)\") {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the while condition ensures at least 4 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 4) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 4;\n\n                    // pull two pairs\n                    let scale: Self = 1_00_00.try_into().expect(\"branch is not hit for types that cannot fit 1E4 (u8)\");\n                    let quad = remain % scale;\n                    remain /= scale;\n                    let pair1 = (quad / 100) as usize;\n                    let pair2 = (quad % 100) as usize;\n                    buf[offset + 0].write(DECIMAL_PAIRS[pair1 * 2 + 0]);\n                    buf[offset + 1].write(DECIMAL_PAIRS[pair1 * 2 + 1]);\n                    buf[offset + 2].write(DECIMAL_PAIRS[pair2 * 2 + 0]);\n                    buf[offset + 3].write(DECIMAL_PAIRS[pair2 * 2 + 1]);\n                }\n\n                // Format per two digits from the lookup table.\n                if remain > 9 {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the if condition ensures at least 2 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 2) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 2;\n\n                    let pair = (remain % 100) as usize;\n                    remain /= 100;\n                    buf[offset + 0].write(DECIMAL_PAIRS[pair * 2 + 0]);\n                    buf[offset + 1].write(DECIMAL_PAIRS[pair * 2 + 1]);\n                }\n\n                // Format the last remaining digit, if any.\n                if remain != 0 || self == 0 {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the if condition ensures (at least) 1 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 1) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 1;\n\n                    // Either the compiler sees that remain < 10, or it prevents\n                    // a boundary check up next.\n                    let last = (remain & 15) as usize;\n                    buf[offset].write(DECIMAL_PAIRS[last * 2 + 1]);\n                    // not used: remain = 0;\n                }\n\n                offset\n            }\n        }\n\n        impl $Signed {\n            /// Allows users to write an integer (in signed decimal format) into a variable `buf` of\n            /// type [`NumBuffer`] that is passed by the caller by mutable reference.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(int_format_into)]\n            /// use core::fmt::NumBuffer;\n            ///\n            #[doc = concat!(\"let n = 0\", stringify!($Signed), \";\")]\n            /// let mut buf = NumBuffer::new();\n            /// assert_eq!(n.format_into(&mut buf), \"0\");\n            ///\n            #[doc = concat!(\"let n1 = 32\", stringify!($Signed), \";\")]\n            /// assert_eq!(n1.format_into(&mut buf), \"32\");\n            ///\n            #[doc = concat!(\"let n2 = \", stringify!($Signed::MAX), \";\")]\n            #[doc = concat!(\"assert_eq!(n2.format_into(&mut buf), \", stringify!($Signed::MAX), \".to_string());\")]\n            /// ```\n            #[unstable(feature = \"int_format_into\", issue = \"138215\")]\n            pub fn format_into(self, buf: &mut NumBuffer<Self>) -> &str {\n                let mut offset;\n\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                // SAFETY: `buf` will always be big enough to contain all digits.\n                unsafe {\n                    offset = self.unsigned_abs()._fmt_inner(&mut buf.buf);\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    // Lossless conversion (with as) is asserted at the top of\n                    // this macro.\n                    offset = ${concat($fmt_fn, _in_buf_small)}(self.unsigned_abs() as $T, &mut buf.buf);\n                }\n                // Only difference between signed and unsigned are these 4 lines.\n                if self < 0 {\n                    offset -= 1;\n                    buf.buf[offset].write(b'-');\n                }\n                // SAFETY: Starting from `offset`, all elements of the slice have been set.\n                unsafe { slice_buffer_to_str(&buf.buf, offset) }\n            }\n        }\n\n        impl $Unsigned {\n            /// Allows users to write an integer (in signed decimal format) into a variable `buf` of\n            /// type [`NumBuffer`] that is passed by the caller by mutable reference.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(int_format_into)]\n            /// use core::fmt::NumBuffer;\n            ///\n            #[doc = concat!(\"let n = 0\", stringify!($Unsigned), \";\")]\n            /// let mut buf = NumBuffer::new();\n            /// assert_eq!(n.format_into(&mut buf), \"0\");\n            ///\n            #[doc = concat!(\"let n1 = 32\", stringify!($Unsigned), \";\")]\n            /// assert_eq!(n1.format_into(&mut buf), \"32\");\n            ///\n            #[doc = concat!(\"let n2 = \", stringify!($Unsigned::MAX), \";\")]\n            #[doc = concat!(\"assert_eq!(n2.format_into(&mut buf), \", stringify!($Unsigned::MAX), \".to_string());\")]\n            /// ```\n            #[unstable(feature = \"int_format_into\", issue = \"138215\")]\n            pub fn format_into(self, buf: &mut NumBuffer<Self>) -> &str {\n                let offset;\n\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                // SAFETY: `buf` will always be big enough to contain all digits.\n                unsafe {\n                    offset = self._fmt_inner(&mut buf.buf);\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    // Lossless conversion (with as) is asserted at the top of\n                    // this macro.\n                    offset = ${concat($fmt_fn, _in_buf_small)}(self as $T, &mut buf.buf);\n                }\n                // SAFETY: Starting from `offset`, all elements of the slice have been set.\n                unsafe { slice_buffer_to_str(&buf.buf, offset) }\n            }\n        }\n\n        )*\n\n        #[cfg(feature = \"optimize_for_size\")]\n        fn ${concat($fmt_fn, _in_buf_small)}(mut n: $T, buf: &mut [MaybeUninit::<u8>]) -> usize {\n            let mut curr = buf.len();\n\n            // SAFETY: To show that it's OK to copy into `buf_ptr`, notice that at the beginning\n            // `curr == buf.len() == 39 > log(n)` since `n < 2^128 < 10^39`, and at\n            // each step this is kept the same as `n` is divided. Since `n` is always\n            // non-negative, this means that `curr > 0` so `buf_ptr[curr..curr + 1]`\n            // is safe to access.\n            loop {\n                curr -= 1;\n                buf[curr].write((n % 10) as u8 + b'0');\n                n /= 10;\n\n                if n == 0 {\n                    break;\n                }\n            }\n            curr\n        }\n\n        #[cfg(feature = \"optimize_for_size\")]\n        fn ${concat($fmt_fn, _small)}(n: $T, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            const MAX_DEC_N: usize = $T::MAX.ilog(10) as usize + 1;\n            let mut buf = [MaybeUninit::<u8>::uninit(); MAX_DEC_N];\n\n            let offset = ${concat($fmt_fn, _in_buf_small)}(n, &mut buf);\n            // SAFETY: Starting from `offset`, all elements of the slice have been set.\n            let buf_slice = unsafe { slice_buffer_to_str(&buf, offset) };\n            f.pad_integral(is_nonnegative, \"\", buf_slice)\n        }\n    };\n}"
    }
  ],
  "callees": [
    "258820287469578611817448591488600041899",
    "177450053108937244256024058949791559633",
    "50186211171463953727684864518369695334",
    "113105628410323550903289764020827107190",
    "7890666119737191484082000720043292310",
    "34410515695185066949979771014252260096",
    "72490371355961874097123965084721395404",
    "1676806814539779643518083197252466559589",
    "157682230385057029222012884580308215814",
    "172389643744910030774385733277492502124",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "1752989996936949203916036071159051010960"
  ]
}
