{
  "file": "core/src/fmt/num.rs",
  "name": "fmt::num::<impl u128>::_fmt_inner",
  "hash": "45318395101956594461130386568624732176",
  "hash_direct": "1052093314282269772915426377115322280839",
  "src": "unsafe fn _fmt_inner(self, buf: &mut [MaybeUninit<u8>]) -> usize {\n        // Optimize common-case zero, which would also need special treatment due to\n        // its \"leading\" zero.\n        if self == 0 {\n            let offset = buf.len() - 1;\n            buf[offset].write(b'0');\n            return offset;\n        }\n        // Take the 16 least-significant decimals.\n        let (quot_1e16, mod_1e16) = div_rem_1e16(self);\n        let (mut remain, mut offset) = if quot_1e16 == 0 {\n            (mod_1e16, U128_MAX_DEC_N)\n        } else {\n            // Write digits at buf[23..39].\n            enc_16lsd::<{ U128_MAX_DEC_N - 16 }>(buf, mod_1e16);\n\n            // Take another 16 decimals.\n            let (quot2, mod2) = div_rem_1e16(quot_1e16);\n            if quot2 == 0 {\n                (mod2, U128_MAX_DEC_N - 16)\n            } else {\n                // Write digits at buf[7..23].\n                enc_16lsd::<{ U128_MAX_DEC_N - 32 }>(buf, mod2);\n                // Quot2 has at most 7 decimals remaining after two 1e16 divisions.\n                (quot2 as u64, U128_MAX_DEC_N - 32)\n            }\n        };\n\n        // Format per four digits from the lookup table.\n        while remain > 999 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the while condition ensures at least 4 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 4) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 4;\n\n            // pull two pairs\n            let quad = remain % 1_00_00;\n            remain /= 1_00_00;\n            let pair1 = (quad / 100) as usize;\n            let pair2 = (quad % 100) as usize;\n            buf[offset + 0].write(DEC_DIGITS_LUT[pair1 * 2 + 0]);\n            buf[offset + 1].write(DEC_DIGITS_LUT[pair1 * 2 + 1]);\n            buf[offset + 2].write(DEC_DIGITS_LUT[pair2 * 2 + 0]);\n            buf[offset + 3].write(DEC_DIGITS_LUT[pair2 * 2 + 1]);\n        }\n\n        // Format per two digits from the lookup table.\n        if remain > 9 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the if condition ensures at least 2 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 2) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 2;\n\n            let pair = (remain % 100) as usize;\n            remain /= 100;\n            buf[offset + 0].write(DEC_DIGITS_LUT[pair * 2 + 0]);\n            buf[offset + 1].write(DEC_DIGITS_LUT[pair * 2 + 1]);\n        }\n\n        // Format the last remaining digit, if any.\n        if remain != 0 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the if condition ensures (at least) 1 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 1) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 1;\n\n            // Either the compiler sees that remain < 10, or it prevents\n            // a boundary check up next.\n            let last = (remain & 15) as usize;\n            buf[offset].write(DEC_DIGITS_LUT[last * 2 + 1]);\n            // not used: remain = 0;\n        }\n        offset\n    }",
  "callees": [
    "589599466487462365011430963401962118509",
    "166559392000045706437744874539733037061",
    "35932598991748325118093873731991502302",
    "568724557284913860013372778298136416306",
    "47323665595455568617290020941376774286",
    "11139495935450220752286966752445431093",
    "819922674618487244413043350901048949292",
    "2730413463489077682871299968750410950",
    "149177879054194305854706121912784527721",
    "1401790216334955327214351023031146810699",
    "169564152499839983839646051342040887309",
    "39071722518750711716217025197493296495",
    "1329845230409163288212548289525672875535",
    "16824420916691935049705640393259467449",
    "84041372649682785889844836039084079894",
    "1728531953254762460916325834585472426982",
    "164499247419474032715135467342069728508",
    "103649489784811006526625132462472248149",
    "1194365697027496133111619491071087150844",
    "1342849835466405409710461719769802605500",
    "97728446667492592338346092068331699738",
    "55549683683119533987529308576431567352",
    "1259853796123792531010116020849677170944",
    "11663475863125548442297136621169599847",
    "694680042487375838617016048567631445241",
    "772065526016577495817057948738175729677",
    "133509031473879608767378732747493739553",
    "150485570763328741959529276593682551099",
    "380409271697733753615604025175457031719",
    "1801932849287312231112662193894546046488",
    "844957821118050201712037424530049556280",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "105125143701458073564296455695110349394",
    "90175179397242369455372712796954544135",
    "478505109661826463711850093418602871650",
    "399232661239117480517401994520839366833"
  ]
}
