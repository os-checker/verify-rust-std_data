{
  "file": "core/src/any.rs",
  "name": "<any::TypeId as cmp::PartialEq>::eq",
  "hash": "55328251318118915666702900663280735987",
  "hash_direct": "4899435052920661736315051384099571315",
  "src": "fn eq(&self, other: &Self) -> bool {\n        #[cfg(miri)]\n        return crate::intrinsics::type_id_eq(*self, *other);\n        #[cfg(not(miri))]\n        {\n            let this = self;\n            crate::intrinsics::const_eval_select!(\n                @capture { this: &TypeId, other: &TypeId } -> bool:\n                if const {\n                    crate::intrinsics::type_id_eq(*this, *other)\n                } else {\n                    // Ideally we would just invoke `type_id_eq` unconditionally here,\n                    // but since we do not MIR inline intrinsics, because backends\n                    // may want to override them (and miri does!), MIR opts do not\n                    // clean up this call sufficiently for LLVM to turn repeated calls\n                    // of `TypeId` comparisons against one specific `TypeId` into\n                    // a lookup table.\n                    // SAFETY: We know that at runtime none of the bits have provenance and all bits\n                    // are initialized. So we can just convert the whole thing to a `u128` and compare that.\n                    unsafe {\n                        crate::mem::transmute::<_, u128>(*this) == crate::mem::transmute::<_, u128>(*other)\n                    }\n                }\n            )\n        }\n    }",
  "callees": [
    "729433234977683395412611545290322551250"
  ]
}
