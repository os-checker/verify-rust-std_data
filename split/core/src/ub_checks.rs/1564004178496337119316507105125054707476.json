{
  "file": "core/src/ub_checks.rs",
  "name": "ptr::mut_ptr::<impl *mut T>::sub::precondition_check",
  "hash": "1564004178496337119316507105125054707476",
  "hash_direct": "558343690668967340913129650445801486966",
  "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    let msg = concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\");\n                    ::core::panicking::panic_nounwind_fmt(::core::fmt::Arguments::new_const(&[msg]), false);\n                }\n            }",
  "macro_backtrace": [
    {
      "callsite": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::sub requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_sub_nowrap(this, count, size)\n        )",
      "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            #[track_caller]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    let msg = concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\");\n                    ::core::panicking::panic_nounwind_fmt(::core::fmt::Arguments::new_const(&[msg]), false);\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
    }
  ],
  "callees": [
    "47323665595455568617290020941376774286",
    "111425599901702694743874629435682172347",
    "714811817540972740211524868124730226803",
    "1329845230409163288212548289525672875535",
    "104310221742716516106825842456563485195",
    "841346702487865802717731804342903065853",
    "26064680123257945312537992217601395168",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "105125143701458073564296455695110349394",
    "25930241974724637292994171257021210872",
    "617554482545947003412104686554524783687",
    "174277204108153543316058831477041384365"
  ]
}
