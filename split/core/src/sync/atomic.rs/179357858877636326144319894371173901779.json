{
  "file": "core/src/sync/atomic.rs",
  "name": "sync::atomic::AtomicI128::fetch_add",
  "hash": "179357858877636326144319894371173901779",
  "hash_direct": "1109046831140540616014871297910300704764",
  "src": "pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_add(self.v.get(), val, order) }\n            }",
  "macro_backtrace": [
    {
      "callsite": "atomic_int! {\n    cfg(target_has_atomic = \"128\"),\n    cfg(target_has_atomic_equal_alignment = \"128\"),\n    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n    rustc_const_unstable(feature = \"integer_atomics\", issue = \"99069\"),\n    rustc_const_unstable(feature = \"integer_atomics\", issue = \"99069\"),\n    rustc_diagnostic_item = \"AtomicI128\",\n    \"i128\",\n    \"#![feature(integer_atomics)]\\n\\n\",\n    atomic_min, atomic_max,\n    16,\n    i128 AtomicI128\n}",
      "defsite": "macro_rules! atomic_int {\n    ($cfg_cas:meta,\n     $cfg_align:meta,\n     $stable:meta,\n     $stable_cxchg:meta,\n     $stable_debug:meta,\n     $stable_access:meta,\n     $stable_from:meta,\n     $stable_nand:meta,\n     $const_stable_new:meta,\n     $const_stable_into_inner:meta,\n     $diagnostic_item:meta,\n     $s_int_type:literal,\n     $extra_feature:expr,\n     $min_fn:ident, $max_fn:ident,\n     $align:expr,\n     $int_type:ident $atomic_type:ident) => {\n        /// An integer type which can be safely shared between threads.\n        ///\n        /// This type has the same\n        #[doc = if_8_bit!(\n            $int_type,\n            yes = [\"size, alignment, and bit validity\"],\n            no = [\"size and bit validity\"],\n        )]\n        /// as the underlying integer type, [`\n        #[doc = $s_int_type]\n        /// `].\n        #[doc = if_8_bit! {\n            $int_type,\n            no = [\n                \"However, the alignment of this type is always equal to its \",\n                \"size, even on targets where [`\", $s_int_type, \"`] has a \",\n                \"lesser alignment.\"\n            ],\n        }]\n        ///\n        /// For more about the differences between atomic types and\n        /// non-atomic types as well as information about the portability of\n        /// this type, please see the [module-level documentation].\n        ///\n        /// **Note:** This type is only available on platforms that support\n        /// atomic loads and stores of [`\n        #[doc = $s_int_type]\n        /// `].\n        ///\n        /// [module-level documentation]: crate::sync::atomic\n        #[$stable]\n        #[$diagnostic_item]\n        #[repr(C, align($align))]\n        pub struct $atomic_type {\n            v: UnsafeCell<$int_type>,\n        }\n\n        #[$stable]\n        impl Default for $atomic_type {\n            #[inline]\n            fn default() -> Self {\n                Self::new(Default::default())\n            }\n        }\n\n        #[$stable_from]\n        #[rustc_const_unstable(feature = \"const_convert\", issue = \"143773\")]\n        impl const From<$int_type> for $atomic_type {\n            #[doc = concat!(\"Converts an `\", stringify!($int_type), \"` into an `\", stringify!($atomic_type), \"`.\")]\n            #[inline]\n            fn from(v: $int_type) -> Self { Self::new(v) }\n        }\n\n        #[$stable_debug]\n        impl fmt::Debug for $atomic_type {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)\n            }\n        }\n\n        // Send is implicitly implemented.\n        #[$stable]\n        unsafe impl Sync for $atomic_type {}\n\n        impl $atomic_type {\n            /// Creates a new atomic integer.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\")]\n            ///\n            #[doc = concat!(\"let atomic_forty_two = \", stringify!($atomic_type), \"::new(42);\")]\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$const_stable_new]\n            #[must_use]\n            pub const fn new(v: $int_type) -> Self {\n                Self {v: UnsafeCell::new(v)}\n            }\n\n            /// Creates a new reference to an atomic integer from a pointer.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{self, \", stringify!($atomic_type), \"};\")]\n            ///\n            /// // Get a pointer to an allocated value\n            #[doc = concat!(\"let ptr: *mut \", stringify!($int_type), \" = Box::into_raw(Box::new(0));\")]\n            ///\n            #[doc = concat!(\"assert!(ptr.cast::<\", stringify!($atomic_type), \">().is_aligned());\")]\n            ///\n            /// {\n            ///     // Create an atomic view of the allocated value\n            // SAFETY: this is a doc comment, tidy, it can't hurt you (also guaranteed by the construction of `ptr` and the assert above)\n            #[doc = concat!(\"    let atomic = unsafe {\", stringify!($atomic_type), \"::from_ptr(ptr) };\")]\n            ///\n            ///     // Use `atomic` for atomic operations, possibly share it with other threads\n            ///     atomic.store(1, atomic::Ordering::Relaxed);\n            /// }\n            ///\n            /// // It's ok to non-atomically access the value behind `ptr`,\n            /// // since the reference to the atomic ended its lifetime in the block above\n            /// assert_eq!(unsafe { *ptr }, 1);\n            ///\n            /// // Deallocate the value\n            /// unsafe { drop(Box::from_raw(ptr)) }\n            /// ```\n            ///\n            /// # Safety\n            ///\n            /// * `ptr` must be aligned to\n            #[doc = concat!(\"  `align_of::<\", stringify!($atomic_type), \">()`\")]\n            #[doc = if_8_bit!{\n                $int_type,\n                yes = [\n                    \"  (note that this is always true, since `align_of::<\",\n                    stringify!($atomic_type), \">() == 1`).\"\n                ],\n                no = [\n                    \"  (note that on some platforms this can be bigger than `align_of::<\",\n                    stringify!($int_type), \">()`).\"\n                ],\n            }]\n            /// * `ptr` must be [valid] for both reads and writes for the whole lifetime `'a`.\n            /// * You must adhere to the [Memory model for atomic accesses]. In particular, it is not\n            ///   allowed to mix conflicting atomic and non-atomic accesses, or atomic accesses of different\n            ///   sizes, without synchronization.\n            ///\n            /// [valid]: crate::ptr#safety\n            /// [Memory model for atomic accesses]: self#memory-model-for-atomic-accesses\n            #[inline]\n            #[stable(feature = \"atomic_from_ptr\", since = \"1.75.0\")]\n            #[rustc_const_stable(feature = \"const_atomic_from_ptr\", since = \"1.84.0\")]\n            pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {\n                // SAFETY: guaranteed by the caller\n                unsafe { &*ptr.cast() }\n            }\n\n\n            /// Returns a mutable reference to the underlying integer.\n            ///\n            /// This is safe because the mutable reference guarantees that no other threads are\n            /// concurrently accessing the atomic data.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let mut some_var = \", stringify!($atomic_type), \"::new(10);\")]\n            /// assert_eq!(*some_var.get_mut(), 10);\n            /// *some_var.get_mut() = 5;\n            /// assert_eq!(some_var.load(Ordering::SeqCst), 5);\n            /// ```\n            #[inline]\n            #[$stable_access]\n            pub fn get_mut(&mut self) -> &mut $int_type {\n                self.v.get_mut()\n            }\n\n            #[doc = concat!(\"Get atomic access to a `&mut \", stringify!($int_type), \"`.\")]\n            ///\n            #[doc = if_8_bit! {\n                $int_type,\n                no = [\n                    \"**Note:** This function is only available on targets where `\",\n                    stringify!($atomic_type), \"` has the same alignment as `\", stringify!($int_type), \"`.\"\n                ],\n            }]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(atomic_from_mut)]\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            /// let mut some_int = 123;\n            #[doc = concat!(\"let a = \", stringify!($atomic_type), \"::from_mut(&mut some_int);\")]\n            /// a.store(100, Ordering::Relaxed);\n            /// assert_eq!(some_int, 100);\n            /// ```\n            ///\n            #[inline]\n            #[$cfg_align]\n            #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n            pub fn from_mut(v: &mut $int_type) -> &mut Self {\n                let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n                // SAFETY:\n                //  - the mutable reference guarantees unique ownership.\n                //  - the alignment of `$int_type` and `Self` is the\n                //    same, as promised by $cfg_align and verified above.\n                unsafe { &mut *(v as *mut $int_type as *mut Self) }\n            }\n\n            #[doc = concat!(\"Get non-atomic access to a `&mut [\", stringify!($atomic_type), \"]` slice\")]\n            ///\n            /// This is safe because the mutable reference guarantees that no other threads are\n            /// concurrently accessing the atomic data.\n            ///\n            /// # Examples\n            ///\n            /// ```ignore-wasm\n            /// #![feature(atomic_from_mut)]\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let mut some_ints = [const { \", stringify!($atomic_type), \"::new(0) }; 10];\")]\n            ///\n            #[doc = concat!(\"let view: &mut [\", stringify!($int_type), \"] = \", stringify!($atomic_type), \"::get_mut_slice(&mut some_ints);\")]\n            /// assert_eq!(view, [0; 10]);\n            /// view\n            ///     .iter_mut()\n            ///     .enumerate()\n            ///     .for_each(|(idx, int)| *int = idx as _);\n            ///\n            /// std::thread::scope(|s| {\n            ///     some_ints\n            ///         .iter()\n            ///         .enumerate()\n            ///         .for_each(|(idx, int)| {\n            ///             s.spawn(move || assert_eq!(int.load(Ordering::Relaxed), idx as _));\n            ///         })\n            /// });\n            /// ```\n            #[inline]\n            #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n            pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {\n                // SAFETY: the mutable reference guarantees unique ownership.\n                unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }\n            }\n\n            #[doc = concat!(\"Get atomic access to a `&mut [\", stringify!($int_type), \"]` slice.\")]\n            ///\n            /// # Examples\n            ///\n            /// ```ignore-wasm\n            /// #![feature(atomic_from_mut)]\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            /// let mut some_ints = [0; 10];\n            #[doc = concat!(\"let a = &*\", stringify!($atomic_type), \"::from_mut_slice(&mut some_ints);\")]\n            /// std::thread::scope(|s| {\n            ///     for i in 0..a.len() {\n            ///         s.spawn(move || a[i].store(i as _, Ordering::Relaxed));\n            ///     }\n            /// });\n            /// for (i, n) in some_ints.into_iter().enumerate() {\n            ///     assert_eq!(i, n as usize);\n            /// }\n            /// ```\n            #[inline]\n            #[$cfg_align]\n            #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n            pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {\n                let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n                // SAFETY:\n                //  - the mutable reference guarantees unique ownership.\n                //  - the alignment of `$int_type` and `Self` is the\n                //    same, as promised by $cfg_align and verified above.\n                unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }\n            }\n\n            /// Consumes the atomic and returns the contained value.\n            ///\n            /// This is safe because passing `self` by value guarantees that no other threads are\n            /// concurrently accessing the atomic data.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            /// assert_eq!(some_var.into_inner(), 5);\n            /// ```\n            #[inline]\n            #[$stable_access]\n            #[$const_stable_into_inner]\n            pub const fn into_inner(self) -> $int_type {\n                self.v.into_inner()\n            }\n\n            /// Loads a value from the atomic integer.\n            ///\n            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n            /// Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n            ///\n            /// # Panics\n            ///\n            /// Panics if `order` is [`Release`] or [`AcqRel`].\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            ///\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 5);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn load(&self, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_load(self.v.get(), order) }\n            }\n\n            /// Stores a value into the atomic integer.\n            ///\n            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n            ///  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n            ///\n            /// # Panics\n            ///\n            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            ///\n            /// some_var.store(10, Ordering::Relaxed);\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn store(&self, val: $int_type, order: Ordering) {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_store(self.v.get(), val, order); }\n            }\n\n            /// Stores a value into the atomic integer, returning the previous value.\n            ///\n            /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            ///\n            /// assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_swap(self.v.get(), val, order) }\n            }\n\n            /// Stores a value into the atomic integer if the current value is the same as\n            /// the `current` value.\n            ///\n            /// The return value is always the previous value. If it is equal to `current`, then the\n            /// value was updated.\n            ///\n            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n            /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n            /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n            /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n            /// happens, and using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Migrating to `compare_exchange` and `compare_exchange_weak`\n            ///\n            /// `compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n            /// memory orderings:\n            ///\n            /// Original | Success | Failure\n            /// -------- | ------- | -------\n            /// Relaxed  | Relaxed | Relaxed\n            /// Acquire  | Acquire | Acquire\n            /// Release  | Release | Relaxed\n            /// AcqRel   | AcqRel  | Acquire\n            /// SeqCst   | SeqCst  | SeqCst\n            ///\n            /// `compare_and_swap` and `compare_exchange` also differ in their return type. You can use\n            /// `compare_exchange(...).unwrap_or_else(|x| x)` to recover the behavior of `compare_and_swap`,\n            /// but in most cases it is more idiomatic to check whether the return value is `Ok` or `Err`\n            /// rather than to infer success vs failure based on the value that was read.\n            ///\n            /// During migration, consider whether it makes sense to use `compare_exchange_weak` instead.\n            /// `compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n            /// which allows the compiler to generate better assembly code when the compare and swap\n            /// is used in a loop.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            ///\n            /// assert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n            ///\n            /// assert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[deprecated(\n                since = \"1.50.0\",\n                note = \"Use `compare_exchange` or `compare_exchange_weak` instead\")\n            ]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn compare_and_swap(&self,\n                                    current: $int_type,\n                                    new: $int_type,\n                                    order: Ordering) -> $int_type {\n                match self.compare_exchange(current,\n                                            new,\n                                            order,\n                                            strongest_failure_ordering(order)) {\n                    Ok(x) => x,\n                    Err(x) => x,\n                }\n            }\n\n            /// Stores a value into the atomic integer if the current value is the same as\n            /// the `current` value.\n            ///\n            /// The return value is a result indicating whether the new value was written and\n            /// containing the previous value. On success this value is guaranteed to be equal to\n            /// `current`.\n            ///\n            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n            /// ordering of this operation. `success` describes the required ordering for the\n            /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n            /// `failure` describes the required ordering for the load operation that takes place when\n            /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n            /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n            /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            ///\n            /// assert_eq!(some_var.compare_exchange(5, 10,\n            ///                                      Ordering::Acquire,\n            ///                                      Ordering::Relaxed),\n            ///            Ok(5));\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n            ///\n            /// assert_eq!(some_var.compare_exchange(6, 12,\n            ///                                      Ordering::SeqCst,\n            ///                                      Ordering::Acquire),\n            ///            Err(10));\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n            /// ```\n            ///\n            /// # Considerations\n            ///\n            /// `compare_exchange` is a [compare-and-swap operation] and thus exhibits the usual downsides\n            /// of CAS operations. In particular, a load of the value followed by a successful\n            /// `compare_exchange` with the previous load *does not ensure* that other threads have not\n            /// changed the value in the interim! This is usually important when the *equality* check in\n            /// the `compare_exchange` is being used to check the *identity* of a value, but equality\n            /// does not necessarily imply identity. This is a particularly common case for pointers, as\n            /// a pointer holding the same address does not imply that the same object exists at that\n            /// address! In this case, `compare_exchange` can lead to the [ABA problem].\n            ///\n            /// [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n            /// [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n            #[inline]\n            #[$stable_cxchg]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn compare_exchange(&self,\n                                    current: $int_type,\n                                    new: $int_type,\n                                    success: Ordering,\n                                    failure: Ordering) -> Result<$int_type, $int_type> {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n            }\n\n            /// Stores a value into the atomic integer if the current value is the same as\n            /// the `current` value.\n            ///\n            #[doc = concat!(\"Unlike [`\", stringify!($atomic_type), \"::compare_exchange`],\")]\n            /// this function is allowed to spuriously fail even\n            /// when the comparison succeeds, which can result in more efficient code on some\n            /// platforms. The return value is a result indicating whether the new value was\n            /// written and containing the previous value.\n            ///\n            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n            /// ordering of this operation. `success` describes the required ordering for the\n            /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n            /// `failure` describes the required ordering for the load operation that takes place when\n            /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n            /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n            /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let val = \", stringify!($atomic_type), \"::new(4);\")]\n            ///\n            /// let mut old = val.load(Ordering::Relaxed);\n            /// loop {\n            ///     let new = old * 2;\n            ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n            ///         Ok(_) => break,\n            ///         Err(x) => old = x,\n            ///     }\n            /// }\n            /// ```\n            ///\n            /// # Considerations\n            ///\n            /// `compare_exchange` is a [compare-and-swap operation] and thus exhibits the usual downsides\n            /// of CAS operations. In particular, a load of the value followed by a successful\n            /// `compare_exchange` with the previous load *does not ensure* that other threads have not\n            /// changed the value in the interim. This is usually important when the *equality* check in\n            /// the `compare_exchange` is being used to check the *identity* of a value, but equality\n            /// does not necessarily imply identity. This is a particularly common case for pointers, as\n            /// a pointer holding the same address does not imply that the same object exists at that\n            /// address! In this case, `compare_exchange` can lead to the [ABA problem].\n            ///\n            /// [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n            /// [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n            #[inline]\n            #[$stable_cxchg]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn compare_exchange_weak(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n                                         success: Ordering,\n                                         failure: Ordering) -> Result<$int_type, $int_type> {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe {\n                    atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n                }\n            }\n\n            /// Adds to the current value, returning the previous value.\n            ///\n            /// This operation wraps around on overflow.\n            ///\n            /// `fetch_add` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0);\")]\n            /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_add(self.v.get(), val, order) }\n            }\n\n            /// Subtracts from the current value, returning the previous value.\n            ///\n            /// This operation wraps around on overflow.\n            ///\n            /// `fetch_sub` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(20);\")]\n            /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_sub(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"and\" with the current value.\n            ///\n            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_and` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0b101101);\")]\n            /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_and(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"nand\" with the current value.\n            ///\n            /// Performs a bitwise \"nand\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0x13);\")]\n            /// assert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\n            /// assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n            /// ```\n            #[inline]\n            #[$stable_nand]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_nand(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"or\" with the current value.\n            ///\n            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0b101101);\")]\n            /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_or(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"xor\" with the current value.\n            ///\n            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0b101101);\")]\n            /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_xor(self.v.get(), val, order) }\n            }\n\n            /// Fetches the value, and applies a function to it that returns an optional\n            /// new value. Returns a `Result` of `Ok(previous_value)` if the function returned `Some(_)`, else\n            /// `Err(previous_value)`.\n            ///\n            /// Note: This may call the function multiple times if the value has been changed from other threads in\n            /// the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n            /// only once to the stored value.\n            ///\n            /// `fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n            /// The first describes the required ordering for when the operation finally succeeds while the second\n            /// describes the required ordering for loads. These correspond to the success and failure orderings of\n            #[doc = concat!(\"[`\", stringify!($atomic_type), \"::compare_exchange`]\")]\n            /// respectively.\n            ///\n            /// Using [`Acquire`] as success ordering makes the store part\n            /// of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n            /// [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Considerations\n            ///\n            /// This method is not magic; it is not provided by the hardware, and does not act like a\n            /// critical section or mutex.\n            ///\n            /// It is implemented on top of an atomic [compare-and-swap operation], and thus is subject to\n            /// the usual drawbacks of CAS operations. In particular, be careful of the [ABA problem]\n            /// if this atomic integer is an index or more generally if knowledge of only the *bitwise value*\n            /// of the atomic is not in and of itself sufficient to ensure any required preconditions.\n            ///\n            /// [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n            /// [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n            ///\n            /// # Examples\n            ///\n            /// ```rust\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let x = \", stringify!($atomic_type), \"::new(7);\")]\n            /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\n            /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\n            /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\n            /// assert_eq!(x.load(Ordering::SeqCst), 9);\n            /// ```\n            #[inline]\n            #[stable(feature = \"no_more_cas\", since = \"1.45.0\")]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn fetch_update<F>(&self,\n                                   set_order: Ordering,\n                                   fetch_order: Ordering,\n                                   mut f: F) -> Result<$int_type, $int_type>\n            where F: FnMut($int_type) -> Option<$int_type> {\n                let mut prev = self.load(fetch_order);\n                while let Some(next) = f(prev) {\n                    match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n                        x @ Ok(_) => return x,\n                        Err(next_prev) => prev = next_prev\n                    }\n                }\n                Err(prev)\n            }\n\n            /// Fetches the value, and applies a function to it that returns an optional\n            /// new value. Returns a `Result` of `Ok(previous_value)` if the function returned `Some(_)`, else\n            /// `Err(previous_value)`.\n            ///\n            #[doc = concat!(\"See also: [`update`](`\", stringify!($atomic_type), \"::update`).\")]\n            ///\n            /// Note: This may call the function multiple times if the value has been changed from other threads in\n            /// the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n            /// only once to the stored value.\n            ///\n            /// `try_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n            /// The first describes the required ordering for when the operation finally succeeds while the second\n            /// describes the required ordering for loads. These correspond to the success and failure orderings of\n            #[doc = concat!(\"[`\", stringify!($atomic_type), \"::compare_exchange`]\")]\n            /// respectively.\n            ///\n            /// Using [`Acquire`] as success ordering makes the store part\n            /// of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n            /// [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Considerations\n            ///\n            /// This method is not magic; it is not provided by the hardware, and does not act like a\n            /// critical section or mutex.\n            ///\n            /// It is implemented on top of an atomic [compare-and-swap operation], and thus is subject to\n            /// the usual drawbacks of CAS operations. In particular, be careful of the [ABA problem]\n            /// if this atomic integer is an index or more generally if knowledge of only the *bitwise value*\n            /// of the atomic is not in and of itself sufficient to ensure any required preconditions.\n            ///\n            /// [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n            /// [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n            ///\n            /// # Examples\n            ///\n            /// ```rust\n            /// #![feature(atomic_try_update)]\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let x = \", stringify!($atomic_type), \"::new(7);\")]\n            /// assert_eq!(x.try_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\n            /// assert_eq!(x.try_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\n            /// assert_eq!(x.try_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\n            /// assert_eq!(x.load(Ordering::SeqCst), 9);\n            /// ```\n            #[inline]\n            #[unstable(feature = \"atomic_try_update\", issue = \"135894\")]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn try_update(\n                &self,\n                set_order: Ordering,\n                fetch_order: Ordering,\n                f: impl FnMut($int_type) -> Option<$int_type>,\n            ) -> Result<$int_type, $int_type> {\n                // FIXME(atomic_try_update): this is currently an unstable alias to `fetch_update`;\n                //      when stabilizing, turn `fetch_update` into a deprecated alias to `try_update`.\n                self.fetch_update(set_order, fetch_order, f)\n            }\n\n            /// Fetches the value, applies a function to it that it return a new value.\n            /// The new value is stored and the old value is returned.\n            ///\n            #[doc = concat!(\"See also: [`try_update`](`\", stringify!($atomic_type), \"::try_update`).\")]\n            ///\n            /// Note: This may call the function multiple times if the value has been changed from other threads in\n            /// the meantime, but the function will have been applied only once to the stored value.\n            ///\n            /// `update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n            /// The first describes the required ordering for when the operation finally succeeds while the second\n            /// describes the required ordering for loads. These correspond to the success and failure orderings of\n            #[doc = concat!(\"[`\", stringify!($atomic_type), \"::compare_exchange`]\")]\n            /// respectively.\n            ///\n            /// Using [`Acquire`] as success ordering makes the store part\n            /// of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n            /// [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Considerations\n            ///\n            /// [CAS operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n            /// This method is not magic; it is not provided by the hardware, and does not act like a\n            /// critical section or mutex.\n            ///\n            /// It is implemented on top of an atomic [compare-and-swap operation], and thus is subject to\n            /// the usual drawbacks of CAS operations. In particular, be careful of the [ABA problem]\n            /// if this atomic integer is an index or more generally if knowledge of only the *bitwise value*\n            /// of the atomic is not in and of itself sufficient to ensure any required preconditions.\n            ///\n            /// [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n            /// [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n            ///\n            /// # Examples\n            ///\n            /// ```rust\n            /// #![feature(atomic_try_update)]\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let x = \", stringify!($atomic_type), \"::new(7);\")]\n            /// assert_eq!(x.update(Ordering::SeqCst, Ordering::SeqCst, |x| x + 1), 7);\n            /// assert_eq!(x.update(Ordering::SeqCst, Ordering::SeqCst, |x| x + 1), 8);\n            /// assert_eq!(x.load(Ordering::SeqCst), 9);\n            /// ```\n            #[inline]\n            #[unstable(feature = \"atomic_try_update\", issue = \"135894\")]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn update(\n                &self,\n                set_order: Ordering,\n                fetch_order: Ordering,\n                mut f: impl FnMut($int_type) -> $int_type,\n            ) -> $int_type {\n                let mut prev = self.load(fetch_order);\n                loop {\n                    match self.compare_exchange_weak(prev, f(prev), set_order, fetch_order) {\n                        Ok(x) => break x,\n                        Err(next_prev) => prev = next_prev,\n                    }\n                }\n            }\n\n            /// Maximum with the current value.\n            ///\n            /// Finds the maximum of the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_max` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n            /// assert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 42);\n            /// ```\n            ///\n            /// If you want to obtain the maximum value in one step, you can use the following:\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n            /// let bar = 42;\n            /// let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n            /// assert!(max_foo == 42);\n            /// ```\n            #[inline]\n            #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { $max_fn(self.v.get(), val, order) }\n            }\n\n            /// Minimum with the current value.\n            ///\n            /// Finds the minimum of the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_min` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n            /// assert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\n            /// assert_eq!(foo.load(Ordering::Relaxed), 23);\n            /// assert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\n            /// assert_eq!(foo.load(Ordering::Relaxed), 22);\n            /// ```\n            ///\n            /// If you want to obtain the minimum value in one step, you can use the following:\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n            /// let bar = 12;\n            /// let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n            /// assert_eq!(min_foo, 12);\n            /// ```\n            #[inline]\n            #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n            #[$cfg_cas]\n            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n            pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { $min_fn(self.v.get(), val, order) }\n            }\n\n            /// Returns a mutable pointer to the underlying integer.\n            ///\n            /// Doing non-atomic reads and writes on the resulting integer can be a data race.\n            /// This method is mostly useful for FFI, where the function signature may use\n            #[doc = concat!(\"`*mut \", stringify!($int_type), \"` instead of `&\", stringify!($atomic_type), \"`.\")]\n            ///\n            /// Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n            /// atomic types work with interior mutability. All modifications of an atomic change the value\n            /// through a shared reference, and can do so safely as long as they use atomic operations. Any\n            /// use of the returned raw pointer requires an `unsafe` block and still has to uphold the\n            /// requirements of the [memory model].\n            ///\n            /// # Examples\n            ///\n            /// ```ignore (extern-declaration)\n            /// # fn main() {\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\")]\n            ///\n            /// extern \"C\" {\n            #[doc = concat!(\"    fn my_atomic_op(arg: *mut \", stringify!($int_type), \");\")]\n            /// }\n            ///\n            #[doc = concat!(\"let atomic = \", stringify!($atomic_type), \"::new(1);\")]\n            ///\n            /// // SAFETY: Safe as long as `my_atomic_op` is atomic.\n            /// unsafe {\n            ///     my_atomic_op(atomic.as_ptr());\n            /// }\n            /// # }\n            /// ```\n            ///\n            /// [memory model]: self#memory-model-for-atomic-accesses\n            #[inline]\n            #[stable(feature = \"atomic_as_ptr\", since = \"1.70.0\")]\n            #[rustc_const_stable(feature = \"atomic_as_ptr\", since = \"1.70.0\")]\n            #[rustc_never_returns_null_ptr]\n            pub const fn as_ptr(&self) -> *mut $int_type {\n                self.v.get()\n            }\n        }\n    }\n}"
    }
  ],
  "callees": [
    "146653371523469198624753652801300818653",
    "1333539123940274992917765674158720361935"
  ]
}
