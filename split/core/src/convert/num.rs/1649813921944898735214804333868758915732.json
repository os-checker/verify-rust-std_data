{
  "file": "core/src/convert/num.rs",
  "name": "convert::num::<impl convert::TryFrom<i8> for num::nonzero::NonZero<i8>>::try_from",
  "hash": "1649813921944898735214804333868758915732",
  "hash_direct": "224457721056429580613419713347750056270",
  "src": "fn try_from(value: $Int) -> Result<Self, Self::Error> {\n                Self::new(value).ok_or(TryFromIntError(()))\n            }",
  "macro_backtrace": [
    {
      "callsite": "impl_nonzero_int_try_from_int!(i8)",
      "defsite": "macro_rules! impl_nonzero_int_try_from_int {\n    ($Int:ty) => {\n        #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")]\n        #[rustc_const_unstable(feature = \"const_convert\", issue = \"143773\")]\n        impl const TryFrom<$Int> for NonZero<$Int> {\n            type Error = TryFromIntError;\n\n            // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n            // Rustdocs on functions do not.\n            #[doc = concat!(\"Attempts to convert [`\", stringify!($Int), \"`] \")]\n            #[doc = concat!(\"to <code>[NonZero]\\\\<[\", stringify!($Int), \"]></code>.\")]\n            #[inline]\n            fn try_from(value: $Int) -> Result<Self, Self::Error> {\n                Self::new(value).ok_or(TryFromIntError(()))\n            }\n        }\n    };\n}"
    }
  ],
  "callees": [
    "65087903618051294264133097032672551694",
    "1048807128405057880515359529229977767283",
    "177028096127130855141974597834504714571"
  ]
}
