{
  "file": "core/src/convert/num.rs",
  "name": "convert::num::verify::check_nonzero_int_try_from_u32::u8::check_nonzero_int_try_from_nonzero_int::{closure#0}",
  "hash": "1264879772490409222016708222037134890067",
  "hash_direct": "175512923628440385202425065265644434276",
  "src": "|&v| {\n                    (v > 0 && (v as u128) <= (<$target>::MAX as u128))\n                        || (v < 0 && (v as i128) >= (<$target>::MIN as i128))\n                }",
  "macro_backtrace": [
    {
      "callsite": "generate_nonzero_int_try_from_nonzero_int_harness!(\n                            $source => $target,\n                            check_nonzero_int_try_from_nonzero_int,\n                            check_nonzero_int_try_from_nonzero_int_should_panic,\n                        )",
      "defsite": "macro_rules! generate_nonzero_int_try_from_nonzero_int_harness {\n        // Passing two identities - one for pass and one for panic - generates harnesses\n        // for fallible cases.\n        ($source:ty => $target:ty, $harness_pass:ident, $harness_panic:ident $(,)?) => {\n            #[kani::proof]\n            pub fn $harness_pass() {\n                let x_inner: $source = kani::any_where(|&v| {\n                    (v > 0 && (v as u128) <= (<$target>::MAX as u128))\n                        || (v < 0 && (v as i128) >= (<$target>::MIN as i128))\n                });\n                let x = NonZero::new(x_inner).unwrap();\n                let _ = NonZero::<$target>::try_from(x).unwrap();\n            }\n\n            #[kani::proof]\n            #[kani::should_panic]\n            pub fn $harness_panic() {\n                let x_inner: $source = kani::any_where(|&v| {\n                    (v > 0 && (v as u128) > (<$target>::MAX as u128))\n                        || (v < 0 && (v as i128) < (<$target>::MIN as i128))\n                        || (v == 0)\n                });\n                let x = NonZero::new(x_inner).unwrap();\n                let _ = NonZero::<$target>::try_from(x).unwrap();\n            }\n        };\n        // Passing a single identity generates harnesses for infallible cases.\n        ($source:ty => $target:ty, $harness_infallible:ident $(,)?) => {\n            #[kani::proof]\n            pub fn $harness_infallible() {\n                let x: NonZero<$source> = kani::any();\n                let _ = NonZero::<$target>::try_from(x).unwrap();\n            }\n        };\n    }"
    },
    {
      "callsite": "generate_nonzero_int_try_from_nonzero_int_harnesses!(\n        check_nonzero_int_try_from_u32,\n        u32 => (\n            [u8, u16, i8, i16, i32],\n            [usize, isize],\n        )\n    )",
      "defsite": "macro_rules! generate_nonzero_int_try_from_nonzero_int_harnesses {\n        ($ns:ident, $source:ty => ([$($target:tt),* $(,)?], [$($infallible:tt),* $(,)?] $(,)?)) => {\n            mod $ns {\n                use super::*;\n\n                $(\n                    mod $target {\n                        use super::*;\n\n                        generate_nonzero_int_try_from_nonzero_int_harness!(\n                            $source => $target,\n                            check_nonzero_int_try_from_nonzero_int,\n                            check_nonzero_int_try_from_nonzero_int_should_panic,\n                        );\n                    }\n                )*\n                $(\n                    mod $infallible {\n                        use super::*;\n\n                        generate_nonzero_int_try_from_nonzero_int_harness!(\n                            $source => $infallible,\n                            check_nonzero_int_try_from_nonzero_int_infallible,\n                        );\n                    }\n                )*\n            }\n        };\n    }"
    }
  ]
}
