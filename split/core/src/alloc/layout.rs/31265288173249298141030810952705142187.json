{
  "file": "core/src/alloc/layout.rs",
  "name": "alloc::layout::Layout::max_size_for_align",
  "hash": "31265288173249298141030810952705142187",
  "hash_direct": "10571575863883477903407192815996421989",
  "src": "const fn max_size_for_align(align: Alignment) -> usize {\n        // (power-of-two implies align != 0.)\n\n        // Rounded up size is:\n        //   size_rounded_up = (size + align - 1) & !(align - 1);\n        //\n        // We know from above that align != 0. If adding (align - 1)\n        // does not overflow, then rounding up will be fine.\n        //\n        // Conversely, &-masking with !(align - 1) will subtract off\n        // only low-order-bits. Thus if overflow occurs with the sum,\n        // the &-mask cannot subtract enough to undo that overflow.\n        //\n        // Above implies that checking for summation overflow is both\n        // necessary and sufficient.\n\n        // SAFETY: the maximum possible alignment is `isize::MAX + 1`,\n        // so the subtraction cannot overflow.\n        unsafe { unchecked_sub(isize::MAX as usize + 1, align.as_usize()) }\n    }",
  "callees": [
    "96976906222507875941165858861254841419"
  ]
}
