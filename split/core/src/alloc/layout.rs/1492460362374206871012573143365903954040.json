{
  "file": "core/src/alloc/layout.rs",
  "name": "core::alloc::Layout::size_rounded_up_to_custom_align",
  "hash": "1492460362374206871012573143365903954040",
  "hash_direct": "65996950954609537763711052150519462471",
  "src": "const fn size_rounded_up_to_custom_align(&self, align: Alignment) -> usize {\n        // SAFETY:\n        // Rounded up value is:\n        //   size_rounded_up = (size + align - 1) & !(align - 1);\n        //\n        // The arithmetic we do here can never overflow:\n        //\n        // 1. align is guaranteed to be > 0, so align - 1 is always\n        //    valid.\n        //\n        // 2. size is at most `isize::MAX`, so adding `align - 1` (which is at\n        //    most `isize::MAX`) can never overflow a `usize`.\n        //\n        // 3. masking by the alignment can remove at most `align - 1`,\n        //    which is what we just added, thus the value we return is never\n        //    less than the original `size`.\n        //\n        // (Size 0 Align MAX is already aligned, so stays the same, but things like\n        // Size 1 Align MAX or Size isize::MAX Align 2 round up to `isize::MAX + 1`.)\n        unsafe {\n            let align_m1 = unchecked_sub(align.as_usize(), 1);\n            let size_rounded_up = unchecked_add(self.size, align_m1) & !align_m1;\n            size_rounded_up\n        }\n    }",
  "callees": [
    "41567241620038406215851091758143153711"
  ]
}
