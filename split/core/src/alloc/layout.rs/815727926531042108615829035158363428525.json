{
  "file": "core/src/alloc/layout.rs",
  "name": "alloc::layout::Layout::size_rounded_up_to_custom_align",
  "hash": "815727926531042108615829035158363428525",
  "hash_direct": "88994707522965972224773293461105830751",
  "src": "const fn size_rounded_up_to_custom_align(&self, align: Alignment) -> usize {\n        // SAFETY:\n        // Rounded up value is:\n        //   size_rounded_up = (size + align - 1) & !(align - 1);\n        //\n        // The arithmetic we do here can never overflow:\n        //\n        // 1. align is guaranteed to be > 0, so align - 1 is always\n        //    valid.\n        //\n        // 2. size is at most `isize::MAX`, so adding `align - 1` (which is at\n        //    most `isize::MAX`) can never overflow a `usize`.\n        //\n        // 3. masking by the alignment can remove at most `align - 1`,\n        //    which is what we just added, thus the value we return is never\n        //    less than the original `size`.\n        //\n        // (Size 0 Align MAX is already aligned, so stays the same, but things like\n        // Size 1 Align MAX or Size isize::MAX Align 2 round up to `isize::MAX + 1`.)\n        unsafe {\n            let align_m1 = unchecked_sub(align.as_usize(), 1);\n            let size_rounded_up = unchecked_add(self.size, align_m1) & !align_m1;\n            size_rounded_up\n        }\n    }",
  "callees": [
    "96976906222507875941165858861254841419"
  ]
}
