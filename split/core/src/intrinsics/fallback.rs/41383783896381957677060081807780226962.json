{
  "file": "core/src/intrinsics/fallback.rs",
  "name": "<u128 as intrinsics::fallback::FunnelShift>::unchecked_funnel_shl",
  "hash": "41383783896381957677060081807780226962",
  "hash_direct": "2134848264836389161081769134588078162",
  "src": "unsafe fn unchecked_funnel_shl(self, rhs: Self, shift: u32) -> Self {\n                // This implementation is also used by Miri so we have to check the precondition.\n                // SAFETY: this is guaranteed by the caller\n                unsafe { super::assume(shift < $type::BITS) };\n                if shift == 0 {\n                    self\n                } else {\n                    // SAFETY:\n                    //  - `shift < T::BITS`, which satisfies `unchecked_shl`\n                    //  - this also ensures that `T::BITS - shift < T::BITS` (shift = 0 is checked\n                    //    above), which satisfies `unchecked_shr`\n                    //  - because the types are unsigned, the combination are disjoint bits (this is\n                    //    not true if they're signed, since SHR will fill in the empty space with a\n                    //    sign bit, not zero)\n                    unsafe {\n                        super::disjoint_bitor(\n                            super::unchecked_shl(self, shift),\n                            super::unchecked_shr(rhs, $type::BITS - shift),\n                        )\n                    }\n                }\n            }",
  "macro_backtrace": [
    {
      "callsite": "impl_funnel_shifts! {\n    u8, u16, u32, u64, u128, usize\n}",
      "defsite": "macro_rules! impl_funnel_shifts {\n    ($($type:ident),*) => {$(\n        #[rustc_const_unstable(feature = \"core_intrinsics_fallbacks\", issue = \"none\")]\n        impl const FunnelShift for $type {\n            #[cfg_attr(miri, track_caller)]\n            #[inline]\n            unsafe fn unchecked_funnel_shl(self, rhs: Self, shift: u32) -> Self {\n                // This implementation is also used by Miri so we have to check the precondition.\n                // SAFETY: this is guaranteed by the caller\n                unsafe { super::assume(shift < $type::BITS) };\n                if shift == 0 {\n                    self\n                } else {\n                    // SAFETY:\n                    //  - `shift < T::BITS`, which satisfies `unchecked_shl`\n                    //  - this also ensures that `T::BITS - shift < T::BITS` (shift = 0 is checked\n                    //    above), which satisfies `unchecked_shr`\n                    //  - because the types are unsigned, the combination are disjoint bits (this is\n                    //    not true if they're signed, since SHR will fill in the empty space with a\n                    //    sign bit, not zero)\n                    unsafe {\n                        super::disjoint_bitor(\n                            super::unchecked_shl(self, shift),\n                            super::unchecked_shr(rhs, $type::BITS - shift),\n                        )\n                    }\n                }\n            }\n\n            #[cfg_attr(miri, track_caller)]\n            #[inline]\n            unsafe fn unchecked_funnel_shr(self, rhs: Self, shift: u32) -> Self {\n                // This implementation is also used by Miri so we have to check the precondition.\n                // SAFETY: this is guaranteed by the caller\n                unsafe { super::assume(shift < $type::BITS) };\n                if shift == 0 {\n                    rhs\n                } else {\n                    // SAFETY:\n                    //  - `shift < T::BITS`, which satisfies `unchecked_shr`\n                    //  - this also ensures that `T::BITS - shift < T::BITS` (shift = 0 is checked\n                    //    above), which satisfies `unchecked_shl`\n                    //  - because the types are unsigned, the combination are disjoint bits (this is\n                    //    not true if they're signed, since SHR will fill in the empty space with a\n                    //    sign bit, not zero)\n                    unsafe {\n                        super::disjoint_bitor(\n                            super::unchecked_shl(self, $type::BITS - shift),\n                            super::unchecked_shr(rhs, shift),\n                        )\n                    }\n                }\n            }\n        }\n    )*};\n}"
    }
  ],
  "callees": [
    "41389422597421656741395145042566161444",
    "1097353576193677703314129679918400810765"
  ]
}
