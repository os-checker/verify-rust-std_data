{
  "file": "core/src/char/decode.rs",
  "name": "<core::char::DecodeUtf16<core::iter::Map<core::iter::Copied<core::slice::Iter<'_, [u8; 2]>>, fn([u8; core::::num::{impl#7}::from_be_bytes::{constant#0}]) -> u16 {core::num::<impl u16>::from_be_bytes}>> as core::iter::Iterator>::next",
  "hash": "118319127919444574325308853415475287884",
  "hash_direct": "1079729320177433852716780363621427680371",
  "src": "fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n        let u = match self.buf.take() {\n            Some(buf) => buf,\n            None => self.iter.next()?,\n        };\n\n        if !u.is_utf16_surrogate() {\n            // SAFETY: not a surrogate\n            Some(Ok(unsafe { char::from_u32_unchecked(u as u32) }))\n        } else if u >= 0xDC00 {\n            // a trailing surrogate\n            Some(Err(DecodeUtf16Error { code: u }))\n        } else {\n            let u2 = match self.iter.next() {\n                Some(u2) => u2,\n                // eof\n                None => return Some(Err(DecodeUtf16Error { code: u })),\n            };\n            if u2 < 0xDC00 || u2 > 0xDFFF {\n                // not a trailing surrogate so we're not a valid\n                // surrogate pair, so rewind to redecode u2 next time.\n                self.buf = Some(u2);\n                return Some(Err(DecodeUtf16Error { code: u }));\n            }\n\n            // all ok, so lets decode it.\n            let c = (((u & 0x3ff) as u32) << 10 | (u2 & 0x3ff) as u32) + 0x1_0000;\n            // SAFETY: we checked that it's a legal unicode value\n            Some(Ok(unsafe { char::from_u32_unchecked(c) }))\n        }\n    }",
  "callees": [
    "47554830076777127569397369677922726250",
    "144504416526253216358440739787798222274",
    "133295110176722646779200296597420703846",
    "12281449246394340237926324936375242532",
    "181267529910573756716102767087485333561",
    "1824545319189397521315695847785602896178",
    "1206508290603295503613972926184320751203",
    "1123039264279358816823932918682574253",
    "155954784201796491474491810208151633466",
    "136794585590173197801964910136148613895",
    "1087124770550947810917528229622155779929",
    "173617642846179087402116812334264091431",
    "19356062152124973495301804916705406438",
    "174592670632113857981889418470530760417",
    "350274559051221032312724320837697244608",
    "8358020412969843293369480817801214853",
    "1483436051876589682917815592106303415640",
    "103440356360242289282950611180150894057",
    "44020733051294954142823992724174765454",
    "773664058596078741114308388533927035965",
    "115553803619679159048380303171788048607",
    "213191719050764759611221948228851816830",
    "45104398050394565818737202389270709596",
    "59381380145263198599196460478579534630",
    "986792852990965178117440249555081278778",
    "90818112465881722349174357944217011292",
    "63085389524472853348886374617170044294",
    "1072146764878047561017269587003053591593",
    "18412722001737694041277939540962853281",
    "90755465168458458369812269229398929855",
    "1356589805382805231915733071248402652587",
    "32628225776281442825569640355230334575",
    "1317853771355193098418404737763423685347",
    "758992747592100549310649652814020507684",
    "8195918782131736758834824075544744142",
    "95750933062297003262468879752983065416",
    "841344188694266590295617675180068548",
    "43454486921978344837886701645797667530",
    "32127953328920885943220843295221183156",
    "180635224128130815714204029673366671286",
    "112989397975222255532054380452996322405"
  ]
}
