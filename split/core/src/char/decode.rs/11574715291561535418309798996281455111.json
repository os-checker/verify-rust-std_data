{
  "file": "core/src/char/decode.rs",
  "name": "<core::char::DecodeUtf16<core::iter::Map<core::iter::Copied<core::slice::Iter<'_, [u8; 2]>>, fn([u8; core::::num::{impl#7}::from_le_bytes::{constant#0}]) -> u16 {core::num::<impl u16>::from_le_bytes}>> as core::iter::Iterator>::size_hint",
  "hash": "11574715291561535418309798996281455111",
  "hash_direct": "58002562732289595073992128122924252551",
  "src": "fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.iter.size_hint();\n\n        let (low_buf, high_buf) = match self.buf {\n            // buf is empty, no additional elements from it.\n            None => (0, 0),\n            // `u` is a non surrogate, so it's always an additional character.\n            Some(u) if !u.is_utf16_surrogate() => (1, 1),\n            // `u` is a leading surrogate (it can never be a trailing surrogate and\n            // it's a surrogate due to the previous branch) and `self.iter` is empty.\n            //\n            // `u` can't be paired, since the `self.iter` is empty,\n            // so it will always become an additional element (error).\n            Some(_u) if high == Some(0) => (1, 1),\n            // `u` is a leading surrogate and `iter` may be non-empty.\n            //\n            // `u` can either pair with a trailing surrogate, in which case no additional elements\n            // are produced, or it can become an error, in which case it's an additional character (error).\n            Some(_u) => (0, 1),\n        };\n\n        // `self.iter` could contain entirely valid surrogates (2 elements per\n        // char), or entirely non-surrogates (1 element per char).\n        //\n        // On odd lower bound, at least one element must stay unpaired\n        // (with other elements from `self.iter`), so we round up.\n        let low = low.div_ceil(2) + low_buf;\n        let high = high.and_then(|h| h.checked_add(high_buf));\n\n        (low, high)\n    }",
  "callees": [
    "1409818791154466704612867106911261757513",
    "11563104784935977822392899470914495442",
    "12281449246394340237926324936375242532",
    "99835071136844477394667148890151411684",
    "73694171442177138896992135977130617471",
    "181267529910573756716102767087485333561",
    "310476737258981539215905981644988688429",
    "1824545319189397521315695847785602896178",
    "1502532036472379137416841110129532542372",
    "10995742834928466727814670536028871489",
    "63445776558743760357306790643934962414",
    "136794585590173197801964910136148613895",
    "60640990905534157415573489096491372167",
    "1625739578339948557413642250871706873641",
    "138823648129421339412755970406599427122",
    "1806791799854859715812616382117092630860",
    "986792852990965178117440249555081278778",
    "90818112465881722349174357944217011292",
    "170281423934441608902372914597711355436",
    "146612017564224181584303574960223420416",
    "63085389524472853348886374617170044294",
    "262831349882779883815480941076479924039",
    "1072146764878047561017269587003053591593",
    "18412722001737694041277939540962853281",
    "98013996996898740901643262307867167755",
    "48057160372141403285748093406035979284",
    "140066426326881796268168576009078000940",
    "8195918782131736758834824075544744142",
    "113589442066407346807885183239821737822",
    "8724462970617561261693075685138175164",
    "747156457449598790816736684951635660145",
    "112989397975222255532054380452996322405"
  ]
}
