{
  "file": "core/src/char/decode.rs",
  "name": "<core::char::DecodeUtf16<core::iter::Map<core::iter::Copied<core::slice::Iter<'_, [u8; 2]>>, fn([u8; core::::num::{impl#7}::from_le_bytes::{constant#0}]) -> u16 {core::num::<impl u16>::from_le_bytes}>> as core::iter::Iterator>::next",
  "hash": "568230605572932654515382506035694488336",
  "hash_direct": "22318001566678474073653446916233074576",
  "src": "fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n        let u = match self.buf.take() {\n            Some(buf) => buf,\n            None => self.iter.next()?,\n        };\n\n        if !u.is_utf16_surrogate() {\n            // SAFETY: not a surrogate\n            Some(Ok(unsafe { char::from_u32_unchecked(u as u32) }))\n        } else if u >= 0xDC00 {\n            // a trailing surrogate\n            Some(Err(DecodeUtf16Error { code: u }))\n        } else {\n            let u2 = match self.iter.next() {\n                Some(u2) => u2,\n                // eof\n                None => return Some(Err(DecodeUtf16Error { code: u })),\n            };\n            if u2 < 0xDC00 || u2 > 0xDFFF {\n                // not a trailing surrogate so we're not a valid\n                // surrogate pair, so rewind to redecode u2 next time.\n                self.buf = Some(u2);\n                return Some(Err(DecodeUtf16Error { code: u }));\n            }\n\n            // all ok, so lets decode it.\n            let c = (((u & 0x3ff) as u32) << 10 | (u2 & 0x3ff) as u32) + 0x1_0000;\n            // SAFETY: we checked that it's a legal unicode value\n            Some(Ok(unsafe { char::from_u32_unchecked(c) }))\n        }\n    }",
  "callees": [
    "47554830076777127569397369677922726250",
    "144504416526253216358440739787798222274",
    "133295110176722646779200296597420703846",
    "12281449246394340237926324936375242532",
    "181267529910573756716102767087485333561",
    "1824545319189397521315695847785602896178",
    "1206508290603295503613972926184320751203",
    "283761827165603689417141859740102055206",
    "155954784201796491474491810208151633466",
    "136794585590173197801964910136148613895",
    "110222155973830814349260760002242824076",
    "994990930139430189416100114842589589707",
    "19356062152124973495301804916705406438",
    "350274559051221032312724320837697244608",
    "8358020412969843293369480817801214853",
    "1483436051876589682917815592106303415640",
    "712743223775799218711855056139160103918",
    "125256131007379623269364805092313130661",
    "773664058596078741114308388533927035965",
    "115553803619679159048380303171788048607",
    "213191719050764759611221948228851816830",
    "131002414102527166921957418261776223620",
    "59381380145263198599196460478579534630",
    "986792852990965178117440249555081278778",
    "90818112465881722349174357944217011292",
    "63085389524472853348886374617170044294",
    "1072146764878047561017269587003053591593",
    "18412722001737694041277939540962853281",
    "64689618837288227206170671061387173645",
    "1356589805382805231915733071248402652587",
    "32628225776281442825569640355230334575",
    "1317853771355193098418404737763423685347",
    "758992747592100549310649652814020507684",
    "8195918782131736758834824075544744142",
    "95750933062297003262468879752983065416",
    "841344188694266590295617675180068548",
    "43454486921978344837886701645797667530",
    "32127953328920885943220843295221183156",
    "180635224128130815714204029673366671286",
    "112989397975222255532054380452996322405"
  ]
}
