{
  "file": "core/src/char/decode.rs",
  "name": "<core::char::DecodeUtf16<core::iter::Map<core::iter::Copied<core::slice::Iter<'_, [u8; 2]>>, fn([u8; core::::num::{impl#7}::from_le_bytes::{constant#0}]) -> u16 {core::num::<impl u16>::from_le_bytes}>> as core::iter::Iterator>::next",
  "hash": "1559197646289373119712529052667214203472",
  "hash_direct": "22318001566678474073653446916233074576",
  "src": "fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n        let u = match self.buf.take() {\n            Some(buf) => buf,\n            None => self.iter.next()?,\n        };\n\n        if !u.is_utf16_surrogate() {\n            // SAFETY: not a surrogate\n            Some(Ok(unsafe { char::from_u32_unchecked(u as u32) }))\n        } else if u >= 0xDC00 {\n            // a trailing surrogate\n            Some(Err(DecodeUtf16Error { code: u }))\n        } else {\n            let u2 = match self.iter.next() {\n                Some(u2) => u2,\n                // eof\n                None => return Some(Err(DecodeUtf16Error { code: u })),\n            };\n            if u2 < 0xDC00 || u2 > 0xDFFF {\n                // not a trailing surrogate so we're not a valid\n                // surrogate pair, so rewind to redecode u2 next time.\n                self.buf = Some(u2);\n                return Some(Err(DecodeUtf16Error { code: u }));\n            }\n\n            // all ok, so lets decode it.\n            let c = (((u & 0x3ff) as u32) << 10 | (u2 & 0x3ff) as u32) + 0x1_0000;\n            // SAFETY: we checked that it's a legal unicode value\n            Some(Ok(unsafe { char::from_u32_unchecked(c) }))\n        }\n    }",
  "callees": [
    "104550528282774795524117016372908034501",
    "146994998949606397634275197795948319731",
    "1664835611994150133815177247542444862856",
    "12281449246394340237926324936375242532",
    "181267529910573756716102767087485333561",
    "1824545319189397521315695847785602896178",
    "579132970795087832117499644956533245419",
    "745735148192762630111571061346114097434",
    "155954784201796491474491810208151633466",
    "136794585590173197801964910136148613895",
    "110529358142384840932381700667077663633",
    "154814872857791229444909894964015826161",
    "164920246545788730618233309646997589036",
    "596717226459156418513221677816795970108",
    "167720725353303677441984078993999087147",
    "349732893336648829317640041454262824981",
    "56512467496642389877585091471634591177",
    "882516872501883330013947781493068822685",
    "773664058596078741114308388533927035965",
    "115553803619679159048380303171788048607",
    "213191719050764759611221948228851816830",
    "674545409956571749715398991869454958923",
    "59381380145263198599196460478579534630",
    "986792852990965178117440249555081278778",
    "90818112465881722349174357944217011292",
    "63085389524472853348886374617170044294",
    "1072146764878047561017269587003053591593",
    "18412722001737694041277939540962853281",
    "64689618837288227206170671061387173645",
    "1356589805382805231915733071248402652587",
    "32628225776281442825569640355230334575",
    "1317853771355193098418404737763423685347",
    "758992747592100549310649652814020507684",
    "8195918782131736758834824075544744142",
    "95750933062297003262468879752983065416",
    "841344188694266590295617675180068548",
    "1280021660972925672111869872627306200650",
    "879543598591726583811363902326698267760",
    "1396369027985523187512983890317312644464",
    "112989397975222255532054380452996322405"
  ]
}
