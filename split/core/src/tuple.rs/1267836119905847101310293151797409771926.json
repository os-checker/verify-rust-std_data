{
  "file": "core/src/tuple.rs",
  "name": "tuple::<impl convert::From<[T; 7]> for (T, T, T, T, T, T, T)>::{constant#0}",
  "hash": "1267836119905847101310293151797409771926",
  "hash_direct": "117522521033813132045434794179299161001",
  "src": "{count($T)}",
  "macro_backtrace": [
    {
      "callsite": "tuple_impls!(@impl $T $( $U )+)",
      "defsite": "macro_rules! tuple_impls {\n    // Stopping criteria (1-ary tuple)\n    ($T:ident) => {\n        tuple_impls!(@impl $T);\n    };\n    // Running criteria (n-ary tuple, with n >= 2)\n    ($T:ident $( $U:ident )+) => {\n        tuple_impls!($( $U )+);\n        tuple_impls!(@impl $T $( $U )+);\n    };\n    // \"Private\" internal implementation\n    (@impl $( $T:ident )+) => {\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: PartialEq),+> PartialEq for ($($T,)+) {\n                #[inline]\n                fn eq(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore($T)} self.${index()} == other.${index()} )&&+\n                }\n                #[inline]\n                fn ne(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore($T)} self.${index()} != other.${index()} )||+\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Eq),+> Eq for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"adt_const_params\", issue = \"95174\")]\n            impl<$($T: ConstParamTy_),+> ConstParamTy_ for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"unsized_const_params\", issue = \"95174\")]\n            impl<$($T: UnsizedConstParamTy),+> UnsizedConstParamTy for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"structural_match\", issue = \"31434\")]\n            impl<$($T),+> StructuralPartialEq for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: PartialOrd),+> PartialOrd for ($($T,)+)\n            {\n                #[inline]\n                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n                    lexical_partial_cmp!($( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn lt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(lt, __chaining_lt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn le(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(le, __chaining_le, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn ge(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(ge, __chaining_ge, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn gt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(gt, __chaining_gt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_lt(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_lt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_le(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_le, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_gt(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_gt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_ge(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_ge, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Ord),+> Ord for ($($T,)+)\n            {\n                #[inline]\n                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                    lexical_cmp!($( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Default),+> Default for ($($T,)+) {\n                #[inline]\n                fn default() -> ($($T,)+) {\n                    ($({ let x: $T = Default::default(); x},)+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"array_tuple_conv\", since = \"1.71.0\")]\n            impl<T> From<[T; ${count($T)}]> for ($(${ignore($T)} T,)+) {\n                #[inline]\n                #[allow(non_snake_case)]\n                fn from(array: [T; ${count($T)}]) -> Self {\n                    let [$($T,)+] = array;\n                    ($($T,)+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"array_tuple_conv\", since = \"1.71.0\")]\n            impl<T> From<($(${ignore($T)} T,)+)> for [T; ${count($T)}] {\n                #[inline]\n                #[allow(non_snake_case)]\n                fn from(tuple: ($(${ignore($T)} T,)+)) -> Self {\n                    let ($($T,)+) = tuple;\n                    [$($T,)+]\n                }\n            }\n        }\n    }\n}"
    },
    {
      "callsite": "tuple_impls!($( $U )+)",
      "defsite": "macro_rules! tuple_impls {\n    // Stopping criteria (1-ary tuple)\n    ($T:ident) => {\n        tuple_impls!(@impl $T);\n    };\n    // Running criteria (n-ary tuple, with n >= 2)\n    ($T:ident $( $U:ident )+) => {\n        tuple_impls!($( $U )+);\n        tuple_impls!(@impl $T $( $U )+);\n    };\n    // \"Private\" internal implementation\n    (@impl $( $T:ident )+) => {\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: PartialEq),+> PartialEq for ($($T,)+) {\n                #[inline]\n                fn eq(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore($T)} self.${index()} == other.${index()} )&&+\n                }\n                #[inline]\n                fn ne(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore($T)} self.${index()} != other.${index()} )||+\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Eq),+> Eq for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"adt_const_params\", issue = \"95174\")]\n            impl<$($T: ConstParamTy_),+> ConstParamTy_ for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"unsized_const_params\", issue = \"95174\")]\n            impl<$($T: UnsizedConstParamTy),+> UnsizedConstParamTy for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"structural_match\", issue = \"31434\")]\n            impl<$($T),+> StructuralPartialEq for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: PartialOrd),+> PartialOrd for ($($T,)+)\n            {\n                #[inline]\n                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n                    lexical_partial_cmp!($( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn lt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(lt, __chaining_lt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn le(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(le, __chaining_le, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn ge(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(ge, __chaining_ge, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn gt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(gt, __chaining_gt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_lt(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_lt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_le(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_le, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_gt(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_gt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_ge(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_ge, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Ord),+> Ord for ($($T,)+)\n            {\n                #[inline]\n                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                    lexical_cmp!($( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Default),+> Default for ($($T,)+) {\n                #[inline]\n                fn default() -> ($($T,)+) {\n                    ($({ let x: $T = Default::default(); x},)+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"array_tuple_conv\", since = \"1.71.0\")]\n            impl<T> From<[T; ${count($T)}]> for ($(${ignore($T)} T,)+) {\n                #[inline]\n                #[allow(non_snake_case)]\n                fn from(array: [T; ${count($T)}]) -> Self {\n                    let [$($T,)+] = array;\n                    ($($T,)+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"array_tuple_conv\", since = \"1.71.0\")]\n            impl<T> From<($(${ignore($T)} T,)+)> for [T; ${count($T)}] {\n                #[inline]\n                #[allow(non_snake_case)]\n                fn from(tuple: ($(${ignore($T)} T,)+)) -> Self {\n                    let ($($T,)+) = tuple;\n                    [$($T,)+]\n                }\n            }\n        }\n    }\n}"
    },
    {
      "callsite": "tuple_impls!($( $U )+)",
      "defsite": "macro_rules! tuple_impls {\n    // Stopping criteria (1-ary tuple)\n    ($T:ident) => {\n        tuple_impls!(@impl $T);\n    };\n    // Running criteria (n-ary tuple, with n >= 2)\n    ($T:ident $( $U:ident )+) => {\n        tuple_impls!($( $U )+);\n        tuple_impls!(@impl $T $( $U )+);\n    };\n    // \"Private\" internal implementation\n    (@impl $( $T:ident )+) => {\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: PartialEq),+> PartialEq for ($($T,)+) {\n                #[inline]\n                fn eq(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore($T)} self.${index()} == other.${index()} )&&+\n                }\n                #[inline]\n                fn ne(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore($T)} self.${index()} != other.${index()} )||+\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Eq),+> Eq for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"adt_const_params\", issue = \"95174\")]\n            impl<$($T: ConstParamTy_),+> ConstParamTy_ for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"unsized_const_params\", issue = \"95174\")]\n            impl<$($T: UnsizedConstParamTy),+> UnsizedConstParamTy for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"structural_match\", issue = \"31434\")]\n            impl<$($T),+> StructuralPartialEq for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: PartialOrd),+> PartialOrd for ($($T,)+)\n            {\n                #[inline]\n                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n                    lexical_partial_cmp!($( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn lt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(lt, __chaining_lt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn le(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(le, __chaining_le, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn ge(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(ge, __chaining_ge, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn gt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(gt, __chaining_gt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_lt(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_lt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_le(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_le, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_gt(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_gt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_ge(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_ge, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Ord),+> Ord for ($($T,)+)\n            {\n                #[inline]\n                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                    lexical_cmp!($( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Default),+> Default for ($($T,)+) {\n                #[inline]\n                fn default() -> ($($T,)+) {\n                    ($({ let x: $T = Default::default(); x},)+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"array_tuple_conv\", since = \"1.71.0\")]\n            impl<T> From<[T; ${count($T)}]> for ($(${ignore($T)} T,)+) {\n                #[inline]\n                #[allow(non_snake_case)]\n                fn from(array: [T; ${count($T)}]) -> Self {\n                    let [$($T,)+] = array;\n                    ($($T,)+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"array_tuple_conv\", since = \"1.71.0\")]\n            impl<T> From<($(${ignore($T)} T,)+)> for [T; ${count($T)}] {\n                #[inline]\n                #[allow(non_snake_case)]\n                fn from(tuple: ($(${ignore($T)} T,)+)) -> Self {\n                    let ($($T,)+) = tuple;\n                    [$($T,)+]\n                }\n            }\n        }\n    }\n}"
    },
    {
      "callsite": "tuple_impls!(E D C B A Z Y X W V U T)",
      "defsite": "macro_rules! tuple_impls {\n    // Stopping criteria (1-ary tuple)\n    ($T:ident) => {\n        tuple_impls!(@impl $T);\n    };\n    // Running criteria (n-ary tuple, with n >= 2)\n    ($T:ident $( $U:ident )+) => {\n        tuple_impls!($( $U )+);\n        tuple_impls!(@impl $T $( $U )+);\n    };\n    // \"Private\" internal implementation\n    (@impl $( $T:ident )+) => {\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: PartialEq),+> PartialEq for ($($T,)+) {\n                #[inline]\n                fn eq(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore($T)} self.${index()} == other.${index()} )&&+\n                }\n                #[inline]\n                fn ne(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore($T)} self.${index()} != other.${index()} )||+\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Eq),+> Eq for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"adt_const_params\", issue = \"95174\")]\n            impl<$($T: ConstParamTy_),+> ConstParamTy_ for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"unsized_const_params\", issue = \"95174\")]\n            impl<$($T: UnsizedConstParamTy),+> UnsizedConstParamTy for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[unstable(feature = \"structural_match\", issue = \"31434\")]\n            impl<$($T),+> StructuralPartialEq for ($($T,)+)\n            {}\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: PartialOrd),+> PartialOrd for ($($T,)+)\n            {\n                #[inline]\n                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n                    lexical_partial_cmp!($( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn lt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(lt, __chaining_lt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn le(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(le, __chaining_le, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn ge(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(ge, __chaining_ge, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn gt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(gt, __chaining_gt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_lt(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_lt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_le(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_le, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_gt(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_gt, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn __chaining_ge(&self, other: &($($T,)+)) -> ControlFlow<bool> {\n                    lexical_chain!(__chaining_ge, $( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Ord),+> Ord for ($($T,)+)\n            {\n                #[inline]\n                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                    lexical_cmp!($( ${ignore($T)} self.${index()}, other.${index()} ),+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T: Default),+> Default for ($($T,)+) {\n                #[inline]\n                fn default() -> ($($T,)+) {\n                    ($({ let x: $T = Default::default(); x},)+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"array_tuple_conv\", since = \"1.71.0\")]\n            impl<T> From<[T; ${count($T)}]> for ($(${ignore($T)} T,)+) {\n                #[inline]\n                #[allow(non_snake_case)]\n                fn from(array: [T; ${count($T)}]) -> Self {\n                    let [$($T,)+] = array;\n                    ($($T,)+)\n                }\n            }\n        }\n\n        maybe_tuple_doc! {\n            $($T)+ @\n            #[stable(feature = \"array_tuple_conv\", since = \"1.71.0\")]\n            impl<T> From<($(${ignore($T)} T,)+)> for [T; ${count($T)}] {\n                #[inline]\n                #[allow(non_snake_case)]\n                fn from(tuple: ($(${ignore($T)} T,)+)) -> Self {\n                    let ($($T,)+) = tuple;\n                    [$($T,)+]\n                }\n            }\n        }\n    }\n}"
    }
  ]
}
