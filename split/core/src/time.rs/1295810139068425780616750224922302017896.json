{
  "file": "core/src/time.rs",
  "name": "time::Duration::try_from_secs_f32::MANT_MASK",
  "hash": "1295810139068425780616750224922302017896",
  "hash_direct": "99380228678961226724405735237500045281",
  "src": "const MANT_MASK: $bits_ty = (1 << $mant_bits) - 1;",
  "macro_backtrace": [
    {
      "callsite": "try_from_secs!(\n            secs = secs,\n            mantissa_bits = 23,\n            exponent_bits = 8,\n            offset = 41,\n            bits_ty = u32,\n            double_ty = u64,\n        )",
      "defsite": "macro_rules! try_from_secs {\n    (\n        secs = $secs: expr,\n        mantissa_bits = $mant_bits: literal,\n        exponent_bits = $exp_bits: literal,\n        offset = $offset: literal,\n        bits_ty = $bits_ty:ty,\n        double_ty = $double_ty:ty,\n    ) => {{\n        const MIN_EXP: i16 = 1 - (1i16 << $exp_bits) / 2;\n        const MANT_MASK: $bits_ty = (1 << $mant_bits) - 1;\n        const EXP_MASK: $bits_ty = (1 << $exp_bits) - 1;\n\n        if $secs < 0.0 {\n            return Err(TryFromFloatSecsError { kind: TryFromFloatSecsErrorKind::Negative });\n        }\n\n        let bits = $secs.to_bits();\n        let mant = (bits & MANT_MASK) | (MANT_MASK + 1);\n        let exp = ((bits >> $mant_bits) & EXP_MASK) as i16 + MIN_EXP;\n\n        let (secs, nanos) = if exp < -31 {\n            // the input represents less than 1ns and can not be rounded to it\n            (0u64, 0u32)\n        } else if exp < 0 {\n            // the input is less than 1 second\n            let t = <$double_ty>::from(mant) << ($offset + exp);\n            let nanos_offset = $mant_bits + $offset;\n            let nanos_tmp = u128::from(NANOS_PER_SEC) * u128::from(t);\n            let nanos = (nanos_tmp >> nanos_offset) as u32;\n\n            let rem_mask = (1 << nanos_offset) - 1;\n            let rem_msb_mask = 1 << (nanos_offset - 1);\n            let rem = nanos_tmp & rem_mask;\n            let is_tie = rem == rem_msb_mask;\n            let is_even = (nanos & 1) == 0;\n            let rem_msb = nanos_tmp & rem_msb_mask == 0;\n            let add_ns = !(rem_msb || (is_even && is_tie));\n\n            // f32 does not have enough precision to trigger the second branch\n            // since it can not represent numbers between 0.999_999_940_395 and 1.0.\n            let nanos = nanos + add_ns as u32;\n            if ($mant_bits == 23) || (nanos != NANOS_PER_SEC) { (0, nanos) } else { (1, 0) }\n        } else if exp < $mant_bits {\n            let secs = u64::from(mant >> ($mant_bits - exp));\n            let t = <$double_ty>::from((mant << exp) & MANT_MASK);\n            let nanos_offset = $mant_bits;\n            let nanos_tmp = <$double_ty>::from(NANOS_PER_SEC) * t;\n            let nanos = (nanos_tmp >> nanos_offset) as u32;\n\n            let rem_mask = (1 << nanos_offset) - 1;\n            let rem_msb_mask = 1 << (nanos_offset - 1);\n            let rem = nanos_tmp & rem_mask;\n            let is_tie = rem == rem_msb_mask;\n            let is_even = (nanos & 1) == 0;\n            let rem_msb = nanos_tmp & rem_msb_mask == 0;\n            let add_ns = !(rem_msb || (is_even && is_tie));\n\n            // f32 does not have enough precision to trigger the second branch.\n            // For example, it can not represent numbers between 1.999_999_880...\n            // and 2.0. Bigger values result in even smaller precision of the\n            // fractional part.\n            let nanos = nanos + add_ns as u32;\n            if ($mant_bits == 23) || (nanos != NANOS_PER_SEC) {\n                (secs, nanos)\n            } else {\n                (secs + 1, 0)\n            }\n        } else if exp < 64 {\n            // the input has no fractional part\n            let secs = u64::from(mant) << (exp - $mant_bits);\n            (secs, 0)\n        } else {\n            return Err(TryFromFloatSecsError { kind: TryFromFloatSecsErrorKind::OverflowOrNan });\n        };\n\n        Ok(Duration::new(secs, nanos))\n    }};\n}"
    }
  ]
}
