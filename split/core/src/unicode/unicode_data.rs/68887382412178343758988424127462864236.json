{
  "file": "core/src/unicode/unicode_data.rs",
  "name": "unicode::unicode_data::skip_search::<22, 319>",
  "hash": "68887382412178343758988424127462864236",
  "hash_direct": "1114719540125062601615571741459459220183",
  "src": "unsafe fn skip_search<const SOR: usize, const OFFSETS: usize>(\n    needle: char,\n    short_offset_runs: &[ShortOffsetRunHeader; SOR],\n    offsets: &[u8; OFFSETS],\n) -> bool {\n    let needle = needle as u32;\n\n    let last_idx =\n        match short_offset_runs.binary_search_by_key(&(needle << 11), |header| header.0 << 11) {\n            Ok(idx) => idx + 1,\n            Err(idx) => idx,\n        };\n    // SAFETY: `last_idx` *cannot* be past the end of the array, as the last\n    // element is greater than `std::char::MAX` (the largest possible needle)\n    // as guaranteed by the caller.\n    //\n    // So, we cannot have found it (i.e. `Ok(idx) => idx + 1 != length`) and the\n    // correct location cannot be past it, so `Err(idx) => idx != length` either.\n    //\n    // This means that we can avoid bounds checking for the accesses below, too.\n    //\n    // We need to use `intrinsics::assume` since the `panic_nounwind` contained\n    // in `hint::assert_unchecked` may not be optimized out.\n    unsafe { crate::intrinsics::assume(last_idx < SOR) };\n\n    let mut offset_idx = short_offset_runs[last_idx].start_index();\n    let length = if let Some(next) = short_offset_runs.get(last_idx + 1) {\n        (*next).start_index() - offset_idx\n    } else {\n        offsets.len() - offset_idx\n    };\n\n    let prev =\n        last_idx.checked_sub(1).map(|prev| short_offset_runs[prev].prefix_sum()).unwrap_or(0);\n\n    let total = needle - prev;\n    let mut prefix_sum = 0;\n    for _ in 0..(length - 1) {\n        // SAFETY: It is guaranteed that `length <= OFFSETS - offset_idx`,\n        // so it follows that `length - 1 + offset_idx < OFFSETS`, therefore\n        // `offset_idx < OFFSETS` is always true in this loop.\n        //\n        // We need to use `intrinsics::assume` since the `panic_nounwind` contained\n        // in `hint::assert_unchecked` may not be optimized out.\n        unsafe { crate::intrinsics::assume(offset_idx < OFFSETS) };\n        let offset = offsets[offset_idx];\n        prefix_sum += offset as u32;\n        if prefix_sum > total {\n            break;\n        }\n        offset_idx += 1;\n    }\n    offset_idx % 2 == 1\n}",
  "callees": [
    "81385294222362714685518950164453635767",
    "6805562217973734478490858430748473698",
    "589599466487462365011430963401962118509",
    "47323665595455568617290020941376774286",
    "11139495935450220752286966752445431093",
    "1048826569175922670011956699091393235644",
    "144365221844634164973961738423316145170",
    "52266615998776091406665035415017120997",
    "1329845230409163288212548289525672875535",
    "109763229663154342343123224747831634619",
    "16824420916691935049705640393259467449",
    "561445107989240208511361370086377379752",
    "1438611585775203574910130895685408999981",
    "180874735662080423702617202418949819065",
    "1388505351152652276212287879007466526739",
    "526814189773195139817557993623059721647",
    "93472950105651706242259860463308488264",
    "102189070583536888521073139681085973390",
    "164434928084716863346001339216522172725",
    "138978394266802077512946941858154207832",
    "1097272359839326724310084488330926354210",
    "1245138925531671967011772485621443291799",
    "290360310864386898714327273451929980463",
    "1617054938297627622011998382328717871744",
    "1196638383615410162910723134175805433641",
    "1182371843420022111010336901757313084440",
    "13796074939706337624507826801091410480",
    "448668348263103227112942894305085327043",
    "15540827688883885545665416931579950807",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "1243847030362955698517207199029174369810",
    "105125143701458073564296455695110349394",
    "25930241974724637292994171257021210872",
    "617554482545947003412104686554524783687",
    "1445917162577882149418297081791436471284",
    "849628185942532211610194183090257053256",
    "1738831485416314296017601195330758574923",
    "53398805961609338523376489634073401615",
    "703663108277374327010040438608357482834",
    "1100495660517602822510660091708953776518",
    "92880896475004770282622108900229659760",
    "13313173089811010157441263592841615988",
    "20986198496993118725423036564777905464",
    "718111253804944270316602693767644141239",
    "178908583266819311171056730682051642189",
    "136032794974893814259994759472454752644",
    "1258173806717946934615019537746325263233",
    "1689384820785723149314678593298307912080",
    "112549728288708924487590960373031667073",
    "1412396542820481544111291621418681240082",
    "127894720137992047561307630410653898601",
    "585608793715020781013282701707677678789",
    "1038146470883482891210358665944751071651",
    "1228992362305440906716088009257992515786",
    "909138891686617124910093832980156420866",
    "167678068380068404989249186208406167029",
    "146890685265567593521124048110972570359",
    "138774632689772549819578629668035245923",
    "90175179397242369455372712796954544135",
    "156558724737321886766153526308848840146",
    "48548664629730829953422984265893277498",
    "399232661239117480517401994520839366833",
    "165260604638305226342101042842060873588",
    "34478597508049401479557782585707843723",
    "1696811055327457487716691781965262582152",
    "620230244182981955916602356246593208579",
    "13138234961168265144375254859311549629",
    "1560390624822037292115708238234738706201"
  ]
}
