{
  "file": "core/src/unicode/unicode_data.rs",
  "name": "core::unicode::unicode_data::skip_search::<34, 751>",
  "hash": "111794617049695779408212976242320368265",
  "hash_direct": "1120958934295026446516825988254932463756",
  "src": "unsafe fn skip_search<const SOR: usize, const OFFSETS: usize>(\n    needle: char,\n    short_offset_runs: &[ShortOffsetRunHeader; SOR],\n    offsets: &[u8; OFFSETS],\n) -> bool {\n    let needle = needle as u32;\n\n    let last_idx =\n        match short_offset_runs.binary_search_by_key(&(needle << 11), |header| header.0 << 11) {\n            Ok(idx) => idx + 1,\n            Err(idx) => idx,\n        };\n    // SAFETY: `last_idx` *cannot* be past the end of the array, as the last\n    // element is greater than `std::char::MAX` (the largest possible needle)\n    // as guaranteed by the caller.\n    //\n    // So, we cannot have found it (i.e. `Ok(idx) => idx + 1 != length`) and the\n    // correct location cannot be past it, so `Err(idx) => idx != length` either.\n    //\n    // This means that we can avoid bounds checking for the accesses below, too.\n    //\n    // We need to use `intrinsics::assume` since the `panic_nounwind` contained\n    // in `hint::assert_unchecked` may not be optimized out.\n    unsafe { crate::intrinsics::assume(last_idx < SOR) };\n\n    let mut offset_idx = short_offset_runs[last_idx].start_index();\n    let length = if let Some(next) = short_offset_runs.get(last_idx + 1) {\n        (*next).start_index() - offset_idx\n    } else {\n        offsets.len() - offset_idx\n    };\n\n    let prev =\n        last_idx.checked_sub(1).map(|prev| short_offset_runs[prev].prefix_sum()).unwrap_or(0);\n\n    let total = needle - prev;\n    let mut prefix_sum = 0;\n    for _ in 0..(length - 1) {\n        // SAFETY: It is guaranteed that `length <= OFFSETS - offset_idx`,\n        // so it follows that `length - 1 + offset_idx < OFFSETS`, therefore\n        // `offset_idx < OFFSETS` is always true in this loop.\n        //\n        // We need to use `intrinsics::assume` since the `panic_nounwind` contained\n        // in `hint::assert_unchecked` may not be optimized out.\n        unsafe { crate::intrinsics::assume(offset_idx < OFFSETS) };\n        let offset = offsets[offset_idx];\n        prefix_sum += offset as u32;\n        if prefix_sum > total {\n            break;\n        }\n        offset_idx += 1;\n    }\n    offset_idx % 2 == 1\n}",
  "callees": [
    "141364671331973869778270942055776551817",
    "38033425202961758733378719026903933598",
    "1760151968317278624513482005825546212798",
    "12281449246394340237926324936375242532",
    "1511275866077199755612412536318849312657",
    "1768913793289742146612177224668359908109",
    "94205340984548205403161824858415082908",
    "1263945855766849354510334944065532128780",
    "181267529910573756716102767087485333561",
    "79817071675776388295206212610749591701",
    "1824545319189397521315695847785602896178",
    "141051090481435808783715316343782561731",
    "87062518103154485528422368842656325288",
    "3658313454039325477944363122213121015",
    "815298085534125605714469750090114749026",
    "4985460341548456644715340132601722906",
    "11976266579713756835272321175156879554",
    "700121798421844638112954362982616513440",
    "3426408591059629602792909874372843773",
    "114741638161998136903549224640438971859",
    "139483837448589163674758035261080447269",
    "439022777647632696517945103495108037392",
    "4076984766143030440815189235784749564",
    "121538525422948258517615039717339200941",
    "51372523453683089364244340980133861262",
    "169382045895387326079929663684999712557",
    "105784042461548404615622384875082564775",
    "104367634591107546717821077127163354051",
    "45320022097344468766723726317823118416",
    "320752001696268705613969942614017134368",
    "986792852990965178117440249555081278778",
    "90818112465881722349174357944217011292",
    "146612017564224181584303574960223420416",
    "63085389524472853348886374617170044294",
    "175623961004431005849298709567805707658",
    "33067340742295788584221598515845050786",
    "139907086782363519768211215911218405340",
    "181953690662554297912505335505865467275",
    "154716117204139621346903708735117238315",
    "10435104334233940885347855730897394048",
    "1793681111599931821712213635413918902143",
    "55408212128999564608147158566316072753",
    "453447829425605175013828912841818007745",
    "1328599216671135015714776194882339466358",
    "401184682645594039513185690909655823909",
    "1102707990469809545812015399289882219301",
    "8161099640543304955344124854131248786",
    "19058764743854314419670517218317949449",
    "89898726682182899673927275838299842474",
    "659673443888135953213414572294403335870",
    "1407178942761306800517059706368724050443",
    "1321571500445129312813707138744963876450",
    "35090294169429653114888470028367354460",
    "112179773871628927303876335612651688990",
    "70542180169395563810324335690772955151",
    "1048239568639303402217163541801075374271",
    "156903084411892069662943432195514942503",
    "1108872896406389492011663091904032266319",
    "83849535035327804979354663630505665277",
    "1753166894143510804112784709663712737672",
    "42640861811413251621458178080920148489",
    "8787952082428538504365079471726452107",
    "1751182092721409607066971085433427634",
    "34168428747107921917921965588564672058",
    "112989397975222255532054380452996322405",
    "56586361413793673417653620039252553370",
    "192903257417349624310389255189038584608",
    "26987256806444037714655035545793307687",
    "27026375606464682699539692727856734723",
    "177905935490097550717772327309877997817",
    "78478499426420116864547417368859725784"
  ]
}
