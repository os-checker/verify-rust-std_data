{
  "file": "core/src/unicode/unicode_data.rs",
  "name": "unicode::unicode_data::skip_search::<22, 315>",
  "hash": "73225728514330242144096820054902171347",
  "hash_direct": "137221693755677227676933754453866736389",
  "src": "unsafe fn skip_search<const SOR: usize, const OFFSETS: usize>(\n    needle: char,\n    short_offset_runs: &[ShortOffsetRunHeader; SOR],\n    offsets: &[u8; OFFSETS],\n) -> bool {\n    let needle = needle as u32;\n\n    let last_idx =\n        match short_offset_runs.binary_search_by_key(&(needle << 11), |header| header.0 << 11) {\n            Ok(idx) => idx + 1,\n            Err(idx) => idx,\n        };\n    // SAFETY: `last_idx` *cannot* be past the end of the array, as the last\n    // element is greater than `std::char::MAX` (the largest possible needle)\n    // as guaranteed by the caller.\n    //\n    // So, we cannot have found it (i.e. `Ok(idx) => idx + 1 != length`) and the\n    // correct location cannot be past it, so `Err(idx) => idx != length` either.\n    //\n    // This means that we can avoid bounds checking for the accesses below, too.\n    //\n    // We need to use `intrinsics::assume` since the `panic_nounwind` contained\n    // in `hint::assert_unchecked` may not be optimized out.\n    unsafe { crate::intrinsics::assume(last_idx < SOR) };\n\n    let mut offset_idx = short_offset_runs[last_idx].start_index();\n    let length = if let Some(next) = short_offset_runs.get(last_idx + 1) {\n        (*next).start_index() - offset_idx\n    } else {\n        offsets.len() - offset_idx\n    };\n\n    let prev =\n        last_idx.checked_sub(1).map(|prev| short_offset_runs[prev].prefix_sum()).unwrap_or(0);\n\n    let total = needle - prev;\n    let mut prefix_sum = 0;\n    for _ in 0..(length - 1) {\n        // SAFETY: It is guaranteed that `length <= OFFSETS - offset_idx`,\n        // so it follows that `length - 1 + offset_idx < OFFSETS`, therefore\n        // `offset_idx < OFFSETS` is always true in this loop.\n        //\n        // We need to use `intrinsics::assume` since the `panic_nounwind` contained\n        // in `hint::assert_unchecked` may not be optimized out.\n        unsafe { crate::intrinsics::assume(offset_idx < OFFSETS) };\n        let offset = offsets[offset_idx];\n        prefix_sum += offset as u32;\n        if prefix_sum > total {\n            break;\n        }\n        offset_idx += 1;\n    }\n    offset_idx % 2 == 1\n}",
  "callees": [
    "25315992229481465352451865580694346951",
    "131804240691040385559237509421631119204",
    "155146884437592745449279657258619050520",
    "258820287469578611817448591488600041899",
    "6962362284417680556415378392413733050",
    "1804749000070432117611232015630452380581",
    "203046086675419464615602037990874887658",
    "92366369245146006064319085484006805154",
    "17421822894816687532325615181214565887",
    "27480086118489678191003877857780025576",
    "23815256893174302637797703719499456373",
    "1639190511405576016712069487289226138136",
    "58079812985260614779074871743441829358",
    "61537032802646890302053131132263133848",
    "1670765222083267730010075026643490075615",
    "56992650673164436291130925969138191855",
    "14280420189120821201735625103429333129",
    "121087737844564590059481680028118075790",
    "1819947172139969375117075366088933977903",
    "74237070139572734645919793489994849435",
    "1816085489936401008914403015960886614493",
    "1342521228831833354715461413551686205925",
    "987456487869566479017228290597691908039",
    "979090888644938360611991061608854301815",
    "137368381448604167703416046205455599816",
    "156396365605833484958181337486344432065",
    "13303575705867660165971022725037666878",
    "174107661030119018973646362480685393050",
    "1798415469519212016017497888722441021150",
    "148830535650372140516605590768229159260",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "1752989996936949203916036071159051010960",
    "478753423337745817613297159272845606672",
    "3658730781980743391697756456907208995",
    "176386771705132260856587306647620489942",
    "24720139230274117689328858551755358968",
    "1566168013061370513711054548557151263674",
    "6413297363691962391133416434026805125",
    "1068637569658805762318411432081459704427",
    "187482952606822645712460029589708661523",
    "126818845945534382313624863669169238336",
    "1618241054506692736412506772334197899706",
    "106633419293027594483292114003604846516",
    "337252503770367200416843019610480962888",
    "139811699956511703589497305218828960943",
    "12583040371049054649997982659979050806",
    "18924474281332607947427114014473837479",
    "1651595606333011072546864449238920069",
    "77640497972243889203799350935596401319",
    "127750155647389663498845688610259713397",
    "148582739576724500918539485428619977857",
    "43593707891869731298181689567737146647",
    "92265120302182205867901197556085256774",
    "1403577039181256549912198932270946634710",
    "1296250330578048610713328165308641997897",
    "180420336041396971707122376675939284899",
    "875889848590572897611758226549010161226",
    "155041741160856370504591579786851724616",
    "9085913821388381438405004062018594468",
    "154911443990380340341563367924870465980",
    "36990817497430174858508344623774643994",
    "126048648882406442003602795325732745334",
    "74111286315405054421392461884745781298",
    "739520556846959085018120036998133255835",
    "71112245793085408723525187754979718597",
    "1217330957027791981411010835694243116934",
    "921093343429125213217757377270116064946",
    "156172685843180766086305544173360207623",
    "230087818014668626613126011779637203238",
    "996858910052358526713825500087224267602"
  ]
}
