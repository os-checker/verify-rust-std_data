{
  "file": "core/src/iter/adapters/zip.rs",
  "name": "<iter::adapters::zip::Zip<slice::iter::IterMut<'_, u8>, array::iter::IntoIter<u8, 4>> as iter::adapters::zip::ZipImpl<slice::iter::IterMut<'_, u8>, array::iter::IntoIter<u8, 4>>>::new",
  "hash": "88299685648512484518048963155611607444",
  "hash_direct": "104259343503489288032387493775900239908",
  "src": "default fn new(a: A, b: B) -> Self {\n            Zip {\n                a,\n                b,\n                index: 0, // unused\n                len: 0,   // unused\n            }\n        }",
  "macro_backtrace": [
    {
      "callsite": "zip_impl_general_defaults! {}",
      "defsite": "macro_rules! zip_impl_general_defaults {\n    () => {\n        default fn new(a: A, b: B) -> Self {\n            Zip {\n                a,\n                b,\n                index: 0, // unused\n                len: 0,   // unused\n            }\n        }\n\n        #[inline]\n        default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n            let x = self.a.next()?;\n            let y = self.b.next()?;\n            Some((x, y))\n        }\n\n        #[inline]\n        default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n            self.super_nth(n)\n        }\n\n        #[inline]\n        default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n        where\n            A: DoubleEndedIterator + ExactSizeIterator,\n            B: DoubleEndedIterator + ExactSizeIterator,\n        {\n            // The function body below only uses `self.a/b.len()` and `self.a/b.next_back()`\n            // and doesnâ€™t call `next_back` too often, so this implementation is safe in\n            // the `TrustedRandomAccessNoCoerce` specialization\n\n            let a_sz = self.a.len();\n            let b_sz = self.b.len();\n            if a_sz != b_sz {\n                // Adjust a, b to equal length\n                if a_sz > b_sz {\n                    for _ in 0..a_sz - b_sz {\n                        self.a.next_back();\n                    }\n                } else {\n                    for _ in 0..b_sz - a_sz {\n                        self.b.next_back();\n                    }\n                }\n            }\n            match (self.a.next_back(), self.b.next_back()) {\n                (Some(x), Some(y)) => Some((x, y)),\n                (None, None) => None,\n                _ => unreachable!(),\n            }\n        }\n    };\n}"
    }
  ]
}
