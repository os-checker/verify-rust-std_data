{
  "file": "core/src/iter/adapters/step_by.rs",
  "name": "<iter::adapters::step_by::StepBy<ops::range::Range<u32>> as iter::adapters::step_by::StepByImpl<ops::range::Range<u32>>>::spec_nth",
  "hash": "1767389833455439637416799471935039298318",
  "hash_direct": "158858071123293466292154407614937829903",
  "src": "fn spec_nth(&mut self, n: usize) -> Option<Self::Item> {\n                self.advance_by(n).ok()?;\n                self.next()\n            }",
  "macro_backtrace": [
    {
      "callsite": "spec_int_ranges!(u8 u16 u32 u64 usize)",
      "defsite": "macro_rules! spec_int_ranges {\n    ($($t:ty)*) => ($(\n\n        const _: () = assert!(usize::BITS >= <$t>::BITS);\n\n        impl SpecRangeSetup<Range<$t>> for Range<$t> {\n            #[inline]\n            fn setup(mut r: Range<$t>, step: usize) -> Range<$t> {\n                let inner_len = r.size_hint().0;\n                // If step exceeds $t::MAX, then the count will be at most 1 and\n                // thus always fit into $t.\n                let yield_count = inner_len.div_ceil(step);\n                // Turn the range end into an iteration counter\n                r.end = yield_count as $t;\n                r\n            }\n        }\n\n        unsafe impl StepByImpl<Range<$t>> for StepBy<Range<$t>> {\n            #[inline]\n            fn spec_next(&mut self) -> Option<$t> {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                if remaining > 0 {\n                    let val = self.iter.start;\n                    // this can only overflow during the last step, after which the value\n                    // will not be used\n                    self.iter.start = val.wrapping_add(step);\n                    self.iter.end = remaining - 1;\n                    Some(val)\n                } else {\n                    None\n                }\n            }\n\n            #[inline]\n            fn spec_size_hint(&self) -> (usize, Option<usize>) {\n                let remaining = self.iter.end as usize;\n                (remaining, Some(remaining))\n            }\n\n            // The methods below are all copied from the Iterator trait default impls.\n            // We have to repeat them here so that the specialization overrides the StepByImpl defaults\n\n            #[inline]\n            fn spec_nth(&mut self, n: usize) -> Option<Self::Item> {\n                self.advance_by(n).ok()?;\n                self.next()\n            }\n\n            #[inline]\n            fn spec_try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n                where\n                    F: FnMut(Acc, Self::Item) -> R,\n                    R: Try<Output = Acc>\n            {\n                let mut accum = init;\n                while let Some(x) = self.next() {\n                    accum = f(accum, x)?;\n                }\n                try { accum }\n            }\n\n            #[inline]\n            fn spec_fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n                where\n                    F: FnMut(Acc, Self::Item) -> Acc\n            {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                let mut acc = init;\n                let mut val = self.iter.start;\n                for _ in 0..remaining {\n                    acc = f(acc, val);\n                    // this can only overflow during the last step, after which the value\n                    // will no longer be used\n                    val = val.wrapping_add(step);\n                }\n                acc\n            }\n        }\n    )*)\n}"
    }
  ],
  "callees": [
    "972810509204405036809177985934168314",
    "258820287469578611817448591488600041899",
    "17421822894816687532325615181214565887",
    "23815256893174302637797703719499456373",
    "144015449030761749859944505375011935883",
    "137005474622222997471810004705164958120",
    "1710884222055455186315492815337157134574",
    "1295236141797881627111672312966726341638",
    "1094547809659256933816981267295897204376",
    "945507852605821974113350030297154818721",
    "25022952783230614255491452397222850714",
    "176304329850486632493214030242214088865",
    "34410515695185066949979771014252260096",
    "1676806814539779643518083197252466559589",
    "137727233253125029217674386074482569004",
    "8204181366844938535028948998470945185",
    "105012112061793268833585764160433448294",
    "821053300062536159115601448644934990736",
    "68648213460155011086108492708709849999",
    "2922976863402117239063671147549004081",
    "1424839172046310268011085042199237354602",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "478753423337745817613297159272845606672",
    "16554284367650193786337801210329994104",
    "5260399976902825921937688862592907629",
    "12583040371049054649997982659979050806",
    "14202615834488052409859027248238516218",
    "181477136256092199837102360697038808743",
    "162591643440005268710985836057110400607",
    "887235042902537721816254572592014930578",
    "739520556846959085018120036998133255835"
  ]
}
