{
  "file": "core/src/iter/adapters/step_by.rs",
  "name": "<iter::adapters::step_by::StepBy<ops::range::Range<u64>> as iter::adapters::step_by::StepByImpl<ops::range::Range<u64>>>::spec_next",
  "hash": "22882808818818634768917121464050103780",
  "hash_direct": "1395115753943561504416767038547714823476",
  "src": "fn spec_next(&mut self) -> Option<$t> {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                if remaining > 0 {\n                    let val = self.iter.start;\n                    // this can only overflow during the last step, after which the value\n                    // will not be used\n                    self.iter.start = val.wrapping_add(step);\n                    self.iter.end = remaining - 1;\n                    Some(val)\n                } else {\n                    None\n                }\n            }",
  "macro_backtrace": [
    {
      "callsite": "spec_int_ranges!(u8 u16 u32 u64 usize)",
      "defsite": "macro_rules! spec_int_ranges {\n    ($($t:ty)*) => ($(\n\n        const _: () = assert!(usize::BITS >= <$t>::BITS);\n\n        impl SpecRangeSetup<Range<$t>> for Range<$t> {\n            #[inline]\n            fn setup(mut r: Range<$t>, step: usize) -> Range<$t> {\n                let inner_len = r.size_hint().0;\n                // If step exceeds $t::MAX, then the count will be at most 1 and\n                // thus always fit into $t.\n                let yield_count = inner_len.div_ceil(step);\n                // Turn the range end into an iteration counter\n                r.end = yield_count as $t;\n                r\n            }\n        }\n\n        unsafe impl StepByImpl<Range<$t>> for StepBy<Range<$t>> {\n            #[inline]\n            fn spec_next(&mut self) -> Option<$t> {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                if remaining > 0 {\n                    let val = self.iter.start;\n                    // this can only overflow during the last step, after which the value\n                    // will not be used\n                    self.iter.start = val.wrapping_add(step);\n                    self.iter.end = remaining - 1;\n                    Some(val)\n                } else {\n                    None\n                }\n            }\n\n            #[inline]\n            fn spec_size_hint(&self) -> (usize, Option<usize>) {\n                let remaining = self.iter.end as usize;\n                (remaining, Some(remaining))\n            }\n\n            // The methods below are all copied from the Iterator trait default impls.\n            // We have to repeat them here so that the specialization overrides the StepByImpl defaults\n\n            #[inline]\n            fn spec_nth(&mut self, n: usize) -> Option<Self::Item> {\n                self.advance_by(n).ok()?;\n                self.next()\n            }\n\n            #[inline]\n            fn spec_try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n                where\n                    F: FnMut(Acc, Self::Item) -> R,\n                    R: Try<Output = Acc>\n            {\n                let mut accum = init;\n                while let Some(x) = self.next() {\n                    accum = f(accum, x)?;\n                }\n                try { accum }\n            }\n\n            #[inline]\n            fn spec_fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n                where\n                    F: FnMut(Acc, Self::Item) -> Acc\n            {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                let mut acc = init;\n                let mut val = self.iter.start;\n                for _ in 0..remaining {\n                    acc = f(acc, val);\n                    // this can only overflow during the last step, after which the value\n                    // will no longer be used\n                    val = val.wrapping_add(step);\n                }\n                acc\n            }\n        }\n    )*)\n}"
    }
  ],
  "callees": [
    "44104660874855087623733736036848372911",
    "47323665595455568617290020941376774286",
    "1329845230409163288212548289525672875535",
    "16824420916691935049705640393259467449",
    "548564216841344399813623389895135870560",
    "161003650625398914518944455314788757627",
    "375485108047544468212954122974188100514",
    "133406493184733961254247820125865521283",
    "50557607022538309823016666339832368041",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "105125143701458073564296455695110349394",
    "145902098131129374381958978242158647124",
    "4232761083145976883077505220950492834",
    "716247779124104198114743061903126163681",
    "1218790289670026660418434748374709001141",
    "399232661239117480517401994520839366833"
  ]
}
