{
  "file": "core/src/iter/adapters/step_by.rs",
  "name": "<ops::range::Range<u32> as iter::adapters::step_by::SpecRangeSetup<ops::range::Range<u32>>>::setup",
  "hash": "153439348672004327191804533722609318590",
  "hash_direct": "323027819239455820513893649749547807336",
  "src": "fn setup(mut r: Range<$t>, step: usize) -> Range<$t> {\n                let inner_len = r.size_hint().0;\n                // If step exceeds $t::MAX, then the count will be at most 1 and\n                // thus always fit into $t.\n                let yield_count = inner_len.div_ceil(step);\n                // Turn the range end into an iteration counter\n                r.end = yield_count as $t;\n                r\n            }",
  "macro_backtrace": [
    {
      "callsite": "spec_int_ranges!(u8 u16 u32 u64 usize)",
      "defsite": "macro_rules! spec_int_ranges {\n    ($($t:ty)*) => ($(\n\n        const _: () = assert!(usize::BITS >= <$t>::BITS);\n\n        impl SpecRangeSetup<Range<$t>> for Range<$t> {\n            #[inline]\n            fn setup(mut r: Range<$t>, step: usize) -> Range<$t> {\n                let inner_len = r.size_hint().0;\n                // If step exceeds $t::MAX, then the count will be at most 1 and\n                // thus always fit into $t.\n                let yield_count = inner_len.div_ceil(step);\n                // Turn the range end into an iteration counter\n                r.end = yield_count as $t;\n                r\n            }\n        }\n\n        unsafe impl StepByImpl<Range<$t>> for StepBy<Range<$t>> {\n            #[inline]\n            fn spec_next(&mut self) -> Option<$t> {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                if remaining > 0 {\n                    let val = self.iter.start;\n                    // this can only overflow during the last step, after which the value\n                    // will not be used\n                    self.iter.start = val.wrapping_add(step);\n                    self.iter.end = remaining - 1;\n                    Some(val)\n                } else {\n                    None\n                }\n            }\n\n            #[inline]\n            fn spec_size_hint(&self) -> (usize, Option<usize>) {\n                let remaining = self.iter.end as usize;\n                (remaining, Some(remaining))\n            }\n\n            // The methods below are all copied from the Iterator trait default impls.\n            // We have to repeat them here so that the specialization overrides the StepByImpl defaults\n\n            #[inline]\n            fn spec_nth(&mut self, n: usize) -> Option<Self::Item> {\n                self.advance_by(n).ok()?;\n                self.next()\n            }\n\n            #[inline]\n            fn spec_try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n                where\n                    F: FnMut(Acc, Self::Item) -> R,\n                    R: Try<Output = Acc>\n            {\n                let mut accum = init;\n                while let Some(x) = self.next() {\n                    accum = f(accum, x)?;\n                }\n                try { accum }\n            }\n\n            #[inline]\n            fn spec_fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n                where\n                    F: FnMut(Acc, Self::Item) -> Acc\n            {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                let mut acc = init;\n                let mut val = self.iter.start;\n                for _ in 0..remaining {\n                    acc = f(acc, val);\n                    // this can only overflow during the last step, after which the value\n                    // will no longer be used\n                    val = val.wrapping_add(step);\n                }\n                acc\n            }\n        }\n    )*)\n}"
    }
  ],
  "callees": [
    "153871104070145767316778160342330240743",
    "894283018808594391611609287380905026642",
    "1161838479416610794316464294495554281847",
    "1716115695399316423118044476678068147651"
  ]
}
