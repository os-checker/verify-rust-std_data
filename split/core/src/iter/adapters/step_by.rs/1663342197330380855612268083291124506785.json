{
  "file": "core/src/iter/adapters/step_by.rs",
  "name": "<iter::adapters::step_by::StepBy<ops::range::Range<u32>> as iter::adapters::step_by::StepByImpl<ops::range::Range<u32>>>::spec_nth",
  "hash": "1663342197330380855612268083291124506785",
  "hash_direct": "158858071123293466292154407614937829903",
  "src": "fn spec_nth(&mut self, n: usize) -> Option<Self::Item> {\n                self.advance_by(n).ok()?;\n                self.next()\n            }",
  "macro_backtrace": [
    {
      "callsite": "spec_int_ranges!(u8 u16 u32 u64 usize)",
      "defsite": "macro_rules! spec_int_ranges {\n    ($($t:ty)*) => ($(\n\n        const _: () = assert!(usize::BITS >= <$t>::BITS);\n\n        impl SpecRangeSetup<Range<$t>> for Range<$t> {\n            #[inline]\n            fn setup(mut r: Range<$t>, step: usize) -> Range<$t> {\n                let inner_len = r.size_hint().0;\n                // If step exceeds $t::MAX, then the count will be at most 1 and\n                // thus always fit into $t.\n                let yield_count = inner_len.div_ceil(step);\n                // Turn the range end into an iteration counter\n                r.end = yield_count as $t;\n                r\n            }\n        }\n\n        unsafe impl StepByImpl<Range<$t>> for StepBy<Range<$t>> {\n            #[inline]\n            fn spec_next(&mut self) -> Option<$t> {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                if remaining > 0 {\n                    let val = self.iter.start;\n                    // this can only overflow during the last step, after which the value\n                    // will not be used\n                    self.iter.start = val.wrapping_add(step);\n                    self.iter.end = remaining - 1;\n                    Some(val)\n                } else {\n                    None\n                }\n            }\n\n            #[inline]\n            fn spec_size_hint(&self) -> (usize, Option<usize>) {\n                let remaining = self.iter.end as usize;\n                (remaining, Some(remaining))\n            }\n\n            // The methods below are all copied from the Iterator trait default impls.\n            // We have to repeat them here so that the specialization overrides the StepByImpl defaults\n\n            #[inline]\n            fn spec_nth(&mut self, n: usize) -> Option<Self::Item> {\n                self.advance_by(n).ok()?;\n                self.next()\n            }\n\n            #[inline]\n            fn spec_try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n                where\n                    F: FnMut(Acc, Self::Item) -> R,\n                    R: Try<Output = Acc>\n            {\n                let mut accum = init;\n                while let Some(x) = self.next() {\n                    accum = f(accum, x)?;\n                }\n                try { accum }\n            }\n\n            #[inline]\n            fn spec_fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n                where\n                    F: FnMut(Acc, Self::Item) -> Acc\n            {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                let mut acc = init;\n                let mut val = self.iter.start;\n                for _ in 0..remaining {\n                    acc = f(acc, val);\n                    // this can only overflow during the last step, after which the value\n                    // will no longer be used\n                    val = val.wrapping_add(step);\n                }\n                acc\n            }\n        }\n    )*)\n}"
    }
  ],
  "callees": [
    "740279432569025443711574644820610176575",
    "47323665595455568617290020941376774286",
    "1329845230409163288212548289525672875535",
    "16824420916691935049705640393259467449",
    "1341380100751663483713673402061083971105",
    "29272695305557412791251994549078058730",
    "348429380086394933110305361134056650577",
    "554397387387847496715114804290992599110",
    "1157575099177598361814044055512526465166",
    "1565365367594885723315960381484691944628",
    "1112064329677692685812262099924363355374",
    "436617572081828855814432374202267148264",
    "161003650625398914518944455314788757627",
    "375485108047544468212954122974188100514",
    "133406493184733961254247820125865521283",
    "811014240907765449310255915500040932880",
    "334793147703861981612991769714708218538",
    "39733537437022171613682062970386769295",
    "116482898840396402477616122367703643717",
    "126012008154782159615214827713093461635",
    "176742512093848468045239021356424772729",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "105125143701458073564296455695110349394",
    "379994518897277131216528315043767400790",
    "151554565565455461655790498251939908013",
    "178908583266819311171056730682051642189",
    "1575180643816959680013764123585909653935",
    "492519479826950394018276053244340769623",
    "29961454789570629418807946327322770135",
    "1218790289670026660418434748374709001141",
    "399232661239117480517401994520839366833"
  ]
}
