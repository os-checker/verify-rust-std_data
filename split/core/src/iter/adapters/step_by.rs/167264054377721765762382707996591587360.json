{
  "file": "core/src/iter/adapters/step_by.rs",
  "name": "<iter::adapters::step_by::StepBy<ops::range::Range<u32>> as iter::adapters::step_by::StepByImpl<ops::range::Range<u32>>>::spec_next",
  "hash": "167264054377721765762382707996591587360",
  "hash_direct": "1448596208995316012212190215497237313640",
  "src": "fn spec_next(&mut self) -> Option<$t> {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                if remaining > 0 {\n                    let val = self.iter.start;\n                    // this can only overflow during the last step, after which the value\n                    // will not be used\n                    self.iter.start = val.wrapping_add(step);\n                    self.iter.end = remaining - 1;\n                    Some(val)\n                } else {\n                    None\n                }\n            }",
  "macro_backtrace": [
    {
      "callsite": "spec_int_ranges!(u8 u16 u32 u64 usize)",
      "defsite": "macro_rules! spec_int_ranges {\n    ($($t:ty)*) => ($(\n\n        const _: () = assert!(usize::BITS >= <$t>::BITS);\n\n        impl SpecRangeSetup<Range<$t>> for Range<$t> {\n            #[inline]\n            fn setup(mut r: Range<$t>, step: usize) -> Range<$t> {\n                let inner_len = r.size_hint().0;\n                // If step exceeds $t::MAX, then the count will be at most 1 and\n                // thus always fit into $t.\n                let yield_count = inner_len.div_ceil(step);\n                // Turn the range end into an iteration counter\n                r.end = yield_count as $t;\n                r\n            }\n        }\n\n        unsafe impl StepByImpl<Range<$t>> for StepBy<Range<$t>> {\n            #[inline]\n            fn spec_next(&mut self) -> Option<$t> {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                if remaining > 0 {\n                    let val = self.iter.start;\n                    // this can only overflow during the last step, after which the value\n                    // will not be used\n                    self.iter.start = val.wrapping_add(step);\n                    self.iter.end = remaining - 1;\n                    Some(val)\n                } else {\n                    None\n                }\n            }\n\n            #[inline]\n            fn spec_size_hint(&self) -> (usize, Option<usize>) {\n                let remaining = self.iter.end as usize;\n                (remaining, Some(remaining))\n            }\n\n            // The methods below are all copied from the Iterator trait default impls.\n            // We have to repeat them here so that the specialization overrides the StepByImpl defaults\n\n            #[inline]\n            fn spec_nth(&mut self, n: usize) -> Option<Self::Item> {\n                self.advance_by(n).ok()?;\n                self.next()\n            }\n\n            #[inline]\n            fn spec_try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n                where\n                    F: FnMut(Acc, Self::Item) -> R,\n                    R: Try<Output = Acc>\n            {\n                let mut accum = init;\n                while let Some(x) = self.next() {\n                    accum = f(accum, x)?;\n                }\n                try { accum }\n            }\n\n            #[inline]\n            fn spec_fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n                where\n                    F: FnMut(Acc, Self::Item) -> Acc\n            {\n                // if a step size larger than the type has been specified fall back to\n                // t::MAX, in which case remaining will be at most 1.\n                let step = <$t>::try_from(self.original_step().get()).unwrap_or(<$t>::MAX);\n                let remaining = self.iter.end;\n                let mut acc = init;\n                let mut val = self.iter.start;\n                for _ in 0..remaining {\n                    acc = f(acc, val);\n                    // this can only overflow during the last step, after which the value\n                    // will no longer be used\n                    val = val.wrapping_add(step);\n                }\n                acc\n            }\n        }\n    )*)\n}"
    }
  ],
  "callees": [
    "1829296751424163616111065659097144121709",
    "258820287469578611817448591488600041899",
    "17421822894816687532325615181214565887",
    "23815256893174302637797703719499456373",
    "1094547809659256933816981267295897204376",
    "34410515695185066949979771014252260096",
    "1676806814539779643518083197252466559589",
    "137727233253125029217674386074482569004",
    "46095478919112651485037565198280203652",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "478753423337745817613297159272845606672",
    "5260399976902825921937688862592907629",
    "12583040371049054649997982659979050806",
    "162591643440005268710985836057110400607",
    "887235042902537721816254572592014930578",
    "739520556846959085018120036998133255835"
  ]
}
