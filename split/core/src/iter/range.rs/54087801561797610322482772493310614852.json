{
  "file": "core/src/iter/range.rs",
  "name": "<i128 as iter::range::Step>::forward_unchecked",
  "hash": "54087801561797610322482772493310614852",
  "hash_direct": "9511105280196344396504665920288166102",
  "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }\n        }",
  "macro_backtrace": [
    {
      "callsite": "step_signed_methods!($u_wider)",
      "defsite": "macro_rules! step_signed_methods {\n    ($unsigned: ty) => {\n        #[requires(start.checked_add_unsigned(n as $unsigned).is_some())]\n        #[inline]\n        unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }\n        }\n\n        #[requires(start.checked_sub_unsigned(n as $unsigned).is_some())]\n        #[inline]\n        unsafe fn backward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.\n            unsafe { start.checked_sub_unsigned(n as $unsigned).unwrap_unchecked() }\n        }\n    };\n}"
    },
    {
      "callsite": "step_integer_impls! {\n    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [u64 i64], [usize isize];\n    wider than usize: [u128 i128];\n}",
      "defsite": "macro_rules! step_integer_impls {\n    {\n        narrower than or same width as usize:\n            $( [ $u_narrower:ident $i_narrower:ident ] ),+;\n        wider than usize:\n            $( [ $u_wider:ident $i_wider:ident ] ),+;\n    } => {\n        $(\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $u_narrower {\n                step_identical_methods!();\n                step_unsigned_methods!();\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        // This relies on $u_narrower <= usize\n                        let steps = (*end - *start) as usize;\n                        (steps, Some(steps))\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    match Self::try_from(n) {\n                        Ok(n) => start.checked_add(n),\n                        Err(_) => None, // if n is out of range, `unsigned_start + n` is too\n                    }\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    match Self::try_from(n) {\n                        Ok(n) => start.checked_sub(n),\n                        Err(_) => None, // if n is out of range, `unsigned_start - n` is too\n                    }\n                }\n            }\n\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $i_narrower {\n                step_identical_methods!();\n                step_signed_methods!($u_narrower);\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        // This relies on $i_narrower <= usize\n                        //\n                        // Casting to isize extends the width but preserves the sign.\n                        // Use wrapping_sub in isize space and cast to usize to compute\n                        // the difference that might not fit inside the range of isize.\n                        let steps = (*end as isize).wrapping_sub(*start as isize) as usize;\n                        (steps, Some(steps))\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    match $u_narrower::try_from(n) {\n                        Ok(n) => {\n                            // Wrapping handles cases like\n                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n                            // even though 200 is out of range for i8.\n                            let wrapped = start.wrapping_add(n as Self);\n                            if wrapped >= start {\n                                Some(wrapped)\n                            } else {\n                                None // Addition overflowed\n                            }\n                        }\n                        // If n is out of range of e.g. u8,\n                        // then it is bigger than the entire range for i8 is wide\n                        // so `any_i8 + n` necessarily overflows i8.\n                        Err(_) => None,\n                    }\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    match $u_narrower::try_from(n) {\n                        Ok(n) => {\n                            // Wrapping handles cases like\n                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n                            // even though 200 is out of range for i8.\n                            let wrapped = start.wrapping_sub(n as Self);\n                            if wrapped <= start {\n                                Some(wrapped)\n                            } else {\n                                None // Subtraction overflowed\n                            }\n                        }\n                        // If n is out of range of e.g. u8,\n                        // then it is bigger than the entire range for i8 is wide\n                        // so `any_i8 - n` necessarily overflows i8.\n                        Err(_) => None,\n                    }\n                }\n            }\n        )+\n\n        $(\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $u_wider {\n                step_identical_methods!();\n                step_unsigned_methods!();\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        if let Ok(steps) = usize::try_from(*end - *start) {\n                            (steps, Some(steps))\n                        } else {\n                            (usize::MAX, None)\n                        }\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_add(n as Self)\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }\n            }\n\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $i_wider {\n                step_identical_methods!();\n                step_signed_methods!($u_wider);\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        match end.checked_sub(*start) {\n                            Some(result) => {\n                                if let Ok(steps) = usize::try_from(result) {\n                                    (steps, Some(steps))\n                                } else {\n                                    (usize::MAX, None)\n                                }\n                            }\n                            // If the difference is too big for e.g. i128,\n                            // it's also gonna be too big for usize with fewer bits.\n                            None => (usize::MAX, None),\n                        }\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_add(n as Self)\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }\n            }\n        )+\n    };\n}"
    }
  ],
  "callees": [
    "47323665595455568617290020941376774286",
    "25768524018977866517055903022448790318",
    "111425599901702694743874629435682172347",
    "714811817540972740211524868124730226803",
    "1329845230409163288212548289525672875535",
    "16824420916691935049705640393259467449",
    "11450866583979562645316440392240766248",
    "47324341073704015417109869266419715557",
    "52199826652157626576980555378632930297",
    "65448937633116892263511956471265313920",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "105125143701458073564296455695110349394",
    "550150895960312460312176584159342455723",
    "399232661239117480517401994520839366833"
  ]
}
