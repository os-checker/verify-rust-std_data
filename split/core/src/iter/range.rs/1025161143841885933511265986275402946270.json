{
  "file": "core/src/iter/range.rs",
  "name": "<ops::range::Range<u8> as iter::range::RangeIteratorImpl>::spec_advance_by",
  "hash": "1025161143841885933511265986275402946270",
  "hash_direct": "388613748637185530217431805301549068287",
  "src": "fn spec_advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        let steps = Step::steps_between(&self.start, &self.end);\n        let available = steps.1.unwrap_or(steps.0);\n\n        let taken = available.min(n);\n\n        // SAFETY: the conditions above ensure that the count is in bounds. If start <= end\n        // then steps_between either returns a bound to which we clamp or returns None which\n        // together with the initial inequality implies more than usize::MAX steps.\n        // Otherwise 0 is returned which always safe to use.\n        self.start = unsafe { Step::forward_unchecked(self.start, taken) };\n\n        NonZero::new(n - taken).map_or(Ok(()), Err)\n    }",
  "callees": [
    "7482589000750884340327816351015335759",
    "155146884437592745449279657258619050520",
    "258820287469578611817448591488600041899",
    "17421822894816687532325615181214565887",
    "23815256893174302637797703719499456373",
    "66558832420252384767352894655095642857",
    "1358246712086198366614107958808171399286",
    "1676806814539779643518083197252466559589",
    "26195867178919098137740125012797303465",
    "18305200539080999937692536706112892813",
    "173406377095566863748465400786477540721",
    "680034622814316217712937714106633543020",
    "1072447301577107643817352323900751606380",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "478753423337745817613297159272845606672",
    "40545036438152791145615465344483147281",
    "16554284367650193786337801210329994104",
    "18924474281332607947427114014473837479",
    "1301995755790878605811491736323759974386",
    "1655209669618753209114659502170458211993",
    "739520556846959085018120036998133255835"
  ]
}
