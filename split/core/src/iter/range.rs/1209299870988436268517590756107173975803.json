{
  "file": "core/src/iter/range.rs",
  "name": "<i128 as iter::range::Step>::backward_checked",
  "hash": "1209299870988436268517590756107173975803",
  "hash_direct": "156413357059783639222175942080252374156",
  "src": "fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }",
  "macro_backtrace": [
    {
      "callsite": "step_integer_impls! {\n    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [u64 i64], [usize isize];\n    wider than usize: [u128 i128];\n}",
      "defsite": "macro_rules! step_integer_impls {\n    {\n        narrower than or same width as usize:\n            $( [ $u_narrower:ident $i_narrower:ident ] ),+;\n        wider than usize:\n            $( [ $u_wider:ident $i_wider:ident ] ),+;\n    } => {\n        $(\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $u_narrower {\n                step_identical_methods!();\n                step_unsigned_methods!();\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        // This relies on $u_narrower <= usize\n                        let steps = (*end - *start) as usize;\n                        (steps, Some(steps))\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    match Self::try_from(n) {\n                        Ok(n) => start.checked_add(n),\n                        Err(_) => None, // if n is out of range, `unsigned_start + n` is too\n                    }\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    match Self::try_from(n) {\n                        Ok(n) => start.checked_sub(n),\n                        Err(_) => None, // if n is out of range, `unsigned_start - n` is too\n                    }\n                }\n            }\n\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $i_narrower {\n                step_identical_methods!();\n                step_signed_methods!($u_narrower);\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        // This relies on $i_narrower <= usize\n                        //\n                        // Casting to isize extends the width but preserves the sign.\n                        // Use wrapping_sub in isize space and cast to usize to compute\n                        // the difference that might not fit inside the range of isize.\n                        let steps = (*end as isize).wrapping_sub(*start as isize) as usize;\n                        (steps, Some(steps))\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    match $u_narrower::try_from(n) {\n                        Ok(n) => {\n                            // Wrapping handles cases like\n                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n                            // even though 200 is out of range for i8.\n                            let wrapped = start.wrapping_add(n as Self);\n                            if wrapped >= start {\n                                Some(wrapped)\n                            } else {\n                                None // Addition overflowed\n                            }\n                        }\n                        // If n is out of range of e.g. u8,\n                        // then it is bigger than the entire range for i8 is wide\n                        // so `any_i8 + n` necessarily overflows i8.\n                        Err(_) => None,\n                    }\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    match $u_narrower::try_from(n) {\n                        Ok(n) => {\n                            // Wrapping handles cases like\n                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n                            // even though 200 is out of range for i8.\n                            let wrapped = start.wrapping_sub(n as Self);\n                            if wrapped <= start {\n                                Some(wrapped)\n                            } else {\n                                None // Subtraction overflowed\n                            }\n                        }\n                        // If n is out of range of e.g. u8,\n                        // then it is bigger than the entire range for i8 is wide\n                        // so `any_i8 - n` necessarily overflows i8.\n                        Err(_) => None,\n                    }\n                }\n            }\n        )+\n\n        $(\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $u_wider {\n                step_identical_methods!();\n                step_unsigned_methods!();\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        if let Ok(steps) = usize::try_from(*end - *start) {\n                            (steps, Some(steps))\n                        } else {\n                            (usize::MAX, None)\n                        }\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_add(n as Self)\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }\n            }\n\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $i_wider {\n                step_identical_methods!();\n                step_signed_methods!($u_wider);\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        match end.checked_sub(*start) {\n                            Some(result) => {\n                                if let Ok(steps) = usize::try_from(result) {\n                                    (steps, Some(steps))\n                                } else {\n                                    (usize::MAX, None)\n                                }\n                            }\n                            // If the difference is too big for e.g. i128,\n                            // it's also gonna be too big for usize with fewer bits.\n                            None => (usize::MAX, None),\n                        }\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_add(n as Self)\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }\n            }\n        )+\n    };\n}"
    }
  ],
  "callees": [
    "588974892899239543415856878986124229421",
    "690438059002452523915046149102377829082",
    "734917329505459768611992150788570820360",
    "99573204806805497962082422441702041656"
  ]
}
