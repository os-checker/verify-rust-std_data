{
  "file": "core/src/iter/range.rs",
  "name": "<isize as iter::range::Step>::forward_unchecked",
  "hash": "703292125058064800113741874364144024758",
  "hash_direct": "55716473677134293679435989250946356749",
  "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }\n        }",
  "macro_backtrace": [
    {
      "callsite": "step_signed_methods!($u_narrower)",
      "defsite": "macro_rules! step_signed_methods {\n    ($unsigned: ty) => {\n        #[requires(start.checked_add_unsigned(n as $unsigned).is_some())]\n        #[inline]\n        unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }\n        }\n\n        #[requires(start.checked_sub_unsigned(n as $unsigned).is_some())]\n        #[inline]\n        unsafe fn backward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.\n            unsafe { start.checked_sub_unsigned(n as $unsigned).unwrap_unchecked() }\n        }\n    };\n}"
    },
    {
      "callsite": "step_integer_impls! {\n    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [u64 i64], [usize isize];\n    wider than usize: [u128 i128];\n}",
      "defsite": "macro_rules! step_integer_impls {\n    {\n        narrower than or same width as usize:\n            $( [ $u_narrower:ident $i_narrower:ident ] ),+;\n        wider than usize:\n            $( [ $u_wider:ident $i_wider:ident ] ),+;\n    } => {\n        $(\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $u_narrower {\n                step_identical_methods!();\n                step_unsigned_methods!();\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        // This relies on $u_narrower <= usize\n                        let steps = (*end - *start) as usize;\n                        (steps, Some(steps))\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    match Self::try_from(n) {\n                        Ok(n) => start.checked_add(n),\n                        Err(_) => None, // if n is out of range, `unsigned_start + n` is too\n                    }\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    match Self::try_from(n) {\n                        Ok(n) => start.checked_sub(n),\n                        Err(_) => None, // if n is out of range, `unsigned_start - n` is too\n                    }\n                }\n            }\n\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $i_narrower {\n                step_identical_methods!();\n                step_signed_methods!($u_narrower);\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        // This relies on $i_narrower <= usize\n                        //\n                        // Casting to isize extends the width but preserves the sign.\n                        // Use wrapping_sub in isize space and cast to usize to compute\n                        // the difference that might not fit inside the range of isize.\n                        let steps = (*end as isize).wrapping_sub(*start as isize) as usize;\n                        (steps, Some(steps))\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    match $u_narrower::try_from(n) {\n                        Ok(n) => {\n                            // Wrapping handles cases like\n                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n                            // even though 200 is out of range for i8.\n                            let wrapped = start.wrapping_add(n as Self);\n                            if wrapped >= start {\n                                Some(wrapped)\n                            } else {\n                                None // Addition overflowed\n                            }\n                        }\n                        // If n is out of range of e.g. u8,\n                        // then it is bigger than the entire range for i8 is wide\n                        // so `any_i8 + n` necessarily overflows i8.\n                        Err(_) => None,\n                    }\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    match $u_narrower::try_from(n) {\n                        Ok(n) => {\n                            // Wrapping handles cases like\n                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n                            // even though 200 is out of range for i8.\n                            let wrapped = start.wrapping_sub(n as Self);\n                            if wrapped <= start {\n                                Some(wrapped)\n                            } else {\n                                None // Subtraction overflowed\n                            }\n                        }\n                        // If n is out of range of e.g. u8,\n                        // then it is bigger than the entire range for i8 is wide\n                        // so `any_i8 - n` necessarily overflows i8.\n                        Err(_) => None,\n                    }\n                }\n            }\n        )+\n\n        $(\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $u_wider {\n                step_identical_methods!();\n                step_unsigned_methods!();\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        if let Ok(steps) = usize::try_from(*end - *start) {\n                            (steps, Some(steps))\n                        } else {\n                            (usize::MAX, None)\n                        }\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_add(n as Self)\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }\n            }\n\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $i_wider {\n                step_identical_methods!();\n                step_signed_methods!($u_wider);\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        match end.checked_sub(*start) {\n                            Some(result) => {\n                                if let Ok(steps) = usize::try_from(result) {\n                                    (steps, Some(steps))\n                                } else {\n                                    (usize::MAX, None)\n                                }\n                            }\n                            // If the difference is too big for e.g. i128,\n                            // it's also gonna be too big for usize with fewer bits.\n                            None => (usize::MAX, None),\n                        }\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_add(n as Self)\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }\n            }\n        )+\n    };\n}"
    }
  ],
  "callees": [
    "258820287469578611817448591488600041899",
    "1415106497522421883676194742336801697",
    "588974892899239543415856878986124229421",
    "690438059002452523915046149102377829082",
    "17421822894816687532325615181214565887",
    "23815256893174302637797703719499456373",
    "166999201557032273571608872796817301099",
    "3323535904070767275982574960807271335",
    "1019827591666192629312139562894365278499",
    "174796509301998562348515022383158913635",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "478753423337745817613297159272845606672",
    "819756211280848030917202637728825520633",
    "739520556846959085018120036998133255835"
  ]
}
