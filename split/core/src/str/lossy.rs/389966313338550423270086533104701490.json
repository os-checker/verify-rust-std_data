{
  "file": "core/src/str/lossy.rs",
  "name": "<str::lossy::Utf8Chunks<'_> as iter::traits::iterator::Iterator>::next",
  "hash": "389966313338550423270086533104701490",
  "hash_direct": "7007980030633734129075346796486247232",
  "src": "fn next(&mut self) -> Option<Utf8Chunk<'a>> {\n        if self.source.is_empty() {\n            return None;\n        }\n\n        const TAG_CONT_U8: u8 = 128;\n        fn safe_get(xs: &[u8], i: usize) -> u8 {\n            *xs.get(i).unwrap_or(&0)\n        }\n\n        let mut i = 0;\n        let mut valid_up_to = 0;\n        // TODO: remove `LEN` and use `self.source.len()` directly once\n        // fix the issue that Kani loop contracts doesn't support `self`.\n        // Tracked in https://github.com/model-checking/kani/issues/3700\n        #[cfg(kani)]\n        let LEN = self.source.len();\n        #[safety::loop_invariant(i <= LEN && valid_up_to == i)]\n        while i < self.source.len() {\n            // SAFETY: `i < self.source.len()` per previous line.\n            // For some reason the following are both significantly slower:\n            // while let Some(&byte) = self.source.get(i) {\n            // while let Some(byte) = self.source.get(i).copied() {\n            let byte = unsafe { *self.source.get_unchecked(i) };\n            i += 1;\n\n            if byte < 128 {\n                // This could be a `1 => ...` case in the match below, but for\n                // the common case of all-ASCII inputs, we bypass loading the\n                // sizeable UTF8_CHAR_WIDTH table into cache.\n            } else {\n                let w = utf8_char_width(byte);\n\n                match w {\n                    2 => {\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    3 => {\n                        match (byte, safe_get(self.source, i)) {\n                            (0xE0, 0xA0..=0xBF) => (),\n                            (0xE1..=0xEC, 0x80..=0xBF) => (),\n                            (0xED, 0x80..=0x9F) => (),\n                            (0xEE..=0xEF, 0x80..=0xBF) => (),\n                            _ => break,\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    4 => {\n                        match (byte, safe_get(self.source, i)) {\n                            (0xF0, 0x90..=0xBF) => (),\n                            (0xF1..=0xF3, 0x80..=0xBF) => (),\n                            (0xF4, 0x80..=0x8F) => (),\n                            _ => break,\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    _ => break,\n                }\n            }\n\n            valid_up_to = i;\n        }\n\n        // SAFETY: `i <= self.source.len()` because it is only ever incremented\n        // via `i += 1` and in between every single one of those increments, `i`\n        // is compared against `self.source.len()`. That happens either\n        // literally by `i < self.source.len()` in the while-loop's condition,\n        // or indirectly by `safe_get(self.source, i) & 192 != TAG_CONT_U8`. The\n        // loop is terminated as soon as the latest `i += 1` has made `i` no\n        // longer less than `self.source.len()`, which means it'll be at most\n        // equal to `self.source.len()`.\n        let (inspected, remaining) = unsafe { self.source.split_at_unchecked(i) };\n        self.source = remaining;\n\n        // SAFETY: `valid_up_to <= i` because it is only ever assigned via\n        // `valid_up_to = i` and `i` only increases.\n        let (valid, invalid) = unsafe { inspected.split_at_unchecked(valid_up_to) };\n\n        Some(Utf8Chunk {\n            // SAFETY: All bytes up to `valid_up_to` are valid UTF-8.\n            valid: unsafe { from_utf8_unchecked(valid) },\n            invalid,\n        })\n    }",
  "callees": [
    "258820287469578611817448591488600041899",
    "588974892899239543415856878986124229421",
    "690438059002452523915046149102377829082",
    "17421822894816687532325615181214565887",
    "313288670142853245916792507642081759284",
    "27480086118489678191003877857780025576",
    "23815256893174302637797703719499456373",
    "1639190511405576016712069487289226138136",
    "38217196742947992835679479997123307043",
    "121097281700569241807917519510076722724",
    "143572956432032064744447501745832117320",
    "137368381448604167703416046205455599816",
    "156396365605833484958181337486344432065",
    "13303575705867660165971022725037666878",
    "761861023504359043615820998596748928032",
    "289952450504960996216944639547677354393",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "1752989996936949203916036071159051010960",
    "478753423337745817613297159272845606672",
    "3658730781980743391697756456907208995",
    "176386771705132260856587306647620489942",
    "24720139230274117689328858551755358968",
    "1566168013061370513711054548557151263674",
    "375960559020688079617955032586718986019",
    "157452307909752828034879955455996353017",
    "153492746833767641913665382585991399102",
    "187482952606822645712460029589708661523",
    "126818845945534382313624863669169238336",
    "94456838198084845861692920132229050794",
    "100566549119408744214400768677206684395",
    "156761099224162496521554063647246510953",
    "696031761158559988717156830525069362848",
    "760499024176919446914647389213438349877",
    "138902882366249903201239198490399945031",
    "47822370175813177448723454097252028703",
    "18415684320297405220951080584907961160",
    "136304994639276996811277527976407166479",
    "497499364745128359314402117207900903418",
    "411805792864265543417403918021470104007",
    "119668517586734080878390935967434516036",
    "1153959874226978119913857890632071810994",
    "16379897238159064530579724829874940611",
    "96426103444183050012757094728170995506",
    "154911443990380340341563367924870465980",
    "1006928117247909106515604664996585110540",
    "56448737519681294968960799914289695112",
    "51920321377442756437204742573348251158",
    "739520556846959085018120036998133255835",
    "154579918799348646172273891119983850679",
    "71112245793085408723525187754979718597",
    "1217330957027791981411010835694243116934"
  ]
}
