{
  "file": "core/src/str/lossy.rs",
  "name": "<core::str::Utf8Chunks<'_> as core::iter::Iterator>::next",
  "hash": "1449181416247553102712624303191517386390",
  "hash_direct": "793035996819955487815400724309049138408",
  "src": "fn next(&mut self) -> Option<Utf8Chunk<'a>> {\n        if self.source.is_empty() {\n            return None;\n        }\n\n        const TAG_CONT_U8: u8 = 128;\n        fn safe_get(xs: &[u8], i: usize) -> u8 {\n            *xs.get(i).unwrap_or(&0)\n        }\n\n        let mut i = 0;\n        let mut valid_up_to = 0;\n        // TODO: remove `LEN` and use `self.source.len()` directly once\n        // fix the issue that Kani loop contracts doesn't support `self`.\n        // Tracked in https://github.com/model-checking/kani/issues/3700\n        #[cfg(kani)]\n        let LEN = self.source.len();\n        #[safety::loop_invariant(i <= LEN && valid_up_to == i)]\n        while i < self.source.len() {\n            // SAFETY: `i < self.source.len()` per previous line.\n            // For some reason the following are both significantly slower:\n            // while let Some(&byte) = self.source.get(i) {\n            // while let Some(byte) = self.source.get(i).copied() {\n            let byte = unsafe { *self.source.get_unchecked(i) };\n            i += 1;\n\n            if byte < 128 {\n                // This could be a `1 => ...` case in the match below, but for\n                // the common case of all-ASCII inputs, we bypass loading the\n                // sizeable UTF8_CHAR_WIDTH table into cache.\n            } else {\n                let w = utf8_char_width(byte);\n\n                match w {\n                    2 => {\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    3 => {\n                        match (byte, safe_get(self.source, i)) {\n                            (0xE0, 0xA0..=0xBF) => (),\n                            (0xE1..=0xEC, 0x80..=0xBF) => (),\n                            (0xED, 0x80..=0x9F) => (),\n                            (0xEE..=0xEF, 0x80..=0xBF) => (),\n                            _ => break,\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    4 => {\n                        match (byte, safe_get(self.source, i)) {\n                            (0xF0, 0x90..=0xBF) => (),\n                            (0xF1..=0xF3, 0x80..=0xBF) => (),\n                            (0xF4, 0x80..=0x8F) => (),\n                            _ => break,\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    _ => break,\n                }\n            }\n\n            valid_up_to = i;\n        }\n\n        // SAFETY: `i <= self.source.len()` because it is only ever incremented\n        // via `i += 1` and in between every single one of those increments, `i`\n        // is compared against `self.source.len()`. That happens either\n        // literally by `i < self.source.len()` in the while-loop's condition,\n        // or indirectly by `safe_get(self.source, i) & 192 != TAG_CONT_U8`. The\n        // loop is terminated as soon as the latest `i += 1` has made `i` no\n        // longer less than `self.source.len()`, which means it'll be at most\n        // equal to `self.source.len()`.\n        let (inspected, remaining) = unsafe { self.source.split_at_unchecked(i) };\n        self.source = remaining;\n\n        // SAFETY: `valid_up_to <= i` because it is only ever assigned via\n        // `valid_up_to = i` and `i` only increases.\n        let (valid, invalid) = unsafe { inspected.split_at_unchecked(valid_up_to) };\n\n        Some(Utf8Chunk {\n            // SAFETY: All bytes up to `valid_up_to` are valid UTF-8.\n            valid: unsafe { from_utf8_unchecked(valid) },\n            invalid,\n        })\n    }",
  "callees": [
    "12281449246394340237926324936375242532",
    "99835071136844477394667148890151411684",
    "73694171442177138896992135977130617471",
    "181267529910573756716102767087485333561",
    "1362727304153836450215186853291845605124",
    "79817071675776388295206212610749591701",
    "1824545319189397521315695847785602896178",
    "1022803319099694746713266409355997953681",
    "97566299569839892074656028861613377837",
    "1055043272310861592713228670863657256034",
    "17976542625295060605041426324269334020",
    "897265533945643607115272871669854221703",
    "89502211078669479795623704974378882516",
    "170846580729842163074659927269266210653",
    "8010637041282557608011263416999007001",
    "134631170439086973183180791068542171141",
    "986792852990965178117440249555081278778",
    "90818112465881722349174357944217011292",
    "146612017564224181584303574960223420416",
    "63085389524472853348886374617170044294",
    "175623961004431005849298709567805707658",
    "33067340742295788584221598515845050786",
    "20743252454400330067347997888777335224",
    "181953690662554297912505335505865467275",
    "927601772743169303216908637897944691801",
    "1227509350711597297112970073629001043324",
    "1574198065840570931715496922327374750806",
    "1793681111599931821712213635413918902143",
    "55408212128999564608147158566316072753",
    "121866230926415018332270093276707107239",
    "752644167293716817117721550981127924220",
    "1161957769894127133012856511664916235439",
    "1427536526616347568511859223439081842037",
    "1576059258124862397814684958146640809205",
    "95673971321914076156357069251308634762",
    "47672539441842164771342608976601968881",
    "138864908789298630857141888322162684323",
    "160100725931238445388616843081371260373",
    "9611486168658861280835191277977503500",
    "26513880466180391136266502522707955176",
    "471059197914006352117967940518452112349",
    "683320997578289266616454728852356232270",
    "33146524702985470014185464408370497287",
    "4951833658330039795044234471525440054",
    "42640861811413251621458178080920148489",
    "356896403557560017460350669106551612",
    "116003191352895236935716644142521429105",
    "916552609649539653110630350571106092626",
    "112989397975222255532054380452996322405",
    "734748700356449319315300238482033757944",
    "597683522621928614711119364722938279780",
    "17341452779707394601695269753709495351"
  ]
}
