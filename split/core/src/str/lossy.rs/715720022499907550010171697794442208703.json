{
  "file": "core/src/str/lossy.rs",
  "name": "<str::lossy::Utf8Chunks<'_> as iter::traits::iterator::Iterator>::next",
  "hash": "715720022499907550010171697794442208703",
  "hash_direct": "7007980030633734129075346796486247232",
  "src": "fn next(&mut self) -> Option<Utf8Chunk<'a>> {\n        if self.source.is_empty() {\n            return None;\n        }\n\n        const TAG_CONT_U8: u8 = 128;\n        fn safe_get(xs: &[u8], i: usize) -> u8 {\n            *xs.get(i).unwrap_or(&0)\n        }\n\n        let mut i = 0;\n        let mut valid_up_to = 0;\n        // TODO: remove `LEN` and use `self.source.len()` directly once\n        // fix the issue that Kani loop contracts doesn't support `self`.\n        // Tracked in https://github.com/model-checking/kani/issues/3700\n        #[cfg(kani)]\n        let LEN = self.source.len();\n        #[safety::loop_invariant(i <= LEN && valid_up_to == i)]\n        while i < self.source.len() {\n            // SAFETY: `i < self.source.len()` per previous line.\n            // For some reason the following are both significantly slower:\n            // while let Some(&byte) = self.source.get(i) {\n            // while let Some(byte) = self.source.get(i).copied() {\n            let byte = unsafe { *self.source.get_unchecked(i) };\n            i += 1;\n\n            if byte < 128 {\n                // This could be a `1 => ...` case in the match below, but for\n                // the common case of all-ASCII inputs, we bypass loading the\n                // sizeable UTF8_CHAR_WIDTH table into cache.\n            } else {\n                let w = utf8_char_width(byte);\n\n                match w {\n                    2 => {\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    3 => {\n                        match (byte, safe_get(self.source, i)) {\n                            (0xE0, 0xA0..=0xBF) => (),\n                            (0xE1..=0xEC, 0x80..=0xBF) => (),\n                            (0xED, 0x80..=0x9F) => (),\n                            (0xEE..=0xEF, 0x80..=0xBF) => (),\n                            _ => break,\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    4 => {\n                        match (byte, safe_get(self.source, i)) {\n                            (0xF0, 0x90..=0xBF) => (),\n                            (0xF1..=0xF3, 0x80..=0xBF) => (),\n                            (0xF4, 0x80..=0x8F) => (),\n                            _ => break,\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    _ => break,\n                }\n            }\n\n            valid_up_to = i;\n        }\n\n        // SAFETY: `i <= self.source.len()` because it is only ever incremented\n        // via `i += 1` and in between every single one of those increments, `i`\n        // is compared against `self.source.len()`. That happens either\n        // literally by `i < self.source.len()` in the while-loop's condition,\n        // or indirectly by `safe_get(self.source, i) & 192 != TAG_CONT_U8`. The\n        // loop is terminated as soon as the latest `i += 1` has made `i` no\n        // longer less than `self.source.len()`, which means it'll be at most\n        // equal to `self.source.len()`.\n        let (inspected, remaining) = unsafe { self.source.split_at_unchecked(i) };\n        self.source = remaining;\n\n        // SAFETY: `valid_up_to <= i` because it is only ever assigned via\n        // `valid_up_to = i` and `i` only increases.\n        let (valid, invalid) = unsafe { inspected.split_at_unchecked(valid_up_to) };\n\n        Some(Utf8Chunk {\n            // SAFETY: All bytes up to `valid_up_to` are valid UTF-8.\n            valid: unsafe { from_utf8_unchecked(valid) },\n            invalid,\n        })\n    }",
  "callees": [
    "47323665595455568617290020941376774286",
    "111425599901702694743874629435682172347",
    "714811817540972740211524868124730226803",
    "1329845230409163288212548289525672875535",
    "80772345035046942210372022594843481570",
    "109763229663154342343123224747831634619",
    "16824420916691935049705640393259467449",
    "561445107989240208511361370086377379752",
    "168545836479171427075036933182194130275",
    "1712898201300478840215074793236064467963",
    "841346702487865802717731804342903065853",
    "1617054938297627622011998382328717871744",
    "1196638383615410162910723134175805433641",
    "1182371843420022111010336901757313084440",
    "26064680123257945312537992217601395168",
    "55945426758310469736292479859590197325",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "1243847030362955698517207199029174369810",
    "105125143701458073564296455695110349394",
    "25930241974724637292994171257021210872",
    "617554482545947003412104686554524783687",
    "1445917162577882149418297081791436471284",
    "849628185942532211610194183090257053256",
    "152018209062913109616942758022114057971",
    "602553655434272852810568520159081802816",
    "102887121523905452179262747329207775596",
    "703663108277374327010040438608357482834",
    "1100495660517602822510660091708953776518",
    "316650073974070898314677646691025099244",
    "180824515799235861855048294605620195261",
    "134444069993780397564703136863158148716",
    "25269069644916694782526525713115896132",
    "3600424921079027518406387297978205971",
    "125503965774672678587505966790704230026",
    "156130332443363785142369276941490088427",
    "1295305430755090081516099295166961669593",
    "685067228267738706816520200651034208821",
    "806886716273422490012922041462466388021",
    "47867114697845434864733977363775125036",
    "179654496502614639316000517910785552386",
    "121719316555113793862003739913395039268",
    "1301380110374255458316535795464893833464",
    "177654207720279896464631270099131912070",
    "138774632689772549819578629668035245923",
    "7839859953712079114640771271960005865",
    "180126912453652104473132457509626900161",
    "1149265318701628438811160570489210589004",
    "399232661239117480517401994520839366833",
    "1366691609966069760614771012231218686545",
    "165260604638305226342101042842060873588",
    "34478597508049401479557782585707843723"
  ]
}
