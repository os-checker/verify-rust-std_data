{
  "file": "core/src/str/validations.rs",
  "name": "str::validations::next_code_point_reverse::<'_, slice::iter::Iter<'_, u8>>",
  "hash": "128686589914158798533390336383350066437",
  "hash_direct": "125613857219438926662249932955204475346",
  "src": "pub(super) unsafe fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\nwhere\n    I: DoubleEndedIterator<Item = &'a u8>,\n{\n    // Decode UTF-8\n    let w = match *bytes.next_back()? {\n        next_byte if next_byte < 128 => return Some(next_byte as u32),\n        back_byte => back_byte,\n    };\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [x [y [z w]]]\n    let mut ch;\n    // SAFETY: `bytes` produces an UTF-8-like string,\n    // so the iterator must produce a value here.\n    let z = unsafe { *bytes.next_back().unwrap_unchecked() };\n    ch = utf8_first_byte(z, 2);\n    if utf8_is_cont_byte(z) {\n        // SAFETY: `bytes` produces an UTF-8-like string,\n        // so the iterator must produce a value here.\n        let y = unsafe { *bytes.next_back().unwrap_unchecked() };\n        ch = utf8_first_byte(y, 3);\n        if utf8_is_cont_byte(y) {\n            // SAFETY: `bytes` produces an UTF-8-like string,\n            // so the iterator must produce a value here.\n            let x = unsafe { *bytes.next_back().unwrap_unchecked() };\n            ch = utf8_first_byte(x, 4);\n            ch = utf8_acc_cont_byte(ch, y);\n        }\n        ch = utf8_acc_cont_byte(ch, z);\n    }\n    ch = utf8_acc_cont_byte(ch, w);\n\n    Some(ch)\n}",
  "callees": [
    "47323665595455568617290020941376774286",
    "25768524018977866517055903022448790318",
    "111425599901702694743874629435682172347",
    "714811817540972740211524868124730226803",
    "1329845230409163288212548289525672875535",
    "16824420916691935049705640393259467449",
    "6221741227072437069508312353437850718",
    "841528230883583910260472553997390736",
    "315331140686166457616644577557668814534",
    "176742512093848468045239021356424772729",
    "172988202723925134796567682468931265149",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "53589810041120365110998933211304468616",
    "1243847030362955698517207199029174369810",
    "105125143701458073564296455695110349394",
    "703663108277374327010040438608357482834",
    "1100495660517602822510660091708953776518",
    "1614903415506775741017981287843401206816",
    "1740741091750212443512988176670821833323",
    "62964906474134410292844024784991518817",
    "934375696446284627516563118665690549226",
    "1028023859496283824714006082102994000183",
    "1375602339865304183616456573312626826122",
    "1038091007637423756616843932505132086543",
    "1163068038768334523712968925068122539241",
    "5815968703736580963562790859338858979",
    "608729603554387759112665830559747788319",
    "17942302198640903099897416856451704995",
    "873553439411192054217928980363503086913",
    "1256571648311385372818048563868553671913",
    "1256571648311385372818048563868553671913",
    "1256571648311385372818048563868553671913",
    "1256571648311385372818048563868553671913",
    "99865840988228285693998358138491244126",
    "99865840988228285693998358138491244126",
    "99865840988228285693998358138491244126",
    "99865840988228285693998358138491244126",
    "30545534060300319003176930052732022160",
    "302067364229160357212378258499441578857",
    "302067364229160357212378258499441578857",
    "302067364229160357212378258499441578857",
    "302067364229160357212378258499441578857",
    "284555045731488463910941043858609989409",
    "284555045731488463910941043858609989409",
    "284555045731488463910941043858609989409",
    "284555045731488463910941043858609989409",
    "802603331907130014710293248879007229107",
    "1793199026846464691616255721034512928348",
    "121973516639670562835557836045994389718",
    "550150895960312460312176584159342455723",
    "160761334367309494176444203284255754796",
    "399232661239117480517401994520839366833"
  ]
}
