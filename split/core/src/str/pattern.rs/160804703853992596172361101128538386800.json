{
  "file": "core/src/str/pattern.rs",
  "name": "str::pattern::TwoWaySearcher::next_back::<str::pattern::MatchOnly>",
  "hash": "160804703853992596172361101128538386800",
  "hash_direct": "426105727508752069914926293345794018675",
  "src": "fn next_back<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> S::Output\n    where\n        S: TwoWayStrategy,\n    {\n        // `next_back()` uses `self.end` as its cursor -- so that `next()` and `next_back()`\n        // are independent.\n        let old_end = self.end;\n        'search: loop {\n            // Check that we have room to search in\n            // end - needle.len() will wrap around when there is no more room,\n            // but due to slice length limits it can never wrap all the way back\n            // into the length of haystack.\n            let front_byte = match haystack.get(self.end.wrapping_sub(needle.len())) {\n                Some(&b) => b,\n                None => {\n                    self.end = 0;\n                    return S::rejecting(0, old_end);\n                }\n            };\n\n            if S::use_early_reject() && old_end != self.end {\n                return S::rejecting(self.end, old_end);\n            }\n\n            // Quickly skip by large portions unrelated to our substring\n            if !self.byteset_contains(front_byte) {\n                self.end -= needle.len();\n                if !long_period {\n                    self.memory_back = needle.len();\n                }\n                continue 'search;\n            }\n\n            // See if the left part of the needle matches\n            let crit = if long_period {\n                self.crit_pos_back\n            } else {\n                cmp::min(self.crit_pos_back, self.memory_back)\n            };\n            for i in (0..crit).rev() {\n                if needle[i] != haystack[self.end - needle.len() + i] {\n                    self.end -= self.crit_pos_back - i;\n                    if !long_period {\n                        self.memory_back = needle.len();\n                    }\n                    continue 'search;\n                }\n            }\n\n            // See if the right part of the needle matches\n            let needle_end = if long_period { needle.len() } else { self.memory_back };\n            for i in self.crit_pos_back..needle_end {\n                if needle[i] != haystack[self.end - needle.len() + i] {\n                    self.end -= self.period;\n                    if !long_period {\n                        self.memory_back = self.period;\n                    }\n                    continue 'search;\n                }\n            }\n\n            // We have found a match!\n            let match_pos = self.end - needle.len();\n            // Note: sub self.period instead of needle.len() to have overlapping matches\n            self.end -= needle.len();\n            if !long_period {\n                self.memory_back = needle.len();\n            }\n\n            return S::matching(match_pos, match_pos + needle.len());\n        }\n    }",
  "callees": [
    "7482589000750884340327816351015335759",
    "155146884437592745449279657258619050520",
    "111948483962809339883106353795926089322",
    "258820287469578611817448591488600041899",
    "17421822894816687532325615181214565887",
    "23815256893174302637797703719499456373",
    "167165721111217593893743718785627578467",
    "111893148674317480745590608994062193214",
    "11996021044221125357274189770344285829",
    "2266474927748722104589482484269181849",
    "106331898439077953744539516180016762298",
    "6914657791414926604643248476891087136",
    "117885714964136718011412517610531756244",
    "12115540591965961592218455255086567020",
    "24502394795559680767584204508227377419",
    "56992650673164436291130925969138191855",
    "90771261734924938883465308637020449641",
    "125312877505429677902664359715729802479",
    "1204668293620499224013336883119093261459",
    "5667765796385169624800112337147502292",
    "171593739300022194915526452191835401234",
    "350987180030767754610510964114749211972",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "478753423337745817613297159272845606672",
    "18924474281332607947427114014473837479",
    "760499024176919446914647389213438349877",
    "18415684320297405220951080584907961160",
    "1296411750804674058315087202364841236804",
    "921040717020639707211435762660647759802",
    "313548882690528367412077569528013544642",
    "179238937216206703897978799586879197334",
    "1737046666080539081914974966237099365643",
    "621698472431332816417792581602959129152",
    "739520556846959085018120036998133255835"
  ]
}
