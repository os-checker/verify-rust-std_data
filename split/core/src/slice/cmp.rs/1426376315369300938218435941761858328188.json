{
  "file": "core/src/slice/cmp.rs",
  "name": "<u16 as slice::cmp::SliceContains>::slice_contains::{closure#0}",
  "hash": "1426376315369300938218435941761858328188",
  "hash_direct": "253526860552293526315420005265292373316",
  "src": "|acc, x| acc | (*x == *self)",
  "macro_backtrace": [
    {
      "callsite": "impl_slice_contains!(u16, u32, u64, i16, i32, i64, f32, f64, usize, isize, char)",
      "defsite": "macro_rules! impl_slice_contains {\n    ($($t:ty),*) => {\n        $(\n            impl SliceContains for $t {\n                #[inline]\n                fn slice_contains(&self, arr: &[$t]) -> bool {\n                    // Make our LANE_COUNT 4x the normal lane count (aiming for 128 bit vectors).\n                    // The compiler will nicely unroll it.\n                    const LANE_COUNT: usize = 4 * (128 / (size_of::<$t>() * 8));\n                    // SIMD\n                    let mut chunks = arr.chunks_exact(LANE_COUNT);\n                    for chunk in &mut chunks {\n                        if chunk.iter().fold(false, |acc, x| acc | (*x == *self)) {\n                            return true;\n                        }\n                    }\n                    // Scalar remainder\n                    return chunks.remainder().iter().any(|x| *x == *self);\n                }\n            }\n        )*\n    };\n}"
    }
  ]
}
