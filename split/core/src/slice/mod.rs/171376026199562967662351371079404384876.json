{
  "file": "core/src/slice/mod.rs",
  "name": "core::slice::<impl [core::unicode::unicode_data::ShortOffsetRunHeader]>::binary_search_by::<'_, {closure@core::slice::<impl [core::unicode::unicode_data::ShortOffsetRunHeader]>::binary_search_by_key<'_, u32, {closure@core::unicode::unicode_data::skip_search<34, 751>::{closure#0}}>::{closure#0}}>",
  "hash": "171376026199562967662351371079404384876",
  "hash_direct": "68126568222197114251048866635846910896",
  "src": "pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,\n    {\n        let mut size = self.len();\n        if size == 0 {\n            return Err(0);\n        }\n        let mut base = 0usize;\n\n        // This loop intentionally doesn't have an early exit if the comparison\n        // returns Equal. We want the number of loop iterations to depend *only*\n        // on the size of the input slice so that the CPU can reliably predict\n        // the loop count.\n        while size > 1 {\n            let half = size / 2;\n            let mid = base + half;\n\n            // SAFETY: the call is made safe by the following invariants:\n            // - `mid >= 0`: by definition\n            // - `mid < size`: `mid = size / 2 + size / 4 + size / 8 ...`\n            let cmp = f(unsafe { self.get_unchecked(mid) });\n\n            // Binary search interacts poorly with branch prediction, so force\n            // the compiler to use conditional moves if supported by the target\n            // architecture.\n            base = hint::select_unpredictable(cmp == Greater, base, mid);\n\n            // This is imprecise in the case where `size` is odd and the\n            // comparison returns Greater: the mid element still gets included\n            // by `size` even though it's known to be larger than the element\n            // being searched for.\n            //\n            // This is fine though: we gain more performance by keeping the\n            // loop iteration count invariant (and thus predictable) than we\n            // lose from considering one additional element.\n            size -= half;\n        }\n\n        // SAFETY: base is always in [0, size) because base <= mid.\n        let cmp = f(unsafe { self.get_unchecked(base) });\n        if cmp == Equal {\n            // SAFETY: same as the `get_unchecked` above.\n            unsafe { hint::assert_unchecked(base < self.len()) };\n            Ok(base)\n        } else {\n            let result = base + (cmp == Less) as usize;\n            // SAFETY: same as the `get_unchecked` above.\n            // Note that this is `<=`, unlike the assume in the `Ok` path.\n            unsafe { hint::assert_unchecked(result <= self.len()) };\n            Err(result)\n        }\n    }",
  "callees": [
    "141364671331973869778270942055776551817",
    "38033425202961758733378719026903933598",
    "12281449246394340237926324936375242532",
    "1511275866077199755612412536318849312657",
    "109777261735956977828864330544561630572",
    "213976084203050181513038939684188374657",
    "1263945855766849354510334944065532128780",
    "181267529910573756716102767087485333561",
    "79817071675776388295206212610749591701",
    "1824545319189397521315695847785602896178",
    "1022803319099694746713266409355997953681",
    "700121798421844638112954362982616513440",
    "3426408591059629602792909874372843773",
    "132656586283717246419120116467473299819",
    "135467273534976011077632682255406986070",
    "139483837448589163674758035261080447269",
    "439022777647632696517945103495108037392",
    "897265533945643607115272871669854221703",
    "89502211078669479795623704974378882516",
    "986792852990965178117440249555081278778",
    "90818112465881722349174357944217011292",
    "146612017564224181584303574960223420416",
    "63085389524472853348886374617170044294",
    "175623961004431005849298709567805707658",
    "33067340742295788584221598515845050786",
    "20743252454400330067347997888777335224",
    "181953690662554297912505335505865467275",
    "154716117204139621346903708735117238315",
    "10435104334233940885347855730897394048",
    "1793681111599931821712213635413918902143",
    "55408212128999564608147158566316072753",
    "68484638068549756813527774561016858731",
    "1328599216671135015714776194882339466358",
    "76687630660750854831132439645386232409",
    "1102707990469809545812015399289882219301",
    "8161099640543304955344124854131248786",
    "19058764743854314419670517218317949449",
    "89898726682182899673927275838299842474",
    "1176805568875757844412601215105379417272",
    "70542180169395563810324335690772955151",
    "1108872896406389492011663091904032266319",
    "1753166894143510804112784709663712737672",
    "42640861811413251621458178080920148489",
    "8787952082428538504365079471726452107",
    "3209455355414418345596547327370884836",
    "112989397975222255532054380452996322405",
    "597683522621928614711119364722938279780",
    "17341452779707394601695269753709495351",
    "177905935490097550717772327309877997817"
  ]
}
