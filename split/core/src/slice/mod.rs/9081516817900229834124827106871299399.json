{
  "file": "core/src/slice/mod.rs",
  "name": "slice::<impl [char]>::align_to_offsets::<u128>",
  "hash": "9081516817900229834124827106871299399",
  "hash_direct": "280547280492542663714972759018943463170",
  "src": "fn align_to_offsets<U>(&self) -> (usize, usize) {\n        // What we gonna do about `rest` is figure out what multiple of `U`s we can put in a\n        // lowest number of `T`s. And how many `T`s we need for each such \"multiple\".\n        //\n        // Consider for example T=u8 U=u16. Then we can put 1 U in 2 Ts. Simple. Now, consider\n        // for example a case where size_of::<T> = 16, size_of::<U> = 24. We can put 2 Us in\n        // place of every 3 Ts in the `rest` slice. A bit more complicated.\n        //\n        // Formula to calculate this is:\n        //\n        // Us = lcm(size_of::<T>, size_of::<U>) / size_of::<U>\n        // Ts = lcm(size_of::<T>, size_of::<U>) / size_of::<T>\n        //\n        // Expanded and simplified:\n        //\n        // Us = size_of::<T> / gcd(size_of::<T>, size_of::<U>)\n        // Ts = size_of::<U> / gcd(size_of::<T>, size_of::<U>)\n        //\n        // Luckily since all this is constant-evaluated... performance here matters not!\n        const fn gcd(a: usize, b: usize) -> usize {\n            if b == 0 { a } else { gcd(b, a % b) }\n        }\n\n        // Explicitly wrap the function call in a const block so it gets\n        // constant-evaluated even in debug mode.\n        let gcd: usize = const { gcd(size_of::<T>(), size_of::<U>()) };\n        let ts: usize = size_of::<U>() / gcd;\n        let us: usize = size_of::<T>() / gcd;\n\n        // Armed with this knowledge, we can find how many `U`s we can fit!\n        let us_len = self.len() / ts * us;\n        // And how many `T`s will be in the trailing slice!\n        let ts_len = self.len() % ts;\n        (us_len, ts_len)\n    }",
  "callees": [
    "86133515756163850188547131179003511107",
    "643230467485784801514457338296833761965"
  ]
}
