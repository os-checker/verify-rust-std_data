{
  "file": "core/src/slice/mod.rs",
  "name": "slice::<impl [()]>::align_to::<char>",
  "hash": "1433479329781128869577455559492555608",
  "hash_direct": "72648388613158106394589261330525781296",
  "src": "pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n        // Note that most of this function will be constant-evaluated,\n        if U::IS_ZST || T::IS_ZST {\n            // handle ZSTs specially, which is â€“ don't handle them at all.\n            return (self, &[], &[]);\n        }\n\n        // First, find at what point do we split between the first and 2nd slice. Easy with\n        // ptr.align_offset.\n        let ptr = self.as_ptr();\n        // SAFETY: See the `align_to_mut` method for the detailed safety comment.\n        let offset = unsafe { crate::ptr::align_offset(ptr, align_of::<U>()) };\n        if offset > self.len() {\n            (self, &[], &[])\n        } else {\n            let (left, rest) = self.split_at(offset);\n            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n            // Inform Miri that we want to consider the \"middle\" pointer to be suitably aligned.\n            #[cfg(miri)]\n            crate::intrinsics::miri_promise_symbolic_alignment(\n                rest.as_ptr().cast(),\n                align_of::<U>(),\n            );\n            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n            // since the caller guarantees that we can transmute `T` to `U` safely.\n            unsafe {\n                (\n                    left,\n                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n                )\n            }\n        }\n    }",
  "callees": [
    "258820287469578611817448591488600041899",
    "588974892899239543415856878986124229421",
    "690438059002452523915046149102377829082",
    "17421822894816687532325615181214565887",
    "313288670142853245916792507642081759284",
    "27480086118489678191003877857780025576",
    "23815256893174302637797703719499456373",
    "1639190511405576016712069487289226138136",
    "24899707394772763509340058915194816546",
    "154632036321720824021555629139300729764",
    "274291830502248510811445962002553983266",
    "86133515756163850188547131179003511107",
    "143572956432032064744447501745832117320",
    "137368381448604167703416046205455599816",
    "156396365605833484958181337486344432065",
    "13303575705867660165971022725037666878",
    "761861023504359043615820998596748928032",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "1752989996936949203916036071159051010960",
    "478753423337745817613297159272845606672",
    "33251186460804850106507820263383872831",
    "3658730781980743391697756456907208995",
    "176386771705132260856587306647620489942",
    "24720139230274117689328858551755358968",
    "1566168013061370513711054548557151263674",
    "375960559020688079617955032586718986019",
    "187482952606822645712460029589708661523",
    "126818845945534382313624863669169238336",
    "1045253218198362802817926442850613386040",
    "7065725997555242645633793423334929656",
    "459810727651636371214600554442874478180",
    "108552149900633290919250115311635650035",
    "108220157883617260478069008114297751968",
    "19598639546271956478323969070632122613",
    "1606030480809784422315766327258874816074",
    "1447601486929668150610263772015915174545",
    "30487059972984412827689666128919789738",
    "164711118354730143454097513815343207342",
    "42864214560640795538237278417314402851",
    "705188544932686626114193360318583844083",
    "75421158218937589828114696376544988756",
    "1006928117247909106515604664996585110540",
    "56448737519681294968960799914289695112",
    "51920321377442756437204742573348251158",
    "739520556846959085018120036998133255835",
    "154579918799348646172273891119983850679",
    "71112245793085408723525187754979718597",
    "1217330957027791981411010835694243116934"
  ]
}
