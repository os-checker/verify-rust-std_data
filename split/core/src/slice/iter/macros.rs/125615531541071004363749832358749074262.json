{
  "file": "core/src/slice/iter/macros.rs",
  "name": "<slice::iter::Iter<'_, u32> as iter::traits::iterator::Iterator>::fold::<bool, {closure@/home/runner/work/distributed-verification/distributed-verification/verify-rust-std/library/core/src/slice/cmp.rs:396:53: 396:61}>",
  "hash": "125615531541071004363749832358749074262",
  "hash_direct": "23357214841156351546961500062552389176",
  "src": "fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }",
  "macro_backtrace": [
    {
      "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
      "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            #[cfg_attr(kani, kani::modifies(self))]\n            #[safety::requires(!is_empty!(self))]\n            #[safety::ensures(|_| self.is_safe())]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            #[cfg_attr(kani, kani::modifies(self))]\n            #[safety::requires(offset <= len!(self))]\n            #[safety::ensures(|_| self.is_safe())]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            #[cfg_attr(kani, kani::modifies(self))]\n            #[safety::requires(offset <= len!(self))]\n            #[safety::ensures(|_| self.is_safe())]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            #[safety::requires(idx < len!(self))]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            #[safety::requires(!is_empty!(self))]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
    }
  ],
  "callees": [
    "258820287469578611817448591488600041899",
    "17421822894816687532325615181214565887",
    "1529875730411415803517587657844377161231",
    "23815256893174302637797703719499456373",
    "99603598099498707762068107842012164044",
    "13303575705867660165971022725037666878",
    "174107661030119018973646362480685393050",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "243931809744896974812513529918607549579",
    "1752989996936949203916036071159051010960",
    "478753423337745817613297159272845606672",
    "1214574077763705187516383491048990527345",
    "124136043214748897212366978666582003224",
    "46403460040447917584474138551510745026",
    "1299320173005259176217029432174392215732",
    "141639776557979467351154191462161712427",
    "167727689149889732012371385327419155313",
    "1727553854790856278011052472099747994665",
    "150078872849429602735832397785542156102",
    "33331637534491476913440505814675408305",
    "129554570757985733413117109142277739837",
    "83701329576096449194952412384715944643",
    "126048648882406442003602795325732745334",
    "92658835324565758495130762072978604201",
    "739520556846959085018120036998133255835"
  ]
}
