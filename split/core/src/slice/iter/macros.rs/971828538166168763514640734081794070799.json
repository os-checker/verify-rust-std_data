{
  "file": "core/src/slice/iter/macros.rs",
  "name": "<core::slice::Iter<'_, u8> as core::iter::Iterator>::fold::<(), {closure@core::iter::adapters::map::map_fold<&u8, u8, (), {closure@/home/runner/work/distributed-verification/distributed-verification/verify-rust-std/library/alloc/src/str.rs:711:49: 711:52}, {closure@core::iter::Iterator::for_each::call<u8, {closure@/home/runner/work/distributed-verification/distributed-verification/verify-rust-std/library/alloc/src/vec/mod.rs:3824:35: 3824:49}>::{closure#0}}>::{closure#0}}>",
  "hash": "971828538166168763514640734081794070799",
  "hash_direct": "117896118831761823957349599283014519254",
  "src": "fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }",
  "macro_backtrace": [
    {
      "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
      "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            #[cfg_attr(kani, kani::modifies(self))]\n            #[safety::requires(!is_empty!(self))]\n            #[safety::ensures(|_| self.is_safe())]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            #[cfg_attr(kani, kani::modifies(self))]\n            #[safety::requires(offset <= len!(self))]\n            #[safety::ensures(|_| self.is_safe())]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            #[cfg_attr(kani, kani::modifies(self))]\n            #[safety::requires(offset <= len!(self))]\n            #[safety::ensures(|_| self.is_safe())]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            #[safety::requires(idx < len!(self))]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            #[safety::requires(!is_empty!(self))]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
    }
  ],
  "callees": [
    "13006671868649879165920642626120321820",
    "13946280446962039053569737044567885419",
    "129832444481914698572618590208818518160",
    "1093003471854123858514730727513262573284",
    "22764982947794928291619404638216582552",
    "12281449246394340237926324936375242532",
    "99835071136844477394667148890151411684",
    "73694171442177138896992135977130617471",
    "181267529910573756716102767087485333561",
    "79817071675776388295206212610749591701",
    "310476737258981539215905981644988688429",
    "28798021335959613552226646194290957655",
    "1824545319189397521315695847785602896178",
    "1022803319099694746713266409355997953681",
    "1145094639071049483215222640206002172219",
    "173377137931829843369203916638161990970",
    "97566299569839892074656028861613377837",
    "1055043272310861592713228670863657256034",
    "17976542625295060605041426324269334020",
    "897265533945643607115272871669854221703",
    "89502211078669479795623704974378882516",
    "170846580729842163074659927269266210653",
    "8010637041282557608011263416999007001",
    "89553991991390806369608823483879896538",
    "986792852990965178117440249555081278778",
    "90818112465881722349174357944217011292",
    "170281423934441608902372914597711355436",
    "146612017564224181584303574960223420416",
    "63085389524472853348886374617170044294",
    "175623961004431005849298709567805707658",
    "33067340742295788584221598515845050786",
    "20743252454400330067347997888777335224",
    "181953690662554297912505335505865467275",
    "262831349882779883815480941076479924039",
    "1793681111599931821712213635413918902143",
    "55408212128999564608147158566316072753",
    "124048927270173258543682139801948377007",
    "906948199880776417018241594337902780119",
    "121699176439207571551116573453334694848",
    "56605460301092211643908078480200231888",
    "793319680976881205710539602328434704009",
    "1753303359881017823516938305256685629547",
    "735018919234909984611473533948904259624",
    "5544996909776080217602144286126393952",
    "298884710962780778440604835530166814",
    "1213241336815109722310271468032047462595",
    "92005998086269722606437028357039395831",
    "181717373102152254895109628399379607332",
    "131565587963228383647279312131403441535",
    "116953387026626631555337908913709999943",
    "747156457449598790816736684951635660145",
    "150019527417952190621648957790276729733",
    "1095899137830294982412553623289739398460",
    "112989397975222255532054380452996322405",
    "597683522621928614711119364722938279780",
    "17341452779707394601695269753709495351"
  ]
}
