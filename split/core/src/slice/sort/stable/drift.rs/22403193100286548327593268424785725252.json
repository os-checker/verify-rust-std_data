{
  "file": "core/src/slice/sort/stable/drift.rs",
  "name": "slice::sort::stable::drift::sqrt_approx",
  "hash": "22403193100286548327593268424785725252",
  "hash_direct": "1745282830712190166613754705104016716133",
  "src": "fn sqrt_approx(n: usize) -> usize {\n    // Note that sqrt(n) = n^(1/2), and that 2^log2(n) = n. We combine these\n    // two facts to approximate sqrt(n) as 2^(log2(n) / 2). Because our integer\n    // log floors we want to add 0.5 to compensate for this on average, so our\n    // initial approximation is 2^((1 + floor(log2(n))) / 2).\n    //\n    // We then apply an iteration of Newton's method to improve our\n    // approximation, which for sqrt(n) is a1 = (a0 + n / a0) / 2.\n    //\n    // Finally we note that the exponentiation / division can be done directly\n    // with shifts. We OR with 1 to avoid zero-checks in the integer log.\n    let ilog = (n | 1).ilog2();\n    let shift = ilog.div_ceil(2);\n    ((1 << shift) + (n >> shift)) / 2\n}",
  "callees": [
    "258820287469578611817448591488600041899",
    "50186211171463953727684864518369695334",
    "34410515695185066949979771014252260096",
    "29146486097285943072997980051462331422",
    "10935169124168190713897023636148712666",
    "1676806814539779643518083197252466559589",
    "86973485814532178778700632526421075230",
    "79471743776648140619750815083574719749",
    "296379394274353785313073430830910699396",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "1752989996936949203916036071159051010960"
  ]
}
