{
  "file": "core/src/slice/sort/stable/drift.rs",
  "name": "slice::sort::stable::drift::sqrt_approx",
  "hash": "255144267985817360714545772341429243057",
  "hash_direct": "1745282830712190166613754705104016716133",
  "src": "fn sqrt_approx(n: usize) -> usize {\n    // Note that sqrt(n) = n^(1/2), and that 2^log2(n) = n. We combine these\n    // two facts to approximate sqrt(n) as 2^(log2(n) / 2). Because our integer\n    // log floors we want to add 0.5 to compensate for this on average, so our\n    // initial approximation is 2^((1 + floor(log2(n))) / 2).\n    //\n    // We then apply an iteration of Newton's method to improve our\n    // approximation, which for sqrt(n) is a1 = (a0 + n / a0) / 2.\n    //\n    // Finally we note that the exponentiation / division can be done directly\n    // with shifts. We OR with 1 to avoid zero-checks in the integer log.\n    let ilog = (n | 1).ilog2();\n    let shift = ilog.div_ceil(2);\n    ((1 << shift) + (n >> shift)) / 2\n}",
  "callees": [
    "258820287469578611817448591488600041899",
    "50186211171463953727684864518369695334",
    "34410515695185066949979771014252260096",
    "82673335129552629317708046730690637448",
    "63508941524203719206996976005100287210",
    "1676806814539779643518083197252466559589",
    "24020411044656085248586030498591244898",
    "50583337313053329404845503660603560676",
    "150614045265181541127113376896708745784",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "1752989996936949203916036071159051010960"
  ]
}
