{
  "file": "core/src/slice/sort/stable/drift.rs",
  "name": "slice::sort::stable::drift::sqrt_approx",
  "hash": "1443528330336837784014302543520297766461",
  "hash_direct": "1745282830712190166613754705104016716133",
  "src": "fn sqrt_approx(n: usize) -> usize {\n    // Note that sqrt(n) = n^(1/2), and that 2^log2(n) = n. We combine these\n    // two facts to approximate sqrt(n) as 2^(log2(n) / 2). Because our integer\n    // log floors we want to add 0.5 to compensate for this on average, so our\n    // initial approximation is 2^((1 + floor(log2(n))) / 2).\n    //\n    // We then apply an iteration of Newton's method to improve our\n    // approximation, which for sqrt(n) is a1 = (a0 + n / a0) / 2.\n    //\n    // Finally we note that the exponentiation / division can be done directly\n    // with shifts. We OR with 1 to avoid zero-checks in the integer log.\n    let ilog = (n | 1).ilog2();\n    let shift = ilog.div_ceil(2);\n    ((1 << shift) + (n >> shift)) / 2\n}",
  "callees": [
    "47323665595455568617290020941376774286",
    "17669494056957649145896081724806188101",
    "161003650625398914518944455314788757627",
    "77998170374190629455861399969371096041",
    "169552790667089619279212848647780148045",
    "375485108047544468212954122974188100514",
    "1211549082959924370012480764396369055485",
    "69486892396498104859321433451980950783",
    "46837697788760171237440623942406809594",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "1243847030362955698517207199029174369810"
  ]
}
