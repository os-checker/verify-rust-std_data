{
  "file": "core/src/num/flt2dec/strategy/grisu.rs",
  "name": "num::flt2dec::strategy::grisu::format_shortest_opt::round_and_weed",
  "hash": "150049311099975308329697245386925670596",
  "hash_direct": "6755688374365203541520988653049460749",
  "src": "fn round_and_weed(\n        buf: &mut [u8],\n        exp: i16,\n        remainder: u64,\n        threshold: u64,\n        plus1v: u64,\n        ten_kappa: u64,\n        ulp: u64,\n    ) -> Option<(&[u8], i16)> {\n        assert!(!buf.is_empty());\n\n        // produce two approximations to `v` (actually `plus1 - v`) within 1.5 ulps.\n        // the resulting representation should be the closest representation to both.\n        //\n        // here `plus1 - v` is used since calculations are done with respect to `plus1`\n        // in order to avoid overflow/underflow (hence the seemingly swapped names).\n        let plus1v_down = plus1v + ulp; // plus1 - (v - 1 ulp)\n        let plus1v_up = plus1v - ulp; // plus1 - (v + 1 ulp)\n\n        // decrease the last digit and stop at the closest representation to `v + 1 ulp`.\n        let mut plus1w = remainder; // plus1w(n) = plus1 - w(n)\n        {\n            let last = buf.last_mut().unwrap();\n\n            // we work with the approximated digits `w(n)`, which is initially equal to `plus1 -\n            // plus1 % 10^kappa`. after running the loop body `n` times, `w(n) = plus1 -\n            // plus1 % 10^kappa - n * 10^kappa`. we set `plus1w(n) = plus1 - w(n) =\n            // plus1 % 10^kappa + n * 10^kappa` (thus `remainder = plus1w(0)`) to simplify checks.\n            // note that `plus1w(n)` is always increasing.\n            //\n            // we have three conditions to terminate. any of them will make the loop unable to\n            // proceed, but we then have at least one valid representation known to be closest to\n            // `v + 1 ulp` anyway. we will denote them as TC1 through TC3 for brevity.\n            //\n            // TC1: `w(n) <= v + 1 ulp`, i.e., this is the last repr that can be the closest one.\n            // this is equivalent to `plus1 - w(n) = plus1w(n) >= plus1 - (v + 1 ulp) = plus1v_up`.\n            // combined with TC2 (which checks if `w(n+1)` is valid), this prevents the possible\n            // overflow on the calculation of `plus1w(n)`.\n            //\n            // TC2: `w(n+1) < minus1`, i.e., the next repr definitely does not round to `v`.\n            // this is equivalent to `plus1 - w(n) + 10^kappa = plus1w(n) + 10^kappa >\n            // plus1 - minus1 = threshold`. the left hand side can overflow, but we know\n            // `threshold > plus1v`, so if TC1 is false, `threshold - plus1w(n) >\n            // threshold - (plus1v - 1 ulp) > 1 ulp` and we can safely test if\n            // `threshold - plus1w(n) < 10^kappa` instead.\n            //\n            // TC3: `abs(w(n) - (v + 1 ulp)) <= abs(w(n+1) - (v + 1 ulp))`, i.e., the next repr is\n            // no closer to `v + 1 ulp` than the current repr. given `z(n) = plus1v_up - plus1w(n)`,\n            // this becomes `abs(z(n)) <= abs(z(n+1))`. again assuming that TC1 is false, we have\n            // `z(n) > 0`. we have two cases to consider:\n            //\n            // - when `z(n+1) >= 0`: TC3 becomes `z(n) <= z(n+1)`. as `plus1w(n)` is increasing,\n            //   `z(n)` should be decreasing and this is clearly false.\n            // - when `z(n+1) < 0`:\n            //   - TC3a: the precondition is `plus1v_up < plus1w(n) + 10^kappa`. assuming TC2 is\n            //     false, `threshold >= plus1w(n) + 10^kappa` so it cannot overflow.\n            //   - TC3b: TC3 becomes `z(n) <= -z(n+1)`, i.e., `plus1v_up - plus1w(n) >=\n            //     plus1w(n+1) - plus1v_up = plus1w(n) + 10^kappa - plus1v_up`. the negated TC1\n            //     gives `plus1v_up > plus1w(n)`, so it cannot overflow or underflow when\n            //     combined with TC3a.\n            //\n            // consequently, we should stop when `TC1 || TC2 || (TC3a && TC3b)`. the following is\n            // equal to its inverse, `!TC1 && !TC2 && (!TC3a || !TC3b)`.\n            while plus1w < plus1v_up\n                && threshold - plus1w >= ten_kappa\n                && (plus1w + ten_kappa < plus1v_up\n                    || plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up)\n            {\n                *last -= 1;\n                debug_assert!(*last > b'0'); // the shortest repr cannot end with `0`\n                plus1w += ten_kappa;\n            }\n        }\n\n        // check if this representation is also the closest representation to `v - 1 ulp`.\n        //\n        // this is simply same to the terminating conditions for `v + 1 ulp`, with all `plus1v_up`\n        // replaced by `plus1v_down` instead. overflow analysis equally holds.\n        if plus1w < plus1v_down\n            && threshold - plus1w >= ten_kappa\n            && (plus1w + ten_kappa < plus1v_down\n                || plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down)\n        {\n            return None;\n        }\n\n        // now we have the closest representation to `v` between `plus1` and `minus1`.\n        // this is too liberal, though, so we reject any `w(n)` not between `plus0` and `minus0`,\n        // i.e., `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n        // that `threshold = plus1 - minus1` and `plus1 - plus0 = minus0 - minus1 = 2 ulp`.\n        if 2 * ulp <= plus1w && plus1w <= threshold - 4 * ulp { Some((buf, exp)) } else { None }\n    }",
  "callees": [
    "47323665595455568617290020941376774286",
    "1512772528668906894810512686157656251676",
    "90154399545981751929034700539601653658",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "53589810041120365110998933211304468616",
    "1243847030362955698517207199029174369810",
    "806886716273422490012922041462466388021",
    "906269420735494801410852980828814528567"
  ]
}
