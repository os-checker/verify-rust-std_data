{
  "file": "core/src/num/wrapping.rs",
  "name": "num::wrapping::Wrapping::<i8>::is_positive",
  "hash": "18604360480786697431221978388007706842",
  "hash_direct": "173460148307485495432118125889734331194",
  "src": "pub const fn is_positive(self) -> bool {\n                self.0.is_positive()\n            }",
  "macro_backtrace": [
    {
      "callsite": "wrapping_int_impl_signed! { isize i8 i16 i32 i64 i128 }",
      "defsite": "macro_rules! wrapping_int_impl_signed {\n    ($($t:ty)*) => ($(\n        impl Wrapping<$t> {\n            /// Returns the number of leading zeros in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\")]\n            ///\n            /// assert_eq!(n.leading_zeros(), 3);\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn leading_zeros(self) -> u32 {\n                self.0.leading_zeros()\n            }\n\n            /// Computes the absolute value of `self`, wrapping around at\n            /// the boundary of the type.\n            ///\n            /// The only case where such wrapping can occur is when one takes the absolute value of the negative\n            /// minimal value for the type this is a positive value that is too large to represent in the type. In\n            /// such a case, this function returns `MIN` itself.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(Wrapping(100\", stringify!($t), \").abs(), Wrapping(100));\")]\n            #[doc = concat!(\"assert_eq!(Wrapping(-100\", stringify!($t), \").abs(), Wrapping(100));\")]\n            #[doc = concat!(\"assert_eq!(Wrapping(\", stringify!($t), \"::MIN).abs(), Wrapping(\", stringify!($t), \"::MIN));\")]\n            /// assert_eq!(Wrapping(-128i8).abs().0 as u8, 128u8);\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub fn abs(self) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_abs())\n            }\n\n            /// Returns a number representing sign of `self`.\n            ///\n            ///  - `0` if the number is zero\n            ///  - `1` if the number is positive\n            ///  - `-1` if the number is negative\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(Wrapping(10\", stringify!($t), \").signum(), Wrapping(1));\")]\n            #[doc = concat!(\"assert_eq!(Wrapping(0\", stringify!($t), \").signum(), Wrapping(0));\")]\n            #[doc = concat!(\"assert_eq!(Wrapping(-10\", stringify!($t), \").signum(), Wrapping(-1));\")]\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub fn signum(self) -> Wrapping<$t> {\n                Wrapping(self.0.signum())\n            }\n\n            /// Returns `true` if `self` is positive and `false` if the number is zero or\n            /// negative.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert!(Wrapping(10\", stringify!($t), \").is_positive());\")]\n            #[doc = concat!(\"assert!(!Wrapping(-10\", stringify!($t), \").is_positive());\")]\n            /// ```\n            #[must_use]\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn is_positive(self) -> bool {\n                self.0.is_positive()\n            }\n\n            /// Returns `true` if `self` is negative and `false` if the number is zero or\n            /// positive.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert!(Wrapping(-10\", stringify!($t), \").is_negative());\")]\n            #[doc = concat!(\"assert!(!Wrapping(10\", stringify!($t), \").is_negative());\")]\n            /// ```\n            #[must_use]\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn is_negative(self) -> bool {\n                self.0.is_negative()\n            }\n        }\n    )*)\n}"
    }
  ],
  "callees": [
    "153106287603906656485957743842226965528"
  ]
}
