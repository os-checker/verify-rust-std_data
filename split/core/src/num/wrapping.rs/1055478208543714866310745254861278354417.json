{
  "file": "core/src/num/wrapping.rs",
  "name": "num::wrapping::Wrapping::<i16>::count_zeros",
  "hash": "1055478208543714866310745254861278354417",
  "hash_direct": "55917601954308721604446629733775307218",
  "src": "pub const fn count_zeros(self) -> u32 {\n                self.0.count_zeros()\n            }",
  "macro_backtrace": [
    {
      "callsite": "wrapping_int_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }",
      "defsite": "macro_rules! wrapping_int_impl {\n    ($($t:ty)*) => ($(\n        impl Wrapping<$t> {\n            /// Returns the smallest value that can be represented by this integer type.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(<Wrapping<\", stringify!($t), \">>::MIN, Wrapping(\", stringify!($t), \"::MIN));\")]\n            /// ```\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const MIN: Self = Self(<$t>::MIN);\n\n            /// Returns the largest value that can be represented by this integer type.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(<Wrapping<\", stringify!($t), \">>::MAX, Wrapping(\", stringify!($t), \"::MAX));\")]\n            /// ```\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const MAX: Self = Self(<$t>::MAX);\n\n            /// Returns the size of this integer type in bits.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(<Wrapping<\", stringify!($t), \">>::BITS, \", stringify!($t), \"::BITS);\")]\n            /// ```\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const BITS: u32 = <$t>::BITS;\n\n            /// Returns the number of ones in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0b01001100\", stringify!($t), \");\")]\n            ///\n            /// assert_eq!(n.count_ones(), 3);\n            /// ```\n            #[inline]\n            #[doc(alias = \"popcount\")]\n            #[doc(alias = \"popcnt\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn count_ones(self) -> u32 {\n                self.0.count_ones()\n            }\n\n            /// Returns the number of zeros in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(Wrapping(!0\", stringify!($t), \").count_zeros(), 0);\")]\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn count_zeros(self) -> u32 {\n                self.0.count_zeros()\n            }\n\n            /// Returns the number of trailing zeros in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0b0101000\", stringify!($t), \");\")]\n            ///\n            /// assert_eq!(n.trailing_zeros(), 3);\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn trailing_zeros(self) -> u32 {\n                self.0.trailing_zeros()\n            }\n\n            /// Shifts the bits to the left by a specified amount, `n`,\n            /// wrapping the truncated bits to the end of the resulting\n            /// integer.\n            ///\n            /// Please note this isn't the same operation as the `<<` shifting\n            /// operator!\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n            /// let m: Wrapping<i64> = Wrapping(-0x76543210FEDCBA99);\n            ///\n            /// assert_eq!(n.rotate_left(32), m);\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn rotate_left(self, n: u32) -> Self {\n                Wrapping(self.0.rotate_left(n))\n            }\n\n            /// Shifts the bits to the right by a specified amount, `n`,\n            /// wrapping the truncated bits to the beginning of the resulting\n            /// integer.\n            ///\n            /// Please note this isn't the same operation as the `>>` shifting\n            /// operator!\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n            /// let m: Wrapping<i64> = Wrapping(-0xFEDCBA987654322);\n            ///\n            /// assert_eq!(n.rotate_right(4), m);\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn rotate_right(self, n: u32) -> Self {\n                Wrapping(self.0.rotate_right(n))\n            }\n\n            /// Reverses the byte order of the integer.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// let n: Wrapping<i16> = Wrapping(0b0000000_01010101);\n            /// assert_eq!(n, Wrapping(85));\n            ///\n            /// let m = n.swap_bytes();\n            ///\n            /// assert_eq!(m, Wrapping(0b01010101_00000000));\n            /// assert_eq!(m, Wrapping(21760));\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn swap_bytes(self) -> Self {\n                Wrapping(self.0.swap_bytes())\n            }\n\n            /// Reverses the bit pattern of the integer.\n            ///\n            /// # Examples\n            ///\n            /// Please note that this example is shared among integer types, which is why `i16`\n            /// is used.\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// use std::num::Wrapping;\n            ///\n            /// let n = Wrapping(0b0000000_01010101i16);\n            /// assert_eq!(n, Wrapping(85));\n            ///\n            /// let m = n.reverse_bits();\n            ///\n            /// assert_eq!(m.0 as u16, 0b10101010_00000000);\n            /// assert_eq!(m, Wrapping(-22016));\n            /// ```\n            #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n            #[rustc_const_stable(feature = \"const_reverse_bits\", since = \"1.37.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn reverse_bits(self) -> Self {\n                Wrapping(self.0.reverse_bits())\n            }\n\n            /// Converts an integer from big endian to the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_be(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_be(n), n.swap_bytes())\")]\n            /// }\n            /// ```\n            #[inline]\n            #[must_use]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn from_be(x: Self) -> Self {\n                Wrapping(<$t>::from_be(x.0))\n            }\n\n            /// Converts an integer from little endian to the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_le(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_le(n), n.swap_bytes())\")]\n            /// }\n            /// ```\n            #[inline]\n            #[must_use]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn from_le(x: Self) -> Self {\n                Wrapping(<$t>::from_le(x.0))\n            }\n\n            /// Converts `self` to big endian from the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            ///     assert_eq!(n.to_be(), n)\n            /// } else {\n            ///     assert_eq!(n.to_be(), n.swap_bytes())\n            /// }\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn to_be(self) -> Self {\n                Wrapping(self.0.to_be())\n            }\n\n            /// Converts `self` to little endian from the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            ///     assert_eq!(n.to_le(), n)\n            /// } else {\n            ///     assert_eq!(n.to_le(), n.swap_bytes())\n            /// }\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn to_le(self) -> Self {\n                Wrapping(self.0.to_le())\n            }\n\n            /// Raises self to the power of `exp`, using exponentiation by squaring.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(Wrapping(3\", stringify!($t), \").pow(4), Wrapping(81));\")]\n            /// ```\n            ///\n            /// Results that are too large are wrapped:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// assert_eq!(Wrapping(3i8).pow(5), Wrapping(-13));\n            /// assert_eq!(Wrapping(3i8).pow(6), Wrapping(-39));\n            /// ```\n            #[inline]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub fn pow(self, exp: u32) -> Self {\n                Wrapping(self.0.wrapping_pow(exp))\n            }\n        }\n    )*)\n}"
    }
  ],
  "callees": [
    "124692644073698712888647358177778262941",
    "14478150187293817575474979595304241775",
    "21104535475405429403494343596662102415"
  ]
}
