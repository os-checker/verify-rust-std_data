{
  "file": "core/src/num/int_sqrt.rs",
  "name": "num::int_sqrt::u128_stages::HALF_BITS",
  "hash": "943643076275893812715811341664201605688",
  "hash_direct": "43251300032384564519618149900950673700",
  "src": "const HALF_BITS: u32 = <$ty>::BITS >> 1;",
  "macro_backtrace": [
    {
      "callsite": "last_stage!(u128, n, s, r)",
      "defsite": "macro_rules! last_stage {\n    ($ty:ty, $n:ident, $s:ident, $r:ident) => {{\n        debug_assert!($s != 0, \"`$s` is  zero in `last_stage!`.\");\n\n        const HALF_BITS: u32 = <$ty>::BITS >> 1;\n        const QUARTER_BITS: u32 = <$ty>::BITS >> 2;\n        const LOWER_HALF_1_BITS: $ty = (1 << HALF_BITS) - 1;\n\n        let lo = $n & LOWER_HALF_1_BITS;\n        let numerator = (($r as $ty) << QUARTER_BITS) | (lo >> QUARTER_BITS);\n        let denominator = ($s as $ty) << 1;\n\n        let q = numerator / denominator;\n        let mut s = ($s << QUARTER_BITS) as $ty + q;\n        let (s_squared, overflow) = s.overflowing_mul(s);\n        if overflow || s_squared > $n {\n            s -= 1;\n        }\n        s\n    }};\n}"
    }
  ]
}
