{
  "file": "core/src/num/dec2flt/decimal_seq.rs",
  "name": "num::dec2flt::decimal_seq::DecimalSeq::right_shift",
  "hash": "608388296789548810016249717027452878830",
  "hash_direct": "120382629418979652624793357440866602453",
  "src": "pub(super) fn right_shift(&mut self, shift: usize) {\n        let mut read_index = 0;\n        let mut write_index = 0;\n        let mut n = 0_u64;\n        #[cfg_attr(kani, kani::loop_invariant( n == 0 || (read_index > 0 && read_index <= self.num_digits + 64 - n.leading_zeros() as usize)))]\n        while (n >> shift) == 0 {\n            if read_index < self.num_digits {\n                n = (10 * n) + self.digits[read_index] as u64;\n                read_index += 1;\n            } else if n == 0 {\n                return;\n            } else {\n                #[cfg_attr(kani, kani::loop_invariant(n > 0 && read_index <= self.num_digits + 64 - n.leading_zeros() as usize && read_index > 0))]\n                while (n >> shift) == 0 {\n                    n *= 10;\n                    read_index += 1;\n                }\n                break;\n            }\n        }\n        self.decimal_point -= read_index as i32 - 1;\n        if self.decimal_point < -Self::DECIMAL_POINT_RANGE {\n            // `self = Self::Default()`, but without the overhead of clearing `digits`.\n            self.num_digits = 0;\n            self.decimal_point = 0;\n            self.truncated = false;\n            return;\n        }\n        let mask = (1_u64 << shift) - 1;\n        #[cfg_attr(kani, kani::loop_invariant(self.num_digits <= Self::MAX_DIGITS &&\n            write_index < read_index &&\n            write_index < Self::MAX_DIGITS - self.num_digits.saturating_sub(read_index)\n        ))]\n        while read_index < self.num_digits {\n            let new_digit = (n >> shift) as u8;\n            n = (10 * (n & mask)) + self.digits[read_index] as u64;\n            read_index += 1;\n            self.digits[write_index] = new_digit;\n            write_index += 1;\n        }\n        #[cfg_attr(kani, kani::loop_invariant(write_index <= Self::MAX_DIGITS))]\n        while n > 0 {\n            let new_digit = (n >> shift) as u8;\n            n = 10 * (n & mask);\n            if write_index < Self::MAX_DIGITS {\n                self.digits[write_index] = new_digit;\n                write_index += 1;\n            } else if new_digit > 0 {\n                self.truncated = true;\n            }\n        }\n        self.num_digits = write_index;\n        self.trim();\n    }",
  "callees": [
    "258820287469578611817448591488600041899",
    "225597411765657792414473578215489856999",
    "98289364377593842548315353617588654034",
    "1401287954468727923311998985611925105518",
    "134553425558737097035764421875440418129",
    "165046526160593314567078115148512297437",
    "11794843469677272946544295805404128504",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "243931809744896974812513529918607549579",
    "1752989996936949203916036071159051010960"
  ]
}
