{
  "file": "core/src/num/dec2flt/lemire.rs",
  "name": "num::dec2flt::lemire::compute_float::<f32>",
  "hash": "789706590710791187117452878530122687743",
  "hash_direct": "106839961759475738411317412440716401057",
  "src": "pub fn compute_float<F: RawFloat>(q: i64, mut w: u64) -> BiasedFp {\n    let fp_zero = BiasedFp::zero_pow2(0);\n    let fp_inf = BiasedFp::zero_pow2(F::INFINITE_POWER);\n    let fp_error = BiasedFp::zero_pow2(-1);\n\n    // Short-circuit if the value can only be a literal 0 or infinity.\n    if w == 0 || q < F::SMALLEST_POWER_OF_TEN as i64 {\n        return fp_zero;\n    } else if q > F::LARGEST_POWER_OF_TEN as i64 {\n        return fp_inf;\n    }\n    // Normalize our significant digits, so the most-significant bit is set.\n    let lz = w.leading_zeros();\n    w <<= lz;\n    let (lo, hi) = compute_product_approx(q, w, F::SIG_BITS as usize + 3);\n    if lo == 0xFFFF_FFFF_FFFF_FFFF {\n        // If we have failed to approximate w x 5^-q with our 128-bit value.\n        // Since the addition of 1 could lead to an overflow which could then\n        // round up over the half-way point, this can lead to improper rounding\n        // of a float.\n        //\n        // However, this can only occur if q âˆˆ [-27, 55]. The upper bound of q\n        // is 55 because 5^55 < 2^128, however, this can only happen if 5^q > 2^64,\n        // since otherwise the product can be represented in 64-bits, producing\n        // an exact result. For negative exponents, rounding-to-even can\n        // only occur if 5^-q < 2^64.\n        //\n        // For detailed explanations of rounding for negative exponents, see\n        // <https://arxiv.org/pdf/2101.11408.pdf#section.9.1>. For detailed\n        // explanations of rounding for positive exponents, see\n        // <https://arxiv.org/pdf/2101.11408.pdf#section.8>.\n        let inside_safe_exponent = (q >= -27) && (q <= 55);\n        if !inside_safe_exponent {\n            return fp_error;\n        }\n    }\n    let upperbit = (hi >> 63) as i32;\n    let mut mantissa = hi >> (upperbit + 64 - F::SIG_BITS as i32 - 3);\n    let mut power2 = power(q as i32) + upperbit - lz as i32 - F::EXP_MIN + 1;\n    if power2 <= 0 {\n        if -power2 + 1 >= 64 {\n            // Have more than 64 bits below the minimum exponent, must be 0.\n            return fp_zero;\n        }\n        // Have a subnormal value.\n        mantissa >>= -power2 + 1;\n        mantissa += mantissa & 1;\n        mantissa >>= 1;\n        power2 = (mantissa >= (1_u64 << F::SIG_BITS)) as i32;\n        return BiasedFp { m: mantissa, p_biased: power2 };\n    }\n    // Need to handle rounding ties. Normally, we need to round up,\n    // but if we fall right in between and we have an even basis, we\n    // need to round down.\n    //\n    // This will only occur if:\n    //  1. The lower 64 bits of the 128-bit representation is 0.\n    //      IE, 5^q fits in single 64-bit word.\n    //  2. The least-significant bit prior to truncated mantissa is odd.\n    //  3. All the bits truncated when shifting to mantissa bits + 1 are 0.\n    //\n    // Or, we may fall between two floats: we are exactly halfway.\n    if lo <= 1\n        && q >= F::MIN_EXPONENT_ROUND_TO_EVEN as i64\n        && q <= F::MAX_EXPONENT_ROUND_TO_EVEN as i64\n        && mantissa & 0b11 == 0b01\n        && (mantissa << (upperbit + 64 - F::SIG_BITS as i32 - 3)) == hi\n    {\n        // Zero the lowest bit, so we don't round up.\n        mantissa &= !1_u64;\n    }\n    // Round-to-even, then shift the significant digits into place.\n    mantissa += mantissa & 1;\n    mantissa >>= 1;\n    if mantissa >= (2_u64 << F::SIG_BITS) {\n        // Rounding up overflowed, so the carry bit is set. Set the\n        // mantissa to 1 (only the implicit, hidden bit is set) and\n        // increase the exponent.\n        mantissa = 1_u64 << F::SIG_BITS;\n        power2 += 1;\n    }\n    // Zero out the hidden bit.\n    mantissa &= !(1_u64 << F::SIG_BITS);\n    if power2 >= F::INFINITE_POWER {\n        // Exponent is above largest normal value, must be infinite.\n        return fp_inf;\n    }\n    BiasedFp { m: mantissa, p_biased: power2 }\n}",
  "callees": [
    "258820287469578611817448591488600041899",
    "124079140710334239353528493759477592936",
    "60763573711029026858639391568773305540",
    "629145951687599873418257489910998052999",
    "1134774619075691336512120415078180903148",
    "79242728783770300391285614254369091785",
    "592548824112144282714422772314322109198",
    "118531085298240041968493098956998850",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "243931809744896974812513529918607549579",
    "1752989996936949203916036071159051010960"
  ]
}
