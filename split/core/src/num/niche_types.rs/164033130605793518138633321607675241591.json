{
  "file": "core/src/num/niche_types.rs",
  "name": "num::niche_types::UsizeNoHighBit::as_inner",
  "hash": "164033130605793518138633321607675241591",
  "hash_direct": "1780134755934384106415832889151097794296",
  "src": "pub const fn as_inner(self) -> $int {\n                // SAFETY: This is a transparent wrapper, so unwrapping it is sound\n                // (Not using `.0` due to MCP#807.)\n                unsafe { crate::mem::transmute(self) }\n            }",
  "macro_backtrace": [
    {
      "callsite": "define_valid_range_type! {\n    pub struct UsizeNoHighBit(usize as usize in 0..=0x7fff_ffff_ffff_ffff);\n    pub struct NonZeroUsizeInner(usize as usize in 1..=0xffff_ffff_ffff_ffff);\n    pub struct NonZeroIsizeInner(isize as usize in 1..=0xffff_ffff_ffff_ffff);\n}",
      "defsite": "macro_rules! define_valid_range_type {\n    ($(\n        $(#[$m:meta])*\n        $vis:vis struct $name:ident($int:ident as $uint:ident in $low:literal..=$high:literal);\n    )+) => {$(\n        #[cfg_attr(flux, flux::opaque)]\n        #[cfg_attr(flux, flux::refined_by(val: int))]\n        #[cfg_attr(flux, flux::invariant($low <= cast(val) && cast(val) <= $high))]\n        #[derive(Clone, Copy, Eq)]\n        #[repr(transparent)]\n        #[rustc_layout_scalar_valid_range_start($low)]\n        #[rustc_layout_scalar_valid_range_end($high)]\n        $(#[$m])*\n        $vis struct $name($int);\n\n        const _: () = {\n            // With the `valid_range` attributes, it's always specified as unsigned\n            assert!(<$uint>::MIN == 0);\n            let ulow: $uint = $low;\n            let uhigh: $uint = $high;\n            assert!(ulow <= uhigh);\n\n            assert!(size_of::<$int>() == size_of::<$uint>());\n        };\n\n        impl $name {\n            #[inline]\n            #[cfg_attr(flux, flux::spec(fn (val: $int) -> Option<Self[{val: cast(val)}]>))]\n            pub const fn new(val: $int) -> Option<Self> {\n                if (val as $uint) >= ($low as $uint) && (val as $uint) <= ($high as $uint) {\n                    // SAFETY: just checked the inclusive range\n                    Some(unsafe { $name(val) })\n                } else {\n                    None\n                }\n            }\n\n            /// Constructs an instance of this type from the underlying integer\n            /// primitive without checking whether its zero.\n            ///\n            /// # Safety\n            /// Immediate language UB if `val` is not within the valid range for this\n            /// type, as it violates the validity invariant.\n            #[inline]\n            #[cfg_attr(flux, flux::spec(fn (val: $int{ $low <= cast(val) && cast(val) <= $high }) -> Self[{val:cast(val)}]))]\n            pub const unsafe fn new_unchecked(val: $int) -> Self {\n                // SAFETY: Caller promised that `val` is within the valid range.\n                unsafe { $name(val) }\n            }\n\n            #[inline]\n            #[cfg_attr(flux, flux::spec(fn (self: Self) -> $int[cast(self.val)] ensures $low <= cast(self.val) && cast(self.val) <= $high))]\n            pub const fn as_inner(self) -> $int {\n                // SAFETY: This is a transparent wrapper, so unwrapping it is sound\n                // (Not using `.0` due to MCP#807.)\n                unsafe { crate::mem::transmute(self) }\n            }\n        }\n\n        // This is required to allow matching a constant.  We don't get it from a derive\n        // because the derived `PartialEq` would do a field projection, which is banned\n        // by <https://github.com/rust-lang/compiler-team/issues/807>.\n        impl StructuralPartialEq for $name {}\n\n        impl PartialEq for $name {\n            #[inline]\n            fn eq(&self, other: &Self) -> bool {\n                self.as_inner() == other.as_inner()\n            }\n        }\n\n        impl Ord for $name {\n            #[inline]\n            fn cmp(&self, other: &Self) -> Ordering {\n                Ord::cmp(&self.as_inner(), &other.as_inner())\n            }\n        }\n\n        impl PartialOrd for $name {\n            #[inline]\n            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n                Some(Ord::cmp(self, other))\n            }\n        }\n\n        impl Hash for $name {\n            // Required method\n            fn hash<H: Hasher>(&self, state: &mut H) {\n                Hash::hash(&self.as_inner(), state);\n            }\n        }\n\n        impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                <$int as fmt::Debug>::fmt(&self.as_inner(), f)\n            }\n        }\n    )+};\n}"
    }
  ]
}
