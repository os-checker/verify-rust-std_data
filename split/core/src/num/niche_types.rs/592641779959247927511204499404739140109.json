{
  "file": "core/src/num/niche_types.rs",
  "name": "<num::niche_types::NonZeroU64Inner as cmp::Eq>::assert_receiver_is_total_eq",
  "hash": "592641779959247927511204499404739140109",
  "hash_direct": "141152225862443195110254977555336470343",
  "src": "Eq",
  "macro_backtrace": [
    {
      "callsite": "Eq",
      "defsite": "pub macro Eq($item:item) {\n    /* compiler built-in */\n}"
    },
    {
      "callsite": "define_valid_range_type! {\n    pub struct NonZeroU8Inner(u8 as u8 in 1..=0xff);\n    pub struct NonZeroU16Inner(u16 as u16 in 1..=0xff_ff);\n    pub struct NonZeroU32Inner(u32 as u32 in 1..=0xffff_ffff);\n    pub struct NonZeroU64Inner(u64 as u64 in 1..=0xffffffff_ffffffff);\n    pub struct NonZeroU128Inner(u128 as u128 in 1..=0xffffffffffffffff_ffffffffffffffff);\n\n    pub struct NonZeroI8Inner(i8 as u8 in 1..=0xff);\n    pub struct NonZeroI16Inner(i16 as u16 in 1..=0xff_ff);\n    pub struct NonZeroI32Inner(i32 as u32 in 1..=0xffff_ffff);\n    pub struct NonZeroI64Inner(i64 as u64 in 1..=0xffffffff_ffffffff);\n    pub struct NonZeroI128Inner(i128 as u128 in 1..=0xffffffffffffffff_ffffffffffffffff);\n\n    pub struct NonZeroCharInner(char as u32 in 1..=0x10ffff);\n}",
      "defsite": "macro_rules! define_valid_range_type {\n    ($(\n        $(#[$m:meta])*\n        $vis:vis struct $name:ident($int:ident as $uint:ident in $low:literal..=$high:literal);\n    )+) => {$(\n        #[cfg_attr(flux, flux::opaque)]\n        #[cfg_attr(flux, flux::refined_by(val: int))]\n        #[cfg_attr(flux, flux::invariant($low <= cast(val) && cast(val) <= $high))]\n        #[derive(Clone, Copy, Eq)]\n        #[repr(transparent)]\n        #[rustc_layout_scalar_valid_range_start($low)]\n        #[rustc_layout_scalar_valid_range_end($high)]\n        $(#[$m])*\n        $vis struct $name($int);\n\n        const _: () = {\n            // With the `valid_range` attributes, it's always specified as unsigned\n            assert!(<$uint>::MIN == 0);\n            let ulow: $uint = $low;\n            let uhigh: $uint = $high;\n            assert!(ulow <= uhigh);\n\n            assert!(size_of::<$int>() == size_of::<$uint>());\n        };\n\n        impl $name {\n            #[inline]\n            #[cfg_attr(flux, flux::spec(fn (val: $int) -> Option<Self[{val: cast(val)}]>))]\n            pub const fn new(val: $int) -> Option<Self> {\n                if (val as $uint) >= ($low as $uint) && (val as $uint) <= ($high as $uint) {\n                    // SAFETY: just checked the inclusive range\n                    Some(unsafe { $name(val) })\n                } else {\n                    None\n                }\n            }\n\n            /// Constructs an instance of this type from the underlying integer\n            /// primitive without checking whether its zero.\n            ///\n            /// # Safety\n            /// Immediate language UB if `val` is not within the valid range for this\n            /// type, as it violates the validity invariant.\n            #[inline]\n            #[cfg_attr(flux, flux::spec(fn (val: $int{ $low <= cast(val) && cast(val) <= $high }) -> Self[{val:cast(val)}]))]\n            pub const unsafe fn new_unchecked(val: $int) -> Self {\n                // SAFETY: Caller promised that `val` is within the valid range.\n                unsafe { $name(val) }\n            }\n\n            #[inline]\n            #[cfg_attr(flux, flux::spec(fn (self: Self) -> $int[cast(self.val)] ensures $low <= cast(self.val) && cast(self.val) <= $high))]\n            pub const fn as_inner(self) -> $int {\n                // SAFETY: This is a transparent wrapper, so unwrapping it is sound\n                // (Not using `.0` due to MCP#807.)\n                unsafe { crate::mem::transmute(self) }\n            }\n        }\n\n        // This is required to allow matching a constant.  We don't get it from a derive\n        // because the derived `PartialEq` would do a field projection, which is banned\n        // by <https://github.com/rust-lang/compiler-team/issues/807>.\n        impl StructuralPartialEq for $name {}\n\n        impl PartialEq for $name {\n            #[inline]\n            fn eq(&self, other: &Self) -> bool {\n                self.as_inner() == other.as_inner()\n            }\n        }\n\n        impl Ord for $name {\n            #[inline]\n            fn cmp(&self, other: &Self) -> Ordering {\n                Ord::cmp(&self.as_inner(), &other.as_inner())\n            }\n        }\n\n        impl PartialOrd for $name {\n            #[inline]\n            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n                Some(Ord::cmp(self, other))\n            }\n        }\n\n        impl Hash for $name {\n            // Required method\n            fn hash<H: Hasher>(&self, state: &mut H) {\n                Hash::hash(&self.as_inner(), state);\n            }\n        }\n\n        impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                <$int as fmt::Debug>::fmt(&self.as_inner(), f)\n            }\n        }\n    )+};\n}"
    }
  ]
}
