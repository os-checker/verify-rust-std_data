{
  "file": "core/src/num/int_macros.rs",
  "name": "num::<impl i32>::overflowing_rem_euclid",
  "hash": "736384317596521665317402457525896150486",
  "hash_direct": "40571856672116452148021679329287020915",
  "src": "pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            if intrinsics::unlikely(rhs == -1) {\n                (0, self == Self::MIN)\n            } else {\n                (self.rem_euclid(rhs), false)\n            }\n        }",
  "macro_backtrace": [
    {
      "callsite": "int_impl! {\n        Self = i32,\n        ActualT = i32,\n        UnsignedT = u32,\n        BITS = 32,\n        BITS_MINUS_ONE = 31,\n        Min = -2147483648,\n        Max = 2147483647,\n        rot = 8,\n        rot_op = \"0x10000b3\",\n        rot_result = \"0xb301\",\n        swap_op = \"0x12345678\",\n        swapped = \"0x78563412\",\n        reversed = \"0x1e6a2c48\",\n        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }",
      "defsite": "macro_rules! int_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        UnsignedT = $UnsignedT:ty,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        Min = $Min:literal,\n        Max = $Max:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type\n        #[doc = concat!(\"(&minus;2<sup>\", $BITS_MINUS_ONE, \"</sup>\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, \", stringify!($Min), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = !Self::MAX;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS_MINUS_ONE, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($Max), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = <$UnsignedT>::BITS;\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b100_0000\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.count_ones(), 1);\n        /// ```\n        ///\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.count_zeros(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            (self as $UnsignedT).leading_zeros()\n        }\n\n        /// Returns the number of trailing zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -4\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_zeros(), 2);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            (self as $UnsignedT).trailing_zeros()\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (self as $UnsignedT).leading_ones()\n        }\n\n        /// Returns the number of trailing ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 3\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_ones(), 2);\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (self as $UnsignedT).trailing_ones()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as an unsigned integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_unsigned(), \", stringify!($UnsignedT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_unsigned(self) -> $UnsignedT {\n            self as $UnsignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_left(n) as Self\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_right(n) as Self\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        ///\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            (self as $UnsignedT).swap_bytes() as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            (self as $UnsignedT).reverse_bits() as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), Some(\", stringify!($SelfT), \"::MAX - 1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n        }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(!self.overflowing_add(rhs).1)]\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with an unsigned integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_unsigned(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_unsigned(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_unsigned(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with an unsigned integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_unsigned(2), 3);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_unsigned(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            let (a, b) = self.overflowing_add_unsigned(rhs);\n            if b { overflow_panic::add() } else { a }\n        }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(1), Some(\", stringify!($SelfT), \"::MIN + 1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).strict_sub(1), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MIN + 2).strict_sub(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n        }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(!self.overflowing_sub(rhs).1)] // Preconditions: No overflow should occur\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with an unsigned integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_unsigned(2), Some(-1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub_unsigned(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_sub_unsigned(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict subtraction with an unsigned integer. Computes `self - rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub_unsigned(2), -1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MIN + 2).strict_sub_unsigned(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            let (a, b) = self.overflowing_sub_unsigned(rhs);\n            if b { overflow_panic::sub() } else { a }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(1), Some(\", stringify!($SelfT), \"::MAX));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.strict_mul(1), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n        }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(!self.overflowing_mul(rhs).1)]\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\n        /// or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_div(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {\n                None\n            } else {\n                // SAFETY: div by zero and by INT_MIN have been checked above\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).strict_div(-1), \", stringify!($Max), \");\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_div(-1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_div(rhs);\n            if b { overflow_panic::div() } else { a }\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`,\n        /// returning `None` if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_div_euclid(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div_euclid(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).strict_div_euclid(-1), \", stringify!($Max), \");\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_div_euclid(-1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_div_euclid(rhs);\n            if b { overflow_panic::div() } else { a }\n        }\n\n        /// Checked integer division without remainder. Computes `self / rhs`,\n        /// returning `None` if `rhs == 0`, the division results in overflow,\n        /// or `self % rhs != 0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(exact_div)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_exact_div(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!((-5\", stringify!($SelfT), \").checked_exact_div(2), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_exact_div(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_exact_div(0), None);\")]\n        /// ```\n        #[unstable(\n            feature = \"exact_div\",\n            issue = \"139911\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_exact_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {\n                None\n            } else {\n                // SAFETY: division by zero and overflow are checked above\n                unsafe {\n                    if intrinsics::unlikely(intrinsics::unchecked_rem(self, rhs) != 0) {\n                        None\n                    } else {\n                        Some(intrinsics::exact_div(self, rhs))\n                    }\n                }\n            }\n        }\n\n        /// Checked integer division without remainder. Computes `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic  if `rhs == 0`, the division results in overflow,\n        /// or `self % rhs != 0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(exact_div)]\n        #[doc = concat!(\"assert_eq!(64\", stringify!($SelfT), \".exact_div(2), 32);\")]\n        #[doc = concat!(\"assert_eq!(64\", stringify!($SelfT), \".exact_div(32), 2);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).exact_div(-1), \", stringify!($Max), \");\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(exact_div)]\n        #[doc = concat!(\"let _ = 65\", stringify!($SelfT), \".exact_div(2);\")]\n        /// ```\n        /// ```should_panic\n        /// #![feature(exact_div)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.exact_div(-1);\")]\n        /// ```\n        #[unstable(\n            feature = \"exact_div\",\n            issue = \"139911\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn exact_div(self, rhs: Self) -> Self {\n            match self.checked_exact_div(rhs) {\n                Some(x) => x,\n                None => panic!(\"Failed to divide without remainder\"),\n            }\n        }\n\n        /// Unchecked integer division without remainder. Computes `self / rhs`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when `rhs == 0`, `self % rhs != 0`, or\n        #[doc = concat!(\"`self == \", stringify!($SelfT), \"::MIN && rhs == -1`,\")]\n        /// i.e. when [`checked_exact_div`](Self::checked_exact_div) would return `None`.\n        #[unstable(\n            feature = \"exact_div\",\n            issue = \"139911\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const unsafe fn unchecked_exact_div(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_exact_div cannot overflow, divide by zero, or leave a remainder\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => rhs > 0 && lhs % rhs == 0 && (lhs != <$SelfT>::MIN || rhs != -1),\n            );\n            // SAFETY: Same precondition\n            unsafe { intrinsics::exact_div(self, rhs) }\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None` if\n        /// `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {\n                None\n            } else {\n                // SAFETY: div by zero and by INT_MIN have been checked above\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`, panicking if\n        /// the division results in overflow.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is `x % y` for `MIN / -1` on a\n        /// signed type (where `MIN` is the negative minimal value), which is invalid due to implementation artifacts.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_rem(2), 1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_rem(-1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_rem(rhs);\n            if b { overflow_panic::rem() } else { a }\n        }\n\n        /// Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean remainder. Computes `self.rem_euclid(rhs)`, panicking if\n        /// the division results in overflow.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is `x % y` for `MIN / -1` on a\n        /// signed type (where `MIN` is the negative minimal value), which is invalid due to implementation artifacts.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_rem_euclid(2), 1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_rem_euclid(-1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_rem_euclid(rhs);\n            if b { overflow_panic::rem() } else { a }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_neg(), Some(-5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Unchecked negation. Computes `-self`, assuming overflow cannot occur.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self == \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_neg`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_neg`]: \", stringify!($SelfT), \"::checked_neg\")]\n        #[unstable(\n            feature = \"unchecked_neg\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(self != $SelfT::MIN)]\n        #[ensures(|result| *result == -self)]\n        pub const unsafe fn unchecked_neg(self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_neg cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                ) => !lhs.overflowing_neg().1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(0, self)\n            }\n        }\n\n        /// Strict negation. Computes `-self`, panicking if `self == MIN`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_neg(), -5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x1\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(rhs < <$ActualT>::BITS)]\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(128);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(rhs < <$ActualT>::BITS)] // i.e. requires the right hand side of the shift (rhs) to be less than the number of bits in the type. This prevents undefined behavior.\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, which yields `0` for a positive number,\n        /// and `-1` for a negative number.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.unbounded_shr(129), -1);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                // A shift by `Self::BITS-1` suffices for signed integers, because the sign bit is copied for each of the shifted bits.\n\n                // SAFETY:\n                // `Self::BITS-1` is guaranteed to be less than `Self::BITS`\n                unsafe { self.unchecked_shr(Self::BITS - 1) }\n            }\n        }\n\n        /// Checked absolute value. Computes `self.abs()`, returning `None` if\n        /// `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-5\", stringify!($SelfT), \").checked_abs(), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_abs(self) -> Option<Self> {\n            if self.is_negative() {\n                self.checked_neg()\n            } else {\n                Some(self)\n            }\n        }\n\n        /// Strict absolute value. Computes `self.abs()`, panicking if\n        /// `self == MIN`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((-5\", stringify!($SelfT), \").strict_abs(), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_abs();\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_abs(self) -> Self {\n            if self.is_negative() {\n                self.strict_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(8\", stringify!($SelfT), \".checked_pow(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            #[safety::loop_invariant(true)]\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(8\", stringify!($SelfT), \".strict_pow(2), 64);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// Returns `None` if `self` is negative.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_isqrt(), Some(3));\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_isqrt(self) -> Option<Self> {\n            if self < 0 {\n                None\n            } else {\n                // SAFETY: Input is nonnegative in this `else` branch.\n                let result = unsafe {\n                    crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT\n                };\n\n                // Inform the optimizer what the range of outputs is. If\n                // testing `core` crashes with no panic message and a\n                // `num::int_sqrt::i*` test failed, it's because your edits\n                // caused these assertions to become false.\n                //\n                // SAFETY: Integer square root is a monotonically nondecreasing\n                // function, which means that increasing the input will never\n                // cause the output to decrease. Thus, since the input for\n                // nonnegative signed integers is bounded by\n                // `[0, <$ActualT>::MAX]`, sqrt(n) will be bounded by\n                // `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n                unsafe {\n                    // SAFETY: `<$ActualT>::MAX` is nonnegative.\n                    const MAX_RESULT: $SelfT = unsafe {\n                        crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT\n                    };\n\n                    crate::hint::assert_unchecked(result >= 0);\n                    crate::hint::assert_unchecked(result <= MAX_RESULT);\n                }\n\n                Some(result)\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n        /// bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(100), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_add(-1), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with an unsigned integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_unsigned(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add_unsigned(100), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            // Overflow can only happen at the upper bound\n            // We cannot use `unwrap_or` here because it is not `const`\n            match self.checked_add_unsigned(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub(100), \", stringify!($SelfT), \"::MIN);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_sub(-1), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating subtraction with an unsigned integer. Computes `self - rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub_unsigned(127), -27);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub_unsigned(100), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            // Overflow can only happen at the lower bound\n            // We cannot use `unwrap_or` here because it is not `const`\n            match self.checked_sub_unsigned(rhs) {\n                Some(x) => x,\n                None => Self::MIN,\n            }\n        }\n\n        /// Saturating integer negation. Computes `-self`, returning `MAX` if `self == MIN`\n        /// instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_neg(), -100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").saturating_neg(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_neg(), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_neg(), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n\n        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_neg(self) -> Self {\n            intrinsics::saturating_sub(0, self)\n        }\n\n        /// Saturating absolute value. Computes `self.abs()`, returning `MAX` if `self ==\n        /// MIN` instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").saturating_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_abs(), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).saturating_abs(), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n\n        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_abs(self) -> Self {\n            if self.is_negative() {\n                self.saturating_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".saturating_mul(12), 120);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_mul(10), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => if (self < 0) == (rhs < 0) {\n                    Self::MAX\n                } else {\n                    Self::MIN\n                }\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_div(-1), \", stringify!($SelfT), \"::MIN + 1);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_div(-1), \", stringify!($SelfT), \"::MAX);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            match self.overflowing_div(rhs) {\n                (result, false) => result,\n                (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow\n            }\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-4\", stringify!($SelfT), \").saturating_pow(3), -64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None if self < 0 && exp % 2 == 1 => Self::MIN,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add(27), 127);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with an unsigned integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add_unsigned(27), 127);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add_unsigned(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub(127), -127);\")]\n        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub(\", stringify!($SelfT), \"::MAX), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with an unsigned integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub_unsigned(127), -127);\")]\n        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), -1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\n        /// the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".wrapping_mul(12), 120);\")]\n        /// assert_eq!(11i8.wrapping_mul(12), -124);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self.overflowing_div(rhs).0\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Wrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\n        /// for the type). This is equivalent to `-MIN`, a positive value that is too large to represent in the\n        /// type. In this case, this method returns `MIN` itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self.overflowing_div_euclid(rhs).0\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// Such wrap-around never actually occurs mathematically; implementation artifacts make `x % y`\n        /// invalid for `MIN / -1` on a signed type (where `MIN` is the negative minimal value). In such a case,\n        /// this function returns `0`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self.overflowing_rem(rhs).0\n        }\n\n        /// Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping around\n        /// at the boundary of the type.\n        ///\n        /// Wrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\n        /// for the type). In this case, this method returns 0.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self.overflowing_rem_euclid(rhs).0\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n        /// of the type.\n        ///\n        /// The only case where such wrapping can occur is when one negates `MIN` on a signed type (where `MIN`\n        /// is the negative minimal value for the type); this is a positive value that is too large to represent\n        /// in the type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), -100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").wrapping_neg(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_neg(), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes\n        /// any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\n        /// the range of the type, rather than the bits shifted out of the LHS being returned to the other end.\n        /// The primitive integer types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(7), -128);\")]\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[ensures(|result| *result == self << (rhs & (Self::BITS - 1)))]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`\n        /// removes any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\n        /// to the range of the type, rather than the bits shifted out of the LHS being returned to the other\n        /// end. The primitive integer types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(7), -1);\")]\n        /// assert_eq!((-128i16).wrapping_shr(64), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[ensures(|result| *result == self >> (rhs & (Self::BITS - 1)))]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n        /// the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one takes the absolute value of the negative\n        /// minimal value for the type; this is a positive value that is too large to represent in the type. In\n        /// such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").wrapping_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_abs(), \", stringify!($SelfT), \"::MIN);\")]\n        /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[allow(unused_attributes)]\n        #[inline]\n        pub const fn wrapping_abs(self) -> Self {\n             if self.is_negative() {\n                 self.wrapping_neg()\n             } else {\n                 self\n             }\n        }\n\n        /// Computes the absolute value of `self` without any wrapping\n        /// or panicking.\n        ///\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".unsigned_abs(), 100\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").unsigned_abs(), 100\", stringify!($UnsignedT), \");\")]\n        /// assert_eq!((-128i8).unsigned_abs(), 128u8);\n        /// ```\n        #[stable(feature = \"unsigned_abs\", since = \"1.51.0\")]\n        #[rustc_const_stable(feature = \"unsigned_abs\", since = \"1.51.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unsigned_abs(self) -> $UnsignedT {\n             self.wrapping_abs() as $UnsignedT\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(4), 81);\")]\n        /// assert_eq!(3i8.wrapping_pow(5), -13);\n        /// assert_eq!(3i8.wrapping_pow(6), -39);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                #[safety::loop_invariant(exp>=1)]\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                #[safety::loop_invariant(true)]\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would have\n        /// occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and checks for overflow.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns a tuple of the sum along with a boolean indicating\n        /// whether an arithmetic overflow would occur. On overflow, the wrapped\n        /// value is returned.\n        ///\n        /// This allows chaining together multiple additions to create a wider\n        /// addition, and can be useful for bignum addition. This method should\n        /// only be used for the most significant word; for the less significant\n        /// words the unsigned method\n        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::carrying_add`]\")]\n        /// should be used.\n        ///\n        /// The output boolean returned by this method is *not* a carry flag,\n        /// and should *not* be added to a more significant word.\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// // Only the most significant word is signed.\n        /// //\n        #[doc = concat!(\"//   10  MAX    (a = 10 × 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// + -5    9    (b = -5 × 2^\", stringify!($BITS), \" + 9)\")]\n        /// // ---------\n        #[doc = concat!(\"//    6    8    (sum = 6 × 2^\", stringify!($BITS), \" + 8)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (10, \", stringify!($UnsignedT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n        /// let carry0 = false;\n        ///\n        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::carrying_add for the less significant words\")]\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        ///\n        #[doc = concat!(\"// \", stringify!($SelfT), \"::carrying_add for the most significant word\")]\n        /// let (sum1, overflow) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(overflow, false);\n        ///\n        /// assert_eq!((sum1, sum0), (6, 8));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic.\n            // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).\n            let (a, b) = self.overflowing_add(rhs);\n            let (c, d) = a.overflowing_add(carry as $SelfT);\n            (c, b != d)\n        }\n\n        /// Calculates `self` + `rhs` with an unsigned `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_unsigned(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_add_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MAX, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_unsigned(3), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n            let rhs = rhs as Self;\n            let (res, overflowed) = self.overflowing_add(rhs);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n        /// would occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and checks for\n        /// overflow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns a tuple of the\n        /// difference along with a boolean indicating whether an arithmetic\n        /// overflow would occur. On overflow, the wrapped value is returned.\n        ///\n        /// This allows chaining together multiple subtractions to create a\n        /// wider subtraction, and can be useful for bignum subtraction. This\n        /// method should only be used for the most significant word; for the\n        /// less significant words the unsigned method\n        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::borrowing_sub`]\")]\n        /// should be used.\n        ///\n        /// The output boolean returned by this method is *not* a borrow flag,\n        /// and should *not* be subtracted from a more significant word.\n        ///\n        /// If the input borrow is false, this method is equivalent to\n        /// [`overflowing_sub`](Self::overflowing_sub).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// // Only the most significant word is signed.\n        /// //\n        #[doc = concat!(\"//    6    8    (a = 6 × 2^\", stringify!($BITS), \" + 8)\")]\n        #[doc = concat!(\"// - -5    9    (b = -5 × 2^\", stringify!($BITS), \" + 9)\")]\n        /// // ---------\n        #[doc = concat!(\"//   10  MAX    (diff = 10 × 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (6, 8);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n        /// let borrow0 = false;\n        ///\n        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::borrowing_sub for the less significant words\")]\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        ///\n        #[doc = concat!(\"// \", stringify!($SelfT), \"::borrowing_sub for the most significant word\")]\n        /// let (diff1, overflow) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(overflow, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (10, \", stringify!($UnsignedT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic.\n            // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).\n            let (a, b) = self.overflowing_sub(rhs);\n            let (c, d) = a.overflowing_sub(borrow as $SelfT);\n            (c, b != d)\n        }\n\n        /// Calculates `self` - `rhs` with an unsigned `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_unsigned(2), (-1, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).overflowing_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MIN, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).overflowing_sub_unsigned(3), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n            let rhs = rhs as Self;\n            let (res, overflowed) = self.overflowing_sub(rhs);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow\n        /// would occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_mul(2), (10, false));\")]\n        /// assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.widening_mul(-2), (4294967286, -1));\n        /// assert_eq!(1_000_000_000i32.widening_mul(-10), (2884901888, -3));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> ($UnsignedT, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.carrying_mul(-2, 0), (4294967286, -1));\n        /// assert_eq!(5i32.carrying_mul(-2, 10), (0, 0));\n        /// assert_eq!(1_000_000_000i32.carrying_mul(-10, 0), (2884901888, -3));\n        /// assert_eq!(1_000_000_000i32.carrying_mul(-10, 10), (2884901898, -3));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX.unsigned_abs() + 1, \", stringify!($SelfT), \"::MAX / 2));\"\n        )]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> ($UnsignedT, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.carrying_mul_add(-2, 0, 0), (4294967286, -1));\n        /// assert_eq!(5i32.carrying_mul_add(-2, 10, 10), (10, 0));\n        /// assert_eq!(1_000_000_000i32.carrying_mul_add(-10, 0, 0), (2884901888, -3));\n        /// assert_eq!(1_000_000_000i32.carrying_mul_add(-10, 10, 10), (2884901908, -3));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($UnsignedT), \"::MAX, \", stringify!($SelfT), \"::MAX / 2));\"\n        )]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> ($UnsignedT, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would occur then self is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div(-1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely((self == Self::MIN) & (rhs == -1)) {\n                (self, true)\n            } else {\n                (self / rhs, false)\n            }\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would occur then `self` is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely((self == Self::MIN) & (rhs == -1)) {\n                (self, true)\n            } else {\n                (self.div_euclid(rhs), false)\n            }\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n        /// arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem(-1), (0, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            if intrinsics::unlikely(rhs == -1) {\n                (0, self == Self::MIN)\n            } else {\n                (self % rhs, false)\n            }\n        }\n\n\n        /// Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n        /// arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            if intrinsics::unlikely(rhs == -1) {\n                (0, self == Self::MIN)\n            } else {\n                (self.rem_euclid(rhs), false)\n            }\n        }\n\n\n        /// Negates self, overflowing if this is equal to the minimum value.\n        ///\n        /// Returns a tuple of the negated version of self along with a boolean indicating whether an overflow\n        /// happened. If `self` is the minimum value (e.g., `i32::MIN` for values of type `i32`), then the\n        /// minimum value will be returned again and `true` will be returned for an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[allow(unused_attributes)]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            if intrinsics::unlikely(self == Self::MIN) {\n                (Self::MIN, true)\n            } else {\n                (-self, false)\n            }\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n        /// value was larger than or equal to the number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT),\".overflowing_shl(4), (0x10, false));\")]\n        /// assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n        /// value was larger than or equal to the number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        /// assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// Returns a tuple of the absolute version of self along with a boolean indicating whether an overflow\n        /// happened. If self is the minimum value\n        #[doc = concat!(\"(e.g., \", stringify!($SelfT), \"::MIN for values of type \", stringify!($SelfT), \"),\")]\n        /// then the minimum value will be returned again and true will be returned\n        /// for an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".overflowing_abs(), (10, false));\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").overflowing_abs(), (10, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_abs(), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_abs(self) -> (Self, bool) {\n            (self.wrapping_abs(), self == Self::MIN)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(4), (81, false));\")]\n        /// assert_eq!(3i8.overflowing_pow(5), (-13, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0 {\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let x: \", stringify!($SelfT), \" = 2; // or any other integer type\")]\n        ///\n        /// assert_eq!(x.pow(5), 32);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is negative.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn isqrt(self) -> Self {\n            match self.checked_isqrt() {\n                Some(sqrt) => sqrt,\n                None => crate::num::int_sqrt::panic_for_negative_argument(),\n            }\n        }\n\n        /// Calculates the quotient of Euclidean division of `self` by `rhs`.\n        ///\n        /// This computes the integer `q` such that `self = q * rhs + r`, with\n        /// `r = self.rem_euclid(rhs)` and `0 <= r < abs(rhs)`.\n        ///\n        /// In other words, the result is `self / rhs` rounded to the integer `q`\n        /// such that `self >= q * rhs`.\n        /// If `self > 0`, this is equal to rounding towards zero (the default in Rust);\n        /// if `self < 0`, this is equal to rounding away from zero (towards +/- infinity).\n        /// If `rhs > 0`, this is equal to rounding towards -infinity;\n        /// if `rhs < 0`, this is equal to rounding towards +infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\")]\n        /// let b = 4;\n        ///\n        /// assert_eq!(a.div_euclid(b), 1); // 7 >= 4 * 1\n        /// assert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\n        /// assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n        /// assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            let q = self / rhs;\n            if self % rhs < 0 {\n                return if rhs > 0 { q - 1 } else { q + 1 }\n            }\n            q\n        }\n\n\n        /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n        ///\n        /// This is done as if by the Euclidean division algorithm -- given\n        /// `r = self.rem_euclid(rhs)`, the result satisfies\n        /// `self = rhs * self.div_euclid(rhs) + r` and `0 <= r < abs(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN` and\n        /// `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\")]\n        /// let b = 4;\n        ///\n        /// assert_eq!(a.rem_euclid(b), 3);\n        /// assert_eq!((-a).rem_euclid(b), 1);\n        /// assert_eq!(a.rem_euclid(-b), 3);\n        /// assert_eq!((-a).rem_euclid(-b), 1);\n        /// ```\n        ///\n        /// This will panic:\n        /// ```should_panic\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.rem_euclid(-1);\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            let r = self % rhs;\n            if r < 0 {\n                // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.\n                // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow\n                // and is clearly equivalent, because `r` is negative.\n                // Otherwise, `rhs` is `Self::MIN`, then we have\n                // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates\n                // to `r.wrapping_add(Self::MIN)`, which is equivalent to\n                // `r - Self::MIN`, which is what we wanted (and will not overflow\n                // for negative `r`).\n                r.wrapping_add(rhs.wrapping_abs())\n            } else {\n                r\n            }\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n        /// let b = 3;\n        ///\n        /// assert_eq!(a.div_floor(b), 2);\n        /// assert_eq!(a.div_floor(-b), -3);\n        /// assert_eq!((-a).div_floor(b), -3);\n        /// assert_eq!((-a).div_floor(-b), 2);\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n\n            // If the remainder is non-zero, we need to subtract one if the\n            // signs of self and rhs differ, as this means we rounded upwards\n            // instead of downwards. We do this branchlessly by creating a mask\n            // which is all-ones iff the signs differ, and 0 otherwise. Then by\n            // adding this mask (which corresponds to the signed value -1), we\n            // get our correction.\n            let correction = (self ^ rhs) >> (Self::BITS - 1);\n            if r != 0 {\n                d + correction\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n        /// let b = 3;\n        ///\n        /// assert_eq!(a.div_ceil(b), 3);\n        /// assert_eq!(a.div_ceil(-b), -2);\n        /// assert_eq!((-a).div_ceil(b), -2);\n        /// assert_eq!((-a).div_ceil(-b), 3);\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n\n            // When remainder is non-zero we have a.div_ceil(b) == 1 + a.div_floor(b),\n            // so we can re-use the algorithm from div_floor, just adding 1.\n            let correction = 1 + ((self ^ rhs) >> (Self::BITS - 1));\n            if r != 0 {\n                d + correction\n            } else {\n                d\n            }\n        }\n\n        /// If `rhs` is positive, calculates the smallest value greater than or\n        /// equal to `self` that is a multiple of `rhs`. If `rhs` is negative,\n        /// calculates the largest value less than or equal to `self` that is a\n        /// multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(-8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(-8), -24);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            // This would otherwise fail when calculating `r` when self == T::MIN.\n            if rhs == -1 {\n                return self;\n            }\n\n            let r = self % rhs;\n            let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n                r + rhs\n            } else {\n                r\n            };\n\n            if m == 0 {\n                self\n            } else {\n                self + (rhs - m)\n            }\n        }\n\n        /// If `rhs` is positive, calculates the smallest value greater than or\n        /// equal to `self` that is a multiple of `rhs`. If `rhs` is negative,\n        /// calculates the largest value less than or equal to `self` that is a\n        /// multiple of `rhs`. Returns `None` if `rhs` is zero or the operation\n        /// would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(-8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(-8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").checked_next_multiple_of(8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").checked_next_multiple_of(8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").checked_next_multiple_of(-8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").checked_next_multiple_of(-8), Some(-24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            // This would otherwise fail when calculating `r` when self == T::MIN.\n            if rhs == -1 {\n                return Some(self);\n            }\n\n            let r = try_opt!(self.checked_rem(rhs));\n            let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n                // r + rhs cannot overflow because they have opposite signs\n                r + rhs\n            } else {\n                r\n            };\n\n            if m == 0 {\n                Some(self)\n            } else {\n                // rhs - m cannot overflow because m has the same sign as rhs\n                self.checked_add(rhs - m)\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero,\n        /// or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else {\n                // Delegate to the unsigned implementation.\n                // The condition makes sure that both casts are exact.\n                (self as $UnsignedT).checked_ilog(base as $UnsignedT)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            if self <= 0 {\n                None\n            } else {\n                // SAFETY: We just checked that this number is positive\n                let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };\n                Some(log)\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            if self > 0 {\n                Some(int_log10::$ActualT(self as $ActualT))\n            } else {\n                None\n            }\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// # Overflow behavior\n        ///\n        /// The absolute value of\n        #[doc = concat!(\"`\", stringify!($SelfT), \"::MIN`\")]\n        /// cannot be represented as an\n        #[doc = concat!(\"`\", stringify!($SelfT), \"`,\")]\n        /// and attempting to calculate it will cause an overflow. This means\n        /// that code in debug mode will trigger a panic on this case and\n        /// optimized code will return\n        #[doc = concat!(\"`\", stringify!($SelfT), \"::MIN`\")]\n        /// without a panic. If you do not want this behavior, consider\n        /// using [`unsigned_abs`](Self::unsigned_abs) instead.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".abs(), 10);\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[allow(unused_attributes)]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn abs(self) -> Self {\n            // Note that the #[rustc_inherit_overflow_checks] and #[inline]\n            // above mean that the overflow semantics of the subtraction\n            // depend on the crate we're being called from.\n            if self.is_negative() {\n                -self\n            } else {\n                self\n            }\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// This function always returns the correct answer without overflow or\n        /// panics by returning an unsigned integer.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").abs_diff(80), 180\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").abs_diff(-120), 20\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.abs_diff(\", stringify!($SelfT), \"::MAX), \", stringify!($UnsignedT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> $UnsignedT {\n            if self < other {\n                // Converting a non-negative x from signed to unsigned by using\n                // `x as U` is left unchanged, but a negative x is converted\n                // to value x + 2^N. Thus if `s` and `o` are binary variables\n                // respectively indicating whether `self` and `other` are\n                // negative, we are computing the mathematical value:\n                //\n                //    (other + o*2^N) - (self + s*2^N)    mod  2^N\n                //    other - self + (o-s)*2^N            mod  2^N\n                //    other - self                        mod  2^N\n                //\n                // Finally, taking the mod 2^N of the mathematical value of\n                // `other - self` does not change it as it already is\n                // in the range [0, 2^N).\n                (other as $UnsignedT).wrapping_sub(self as $UnsignedT)\n            } else {\n                (self as $UnsignedT).wrapping_sub(other as $UnsignedT)\n            }\n        }\n\n        /// Returns a number representing sign of `self`.\n        ///\n        ///  - `0` if the number is zero\n        ///  - `1` if the number is positive\n        ///  - `-1` if the number is negative\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".signum(), 1);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".signum(), 0);\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").signum(), -1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_sign\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn signum(self) -> Self {\n            // Picking the right way to phrase this is complicated\n            // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)\n            // so delegate it to `Ord` which is already producing -1/0/+1\n            // exactly like we need and can be the place to deal with the complexity.\n\n            crate::intrinsics::three_way_compare(self, 0) as Self\n        }\n\n        /// Returns `true` if `self` is positive and `false` if the number is zero or\n        /// negative.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(10\", stringify!($SelfT), \".is_positive());\")]\n        #[doc = concat!(\"assert!(!(-10\", stringify!($SelfT), \").is_positive());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_positive(self) -> bool { self > 0 }\n\n        /// Returns `true` if `self` is negative and `false` if the number is zero or\n        /// positive.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert!((-10\", stringify!($SelfT), \").is_negative());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_negative());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_negative(self) -> bool { self < 0 }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[allow(unnecessary_transmutes)]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates an integer value from its representation as a byte array in\n        /// big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates an integer value from its representation as a byte array in\n        /// little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates an integer value from its memory representation as a byte\n        /// array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes)]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes)]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[allow(unnecessary_transmutes)]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline(always)]\n        #[rustc_promotable]\n        #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self {\n            Self::MIN\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline(always)]\n        #[rustc_promotable]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self {\n            Self::MAX\n        }\n    }\n}"
    }
  ],
  "callees": [
    "111425599901702694743874629435682172347",
    "714811817540972740211524868124730226803",
    "79307503347131170578315604022567527135",
    "39174434886231383334682429144756173831",
    "45465200458951020712268855471874148461",
    "47001780835025045275641180846124067173",
    "10276831356989197177291225683156882265",
    "145583995108105043133401862026582368143"
  ]
}
