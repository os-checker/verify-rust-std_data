{
  "file": "core/src/num/bignum.rs",
  "name": "num::bignum::tests::Big8x3::from_small",
  "hash": "164529263798971822246512196965964349380",
  "hash_direct": "7251809016543284123357979030800482009",
  "src": "pub fn from_small(v: $ty) -> $name {\n                let mut base = [0; $n];\n                base[0] = v;\n                $name { size: 1, base }\n            }",
  "macro_backtrace": [
    {
      "callsite": "define_bignum!(Big8x3: type=u8, n=3)",
      "defsite": "macro_rules! define_bignum {\n    ($name:ident: type=$ty:ty, n=$n:expr) => {\n        /// Stack-allocated arbitrary-precision (up to certain limit) integer.\n        ///\n        /// This is backed by a fixed-size array of given type (\"digit\").\n        /// While the array is not very large (normally some hundred bytes),\n        /// copying it recklessly may result in the performance hit.\n        /// Thus this is intentionally not `Copy`.\n        ///\n        /// All operations available to bignums panic in the case of overflows.\n        /// The caller is responsible to use large enough bignum types.\n        pub struct $name {\n            /// One plus the offset to the maximum \"digit\" in use.\n            /// This does not decrease, so be aware of the computation order.\n            /// `base[size..]` should be zero.\n            size: usize,\n            /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n            /// where `W` is the number of bits in the digit type.\n            base: [$ty; $n],\n        }\n\n        impl $name {\n            /// Makes a bignum from one digit.\n            pub fn from_small(v: $ty) -> $name {\n                let mut base = [0; $n];\n                base[0] = v;\n                $name { size: 1, base }\n            }\n\n            /// Makes a bignum from `u64` value.\n            pub fn from_u64(mut v: u64) -> $name {\n                let mut base = [0; $n];\n                let mut sz = 0;\n                while v > 0 {\n                    base[sz] = v as $ty;\n                    v >>= <$ty>::BITS;\n                    sz += 1;\n                }\n                $name { size: sz, base }\n            }\n\n            /// Returns the internal digits as a slice `[a, b, c, ...]` such that the numeric\n            /// value is `a + b * 2^W + c * 2^(2W) + ...` where `W` is the number of bits in\n            /// the digit type.\n            pub fn digits(&self) -> &[$ty] {\n                &self.base[..self.size]\n            }\n\n            /// Returns the `i`-th bit where bit 0 is the least significant one.\n            /// In other words, the bit with weight `2^i`.\n            pub fn get_bit(&self, i: usize) -> u8 {\n                let digitbits = <$ty>::BITS as usize;\n                let d = i / digitbits;\n                let b = i % digitbits;\n                ((self.base[d] >> b) & 1) as u8\n            }\n\n            /// Returns `true` if the bignum is zero.\n            pub fn is_zero(&self) -> bool {\n                self.digits().iter().all(|&v| v == 0)\n            }\n\n            /// Returns the number of bits necessary to represent this value. Note that zero\n            /// is considered to need 0 bits.\n            pub fn bit_length(&self) -> usize {\n                let digitbits = <$ty>::BITS as usize;\n                let digits = self.digits();\n                // Find the most significant non-zero digit.\n                let msd = digits.iter().rposition(|&x| x != 0);\n                match msd {\n                    Some(msd) => msd * digitbits + digits[msd].ilog2() as usize + 1,\n                    // There are no non-zero digits, i.e., the number is zero.\n                    _ => 0,\n                }\n            }\n\n            /// Adds `other` to itself and returns its own mutable reference.\n            pub fn add<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n                use crate::{cmp, iter};\n\n                let mut sz = cmp::max(self.size, other.size);\n                let mut carry = false;\n                for (a, b) in iter::zip(&mut self.base[..sz], &other.base[..sz]) {\n                    let (v, c) = (*a).carrying_add(*b, carry);\n                    *a = v;\n                    carry = c;\n                }\n                if carry {\n                    self.base[sz] = 1;\n                    sz += 1;\n                }\n                self.size = sz;\n                self\n            }\n\n            pub fn add_small(&mut self, other: $ty) -> &mut $name {\n                let (v, mut carry) = self.base[0].carrying_add(other, false);\n                self.base[0] = v;\n                let mut i = 1;\n                while carry {\n                    let (v, c) = self.base[i].carrying_add(0, carry);\n                    self.base[i] = v;\n                    carry = c;\n                    i += 1;\n                }\n                if i > self.size {\n                    self.size = i;\n                }\n                self\n            }\n\n            /// Subtracts `other` from itself and returns its own mutable reference.\n            pub fn sub<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n                use crate::{cmp, iter};\n\n                let sz = cmp::max(self.size, other.size);\n                let mut noborrow = true;\n                for (a, b) in iter::zip(&mut self.base[..sz], &other.base[..sz]) {\n                    let (v, c) = (*a).carrying_add(!*b, noborrow);\n                    *a = v;\n                    noborrow = c;\n                }\n                assert!(noborrow);\n                self.size = sz;\n                self\n            }\n\n            /// Multiplies itself by a digit-sized `other` and returns its own\n            /// mutable reference.\n            pub fn mul_small(&mut self, other: $ty) -> &mut $name {\n                let mut sz = self.size;\n                let mut carry = 0;\n                for a in &mut self.base[..sz] {\n                    let (v, c) = (*a).carrying_mul(other, carry);\n                    *a = v;\n                    carry = c;\n                }\n                if carry > 0 {\n                    self.base[sz] = carry;\n                    sz += 1;\n                }\n                self.size = sz;\n                self\n            }\n\n            /// Multiplies itself by `2^bits` and returns its own mutable reference.\n            pub fn mul_pow2(&mut self, bits: usize) -> &mut $name {\n                let digitbits = <$ty>::BITS as usize;\n                let digits = bits / digitbits;\n                let bits = bits % digitbits;\n\n                assert!(digits < $n);\n                debug_assert!(self.base[$n - digits..].iter().all(|&v| v == 0));\n                debug_assert!(bits == 0 || (self.base[$n - digits - 1] >> (digitbits - bits)) == 0);\n\n                // shift by `digits * digitbits` bits\n                for i in (0..self.size).rev() {\n                    self.base[i + digits] = self.base[i];\n                }\n                for i in 0..digits {\n                    self.base[i] = 0;\n                }\n\n                // shift by `bits` bits\n                let mut sz = self.size + digits;\n                if bits > 0 {\n                    let last = sz;\n                    let overflow = self.base[last - 1] >> (digitbits - bits);\n                    if overflow > 0 {\n                        self.base[last] = overflow;\n                        sz += 1;\n                    }\n                    for i in (digits + 1..last).rev() {\n                        self.base[i] =\n                            (self.base[i] << bits) | (self.base[i - 1] >> (digitbits - bits));\n                    }\n                    self.base[digits] <<= bits;\n                    // self.base[..digits] is zero, no need to shift\n                }\n\n                self.size = sz;\n                self\n            }\n\n            /// Multiplies itself by `5^e` and returns its own mutable reference.\n            pub fn mul_pow5(&mut self, mut e: usize) -> &mut $name {\n                use crate::num::bignum::SMALL_POW5;\n\n                // There are exactly n trailing zeros on 2^n, and the only relevant digit sizes\n                // are consecutive powers of two, so this is well suited index for the table.\n                let table_index = size_of::<$ty>().trailing_zeros() as usize;\n                let (small_power, small_e) = SMALL_POW5[table_index];\n                let small_power = small_power as $ty;\n\n                // Multiply with the largest single-digit power as long as possible ...\n                while e >= small_e {\n                    self.mul_small(small_power);\n                    e -= small_e;\n                }\n\n                // ... then finish off the remainder.\n                let mut rest_power = 1;\n                for _ in 0..e {\n                    rest_power *= 5;\n                }\n                self.mul_small(rest_power);\n\n                self\n            }\n\n            /// Multiplies itself by a number described by `other[0] + other[1] * 2^W +\n            /// other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)\n            /// and returns its own mutable reference.\n            pub fn mul_digits<'a>(&'a mut self, other: &[$ty]) -> &'a mut $name {\n                // the internal routine. works best when aa.len() <= bb.len().\n                fn mul_inner(ret: &mut [$ty; $n], aa: &[$ty], bb: &[$ty]) -> usize {\n                    use crate::num::bignum::FullOps;\n\n                    let mut retsz = 0;\n                    for (i, &a) in aa.iter().enumerate() {\n                        if a == 0 {\n                            continue;\n                        }\n                        let mut sz = bb.len();\n                        let mut carry = 0;\n                        for (j, &b) in bb.iter().enumerate() {\n                            let (c, v) = a.full_mul_add(b, ret[i + j], carry);\n                            ret[i + j] = v;\n                            carry = c;\n                        }\n                        if carry > 0 {\n                            ret[i + sz] = carry;\n                            sz += 1;\n                        }\n                        if retsz < i + sz {\n                            retsz = i + sz;\n                        }\n                    }\n                    retsz\n                }\n\n                let mut ret = [0; $n];\n                let retsz = if self.size < other.len() {\n                    mul_inner(&mut ret, &self.digits(), other)\n                } else {\n                    mul_inner(&mut ret, other, &self.digits())\n                };\n                self.base = ret;\n                self.size = retsz;\n                self\n            }\n\n            /// Divides itself by a digit-sized `other` and returns its own\n            /// mutable reference *and* the remainder.\n            pub fn div_rem_small(&mut self, other: $ty) -> (&mut $name, $ty) {\n                use crate::num::bignum::FullOps;\n\n                assert!(other > 0);\n\n                let sz = self.size;\n                let mut borrow = 0;\n                for a in self.base[..sz].iter_mut().rev() {\n                    let (q, r) = (*a).full_div_rem(other, borrow);\n                    *a = q;\n                    borrow = r;\n                }\n                (self, borrow)\n            }\n\n            /// Divide self by another bignum, overwriting `q` with the quotient and `r` with the\n            /// remainder.\n            pub fn div_rem(&self, d: &$name, q: &mut $name, r: &mut $name) {\n                // Stupid slow base-2 long division taken from\n                // https://en.wikipedia.org/wiki/Division_algorithm\n                // FIXME use a greater base ($ty) for the long division.\n                assert!(!d.is_zero());\n                let digitbits = <$ty>::BITS as usize;\n                for digit in &mut q.base[..] {\n                    *digit = 0;\n                }\n                for digit in &mut r.base[..] {\n                    *digit = 0;\n                }\n                r.size = d.size;\n                q.size = 1;\n                let mut q_is_zero = true;\n                let end = self.bit_length();\n                for i in (0..end).rev() {\n                    r.mul_pow2(1);\n                    r.base[0] |= self.get_bit(i) as $ty;\n                    if &*r >= d {\n                        r.sub(d);\n                        // Set bit `i` of q to 1.\n                        let digit_idx = i / digitbits;\n                        let bit_idx = i % digitbits;\n                        if q_is_zero {\n                            q.size = digit_idx + 1;\n                            q_is_zero = false;\n                        }\n                        q.base[digit_idx] |= 1 << bit_idx;\n                    }\n                }\n                debug_assert!(q.base[q.size..].iter().all(|&d| d == 0));\n                debug_assert!(r.base[r.size..].iter().all(|&d| d == 0));\n            }\n        }\n\n        impl crate::cmp::PartialEq for $name {\n            fn eq(&self, other: &$name) -> bool {\n                self.base[..] == other.base[..]\n            }\n        }\n\n        impl crate::cmp::Eq for $name {}\n\n        impl crate::cmp::PartialOrd for $name {\n            fn partial_cmp(&self, other: &$name) -> crate::option::Option<crate::cmp::Ordering> {\n                crate::option::Option::Some(self.cmp(other))\n            }\n        }\n\n        impl crate::cmp::Ord for $name {\n            fn cmp(&self, other: &$name) -> crate::cmp::Ordering {\n                use crate::cmp::max;\n                let sz = max(self.size, other.size);\n                let lhs = self.base[..sz].iter().cloned().rev();\n                let rhs = other.base[..sz].iter().cloned().rev();\n                lhs.cmp(rhs)\n            }\n        }\n\n        impl crate::clone::Clone for $name {\n            fn clone(&self) -> Self {\n                Self { size: self.size, base: self.base }\n            }\n        }\n\n        impl crate::clone::UseCloned for $name {}\n\n        impl crate::fmt::Debug for $name {\n            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n                let sz = if self.size < 1 { 1 } else { self.size };\n                let digitlen = <$ty>::BITS as usize / 4;\n\n                write!(f, \"{:#x}\", self.base[sz - 1])?;\n                for &v in self.base[..sz - 1].iter().rev() {\n                    write!(f, \"_{:01$x}\", v, digitlen)?;\n                }\n                crate::result::Result::Ok(())\n            }\n        }\n    };\n}"
    }
  ]
}
