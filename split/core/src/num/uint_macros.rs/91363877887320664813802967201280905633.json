{
  "file": "core/src/num/uint_macros.rs",
  "name": "num::<impl u64>::strict_shl",
  "hash": "91363877887320664813802967201280905633",
  "hash_direct": "127468803555532657078503452538713201378",
  "src": "pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }",
  "macro_backtrace": [
    {
      "callsite": "uint_impl! {\n        Self = u64,\n        ActualT = u64,\n        SignedT = i64,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }",
      "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns the minimum number of bits required to represent `self`.\n        ///\n        /// This method returns zero if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(uint_bit_width)]\n        ///\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".bit_width(), 0);\")]\n        #[doc = concat!(\"assert_eq!(0b111_\", stringify!($SelfT), \".bit_width(), 3);\")]\n        #[doc = concat!(\"assert_eq!(0b1110_\", stringify!($SelfT), \".bit_width(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.bit_width(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[unstable(feature = \"uint_bit_width\", issue = \"142326\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn bit_width(self) -> u32 {\n            Self::BITS - self.leading_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_highest_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_highest_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_highest_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_lowest_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_lowest_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_lowest_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n        }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(!self.overflowing_add(rhs).1)]\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n        }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n        }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(!self.overflowing_sub(rhs).1)] // Preconditions: No overflow should occur\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops_unsigned_sub\", since = \"1.90.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops_unsigned_sub\", since = \"1.90.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Strict subtraction with a signed integer. Computes `self - rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".strict_sub_signed(2), 1);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_sub_signed(2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX).strict_sub_signed(-1);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_sub_signed(rhs);\n            if b { overflow_panic::sub() } else { a }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[stable(feature = \"unsigned_signed_diff\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_signed_diff\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n        }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(!self.overflowing_mul(rhs).1)]\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer division without remainder. Computes `self / rhs`,\n        /// returning `None` if `rhs == 0` or if `self % rhs != 0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(exact_div)]\n        #[doc = concat!(\"assert_eq!(64\", stringify!($SelfT), \".checked_exact_div(2), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(64\", stringify!($SelfT), \".checked_exact_div(32), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(64\", stringify!($SelfT), \".checked_exact_div(0), None);\")]\n        #[doc = concat!(\"assert_eq!(65\", stringify!($SelfT), \".checked_exact_div(2), None);\")]\n        /// ```\n        #[unstable(\n            feature = \"exact_div\",\n            issue = \"139911\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_exact_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: division by zero is checked above\n                unsafe {\n                    if intrinsics::unlikely(intrinsics::unchecked_rem(self, rhs) != 0) {\n                        None\n                    } else {\n                        Some(intrinsics::exact_div(self, rhs))\n                    }\n                }\n            }\n        }\n\n        /// Checked integer division without remainder. Computes `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic  if `rhs == 0` or `self % rhs != 0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(exact_div)]\n        #[doc = concat!(\"assert_eq!(64\", stringify!($SelfT), \".exact_div(2), 32);\")]\n        #[doc = concat!(\"assert_eq!(64\", stringify!($SelfT), \".exact_div(32), 2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(exact_div)]\n        #[doc = concat!(\"let _ = 65\", stringify!($SelfT), \".exact_div(2);\")]\n        /// ```\n        #[unstable(\n            feature = \"exact_div\",\n            issue = \"139911\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn exact_div(self, rhs: Self) -> Self {\n            match self.checked_exact_div(rhs) {\n                Some(x) => x,\n                None => panic!(\"Failed to divide without remainder\"),\n            }\n        }\n\n        /// Unchecked integer division without remainder. Computes `self / rhs`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when `rhs == 0` or `self % rhs != 0`,\n        /// i.e. when [`checked_exact_div`](Self::checked_exact_div) would return `None`.\n        #[unstable(\n            feature = \"exact_div\",\n            issue = \"139911\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const unsafe fn unchecked_exact_div(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_exact_div divide by zero or leave a remainder\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => rhs > 0 && lhs % rhs == 0,\n            );\n            // SAFETY: Same precondition\n            unsafe { intrinsics::exact_div(self, rhs) }\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        #[requires((self & other) == 0)]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for ⌊log(base,self)⌋ because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                ≥ ⌊log(2,self)⌋ / (⌊log(2,base)⌋ + 1)\n                    //\n                    // hence\n                    //\n                    // ⌊log(base,self)⌋ ≥ ⌊ ⌊log(2,self)⌋ / (⌊log(2,base)⌋ + 1) ⌋ .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(rhs < <$ActualT>::BITS)]\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        #[requires(rhs < <$ActualT>::BITS)]// i.e. requires the right hand side of the shift (rhs) to be less than the number of bits in the type. This prevents undefined behavior.\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            #[safety::loop_invariant(true)]\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"strict_overflow_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops_unsigned_sub\", since = \"1.90.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops_unsigned_sub\", since = \"1.90.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops_unsigned_sub\", since = \"1.90.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops_unsigned_sub\", since = \"1.90.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[ensures(|result| *result == self << (rhs & (Self::BITS - 1)))]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[ensures(|result| *result == self >> (rhs & (Self::BITS - 1)))]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                #[safety::loop_invariant(exp>=1)]\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                #[safety::loop_invariant(true)]\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3 × 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5 × 2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9 × 2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9 × 2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5 × 2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3 × 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops_unsigned_sub\", since = \"1.90.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops_unsigned_sub\", since = \"1.90.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).unsigned_abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n²) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            #[safety::loop_invariant(true)]\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"1.87.0\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some unsigned integer `k`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[allow(unnecessary_transmutes)]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[allow(unnecessary_transmutes)]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
    }
  ],
  "callees": [
    "258820287469578611817448591488600041899",
    "17421822894816687532325615181214565887",
    "23815256893174302637797703719499456373",
    "290609851857017803814021177754696512679",
    "442690259344920482714102155253002992727",
    "1108081449592419884016838652365169397119",
    "97244087392592679868638070082735584826",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "1752989996936949203916036071159051010960",
    "478753423337745817613297159272845606672",
    "201774631661856202013381004016496631198",
    "739520556846959085018120036998133255835"
  ]
}
