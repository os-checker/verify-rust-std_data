{
  "file": "core/src/num/nonzero.rs",
  "name": "<num::nonzero::NonZero<i8> as str::traits::FromStr>::from_str",
  "hash": "161464624945302678077942412127995248400",
  "hash_direct": "387760140714476082214110621752954401378",
  "src": "fn from_str(src: &str) -> Result<Self, Self::Err> {\n                Self::new(<$Int>::from_str_radix(src, 10)?)\n                    .ok_or(ParseIntError {\n                        kind: IntErrorKind::Zero\n                    })\n            }",
  "macro_backtrace": [
    {
      "callsite": "nonzero_integer! {\n            #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\n            Self = $Ty,\n            Primitive = signed $Int,\n            SignedPrimitive = $Int,\n            UnsignedPrimitive = $Uint,\n            rot = $rot,\n            rot_op = $rot_op,\n            rot_result = $rot_result,\n            swap_op = $swap_op,\n            swapped = $swapped,\n            reversed = $reversed,\n            leading_zeros_test = concat!(\"-1\", stringify!($Int)),\n        }",
      "defsite": "macro_rules! nonzero_integer {\n    (\n        #[$stability:meta]\n        Self = $Ty:ident,\n        Primitive = $signedness:ident $Int:ident,\n        SignedPrimitive = $Sint:ty,\n        UnsignedPrimitive = $Uint:ty,\n\n        // Used in doc comments.\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        leading_zeros_test = $leading_zeros_test:expr,\n    ) => {\n        #[doc = sign_dependent_expr!{\n            $signedness ?\n            if signed {\n                concat!(\"An [`\", stringify!($Int), \"`] that is known not to equal zero.\")\n            }\n            if unsigned {\n                concat!(\"A [`\", stringify!($Int), \"`] that is known not to equal zero.\")\n            }\n        }]\n        ///\n        /// This enables some memory layout optimization.\n        #[doc = concat!(\"For example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\")]\n        ///\n        /// ```rust\n        #[doc = concat!(\"assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int), \">());\")]\n        /// ```\n        ///\n        /// # Layout\n        ///\n        #[doc = concat!(\"`\", stringify!($Ty), \"` is guaranteed to have the same layout and bit validity as `\", stringify!($Int), \"`\")]\n        /// with the exception that `0` is not a valid instance.\n        #[doc = concat!(\"`Option<\", stringify!($Ty), \">` is guaranteed to be compatible with `\", stringify!($Int), \"`,\")]\n        /// including in FFI.\n        ///\n        /// Thanks to the [null pointer optimization],\n        #[doc = concat!(\"`\", stringify!($Ty), \"` and `Option<\", stringify!($Ty), \">`\")]\n        /// are guaranteed to have the same size and alignment:\n        ///\n        /// ```\n        #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(size_of::<\", stringify!($Ty), \">(), size_of::<Option<\", stringify!($Ty), \">>());\")]\n        #[doc = concat!(\"assert_eq!(align_of::<\", stringify!($Ty), \">(), align_of::<Option<\", stringify!($Ty), \">>());\")]\n        /// ```\n        ///\n        /// [null pointer optimization]: crate::option#representation\n        #[$stability]\n        pub type $Ty = NonZero<$Int>;\n\n        impl NonZero<$Int> {\n            /// The size of this non-zero integer type in bits.\n            ///\n            #[doc = concat!(\"This value is equal to [`\", stringify!($Int), \"::BITS`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            #[doc = concat!(\"assert_eq!(NonZero::<\", stringify!($Int), \">::BITS, \", stringify!($Int), \"::BITS);\")]\n            /// ```\n            #[stable(feature = \"nonzero_bits\", since = \"1.67.0\")]\n            pub const BITS: u32 = <$Int>::BITS;\n\n            /// Returns the number of leading zeros in the binary representation of `self`.\n            ///\n            /// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::<\", stringify!($Int), \">::new(\", $leading_zeros_test, \")?;\")]\n            ///\n            /// assert_eq!(n.leading_zeros(), 0);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[rustc_const_stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn leading_zeros(self) -> u32 {\n                // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.\n                unsafe {\n                    intrinsics::ctlz_nonzero(self.get() as $Uint)\n                }\n            }\n\n            /// Returns the number of trailing zeros in the binary representation\n            /// of `self`.\n            ///\n            /// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::<\", stringify!($Int), \">::new(0b0101000)?;\")]\n            ///\n            /// assert_eq!(n.trailing_zeros(), 3);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[rustc_const_stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn trailing_zeros(self) -> u32 {\n                // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.\n                unsafe {\n                    intrinsics::cttz_nonzero(self.get() as $Uint)\n                }\n            }\n\n            /// Returns `self` with only the most significant bit set.\n            ///\n            /// # Example\n            ///\n            /// ```\n            /// #![feature(isolate_most_least_significant_one)]\n            ///\n            /// # use core::num::NonZero;\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b_01100100)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b_01000000)?;\")]\n            ///\n            /// assert_eq!(a.isolate_most_significant_one(), b);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn isolate_most_significant_one(self) -> Self {\n                let n = self.get() & (((1 as $Int) << (<$Int>::BITS - 1)).wrapping_shr(self.leading_zeros()));\n\n                // SAFETY:\n                // `self` is non-zero, so masking to preserve only the most\n                // significant set bit will result in a non-zero `n`.\n                unsafe { NonZero::new_unchecked(n) }\n            }\n\n            /// Returns `self` with only the least significant bit set.\n            ///\n            /// # Example\n            ///\n            /// ```\n            /// #![feature(isolate_most_least_significant_one)]\n            ///\n            /// # use core::num::NonZero;\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b_01100100)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b_00000100)?;\")]\n            ///\n            /// assert_eq!(a.isolate_least_significant_one(), b);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn isolate_least_significant_one(self) -> Self {\n                let n = self.get();\n                let n = n & n.wrapping_neg();\n\n                // SAFETY: `self` is non-zero, so `self` with only its least\n                // significant set bit will remain non-zero.\n                unsafe { NonZero::new_unchecked(n) }\n            }\n\n            /// Returns the number of ones in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b100_0000)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b100_0011)?;\")]\n            ///\n            /// assert_eq!(a.count_ones(), NonZero::new(1)?);\n            /// assert_eq!(b.count_ones(), NonZero::new(3)?);\n            /// # Some(())\n            /// # }\n            /// ```\n            ///\n            #[stable(feature = \"non_zero_count_ones\", since = \"1.86.0\")]\n            #[rustc_const_stable(feature = \"non_zero_count_ones\", since = \"1.86.0\")]\n            #[doc(alias = \"popcount\")]\n            #[doc(alias = \"popcnt\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() > 0)]\n            pub const fn count_ones(self) -> NonZero<u32> {\n                // SAFETY:\n                // `self` is non-zero, which means it has at least one bit set, which means\n                // that the result of `count_ones` is non-zero.\n                unsafe { NonZero::new_unchecked(self.get().count_ones()) }\n            }\n\n            /// Shifts the bits to the left by a specified amount, `n`,\n            /// wrapping the truncated bits to the end of the resulting integer.\n            ///\n            /// Please note this isn't the same operation as the `<<` shifting operator!\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $rot_op, stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let m = NonZero::new(\", $rot_result, \")?;\")]\n            ///\n            #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() != 0)]\n            #[ensures(|result| result.rotate_right(n).get() == old(self).get())]\n            pub const fn rotate_left(self, n: u32) -> Self {\n                let result = self.get().rotate_left(n);\n                // SAFETY: Rotating bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Shifts the bits to the right by a specified amount, `n`,\n            /// wrapping the truncated bits to the beginning of the resulting\n            /// integer.\n            ///\n            /// Please note this isn't the same operation as the `>>` shifting operator!\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $rot_result, stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let m = NonZero::new(\", $rot_op, \")?;\")]\n            ///\n            #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() != 0)]\n            #[ensures(|result| result.rotate_left(n).get() == old(self).get())]\n            pub const fn rotate_right(self, n: u32) -> Self {\n                let result = self.get().rotate_right(n);\n                // SAFETY: Rotating bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Reverses the byte order of the integer.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $swap_op, stringify!($Int), \")?;\")]\n            /// let m = n.swap_bytes();\n            ///\n            #[doc = concat!(\"assert_eq!(m, NonZero::new(\", $swapped, \")?);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn swap_bytes(self) -> Self {\n                let result = self.get().swap_bytes();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n            /// second least-significant bit becomes second most-significant bit, etc.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $swap_op, stringify!($Int), \")?;\")]\n            /// let m = n.reverse_bits();\n            ///\n            #[doc = concat!(\"assert_eq!(m, NonZero::new(\", $reversed, \")?);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn reverse_bits(self) -> Self {\n                let result = self.get().reverse_bits();\n                // SAFETY: Reversing bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts an integer from big endian to the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_be(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_be(n), n.swap_bytes())\")]\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use]\n            #[inline(always)]\n            pub const fn from_be(x: Self) -> Self {\n                let result = $Int::from_be(x.get());\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts an integer from little endian to the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_le(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_le(n), n.swap_bytes())\")]\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use]\n            #[inline(always)]\n            pub const fn from_le(x: Self) -> Self {\n                let result = $Int::from_le(x.get());\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts `self` to big endian from the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            ///     assert_eq!(n.to_be(), n)\n            /// } else {\n            ///     assert_eq!(n.to_be(), n.swap_bytes())\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn to_be(self) -> Self {\n                let result = self.get().to_be();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts `self` to little endian from the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            ///     assert_eq!(n.to_le(), n)\n            /// } else {\n            ///     assert_eq!(n.to_le(), n.swap_bytes())\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn to_le(self) -> Self {\n                let result = self.get().to_le();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            nonzero_integer_signedness_dependent_methods! {\n                Primitive = $signedness $Int,\n                SignedPrimitive = $Sint,\n                UnsignedPrimitive = $Uint,\n            }\n\n            /// Multiplies two non-zero integers together.\n            /// Checks for overflow and returns [`None`] on overflow.\n            /// As a consequence, the result cannot wrap to zero.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(Some(four), two.checked_mul(two));\n            /// assert_eq!(None, max.checked_mul(two));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn checked_mul(self, other: Self) -> Option<Self> {\n                if let Some(result) = self.get().checked_mul(other.get()) {\n                    // SAFETY:\n                    // - `checked_mul` returns `None` on overflow\n                    // - `self` and `other` are non-zero\n                    // - the only way to get zero from a multiplication without overflow is for one\n                    //   of the sides to be zero\n                    //\n                    // So the result cannot be zero.\n                    Some(unsafe { Self::new_unchecked(result) })\n                } else {\n                    None\n                }\n            }\n\n            /// Multiplies two non-zero integers together.\n            #[doc = concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(four, two.saturating_mul(two));\n            /// assert_eq!(max, four.saturating_mul(max));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_mul(self, other: Self) -> Self {\n                // SAFETY:\n                // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,\n                //   all of which are non-zero\n                // - `self` and `other` are non-zero\n                // - the only way to get zero from a multiplication without overflow is for one\n                //   of the sides to be zero\n                //\n                // So the result cannot be zero.\n                unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }\n            }\n\n            /// Multiplies two non-zero integers together,\n            /// assuming overflow cannot occur.\n            /// Overflow is unchecked, and it is undefined behavior to overflow\n            /// *even if the result would wrap to a non-zero value*.\n            /// The behavior is undefined as soon as\n            #[doc = sign_dependent_expr!{\n                $signedness ?\n                if signed {\n                    concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`, \",\n                            \"or `self * rhs < \", stringify!($Int), \"::MIN`.\")\n                }\n                if unsigned {\n                    concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`.\")\n                }\n            }]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_ops)]\n            ///\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            ///\n            /// assert_eq!(four, unsafe { two.unchecked_mul(two) });\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            #[requires({\n                self.get().checked_mul(other.get()).is_some()\n            })]\n            #[ensures(|result: &Self| {\n                self.get().checked_mul(other.get()).is_some_and(|product| product == result.get())\n            })]\n            pub const unsafe fn unchecked_mul(self, other: Self) -> Self {\n                // SAFETY: The caller ensures there is no overflow.\n                unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }\n            }\n\n            /// Raises non-zero value to an integer power.\n            /// Checks for overflow and returns [`None`] on overflow.\n            /// As a consequence, the result cannot wrap to zero.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let three = NonZero::new(3\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let twenty_seven = NonZero::new(27\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let half_max = NonZero::new(\", stringify!($Int), \"::MAX / 2)?;\")]\n            ///\n            /// assert_eq!(Some(twenty_seven), three.checked_pow(3));\n            /// assert_eq!(None, half_max.checked_pow(3));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn checked_pow(self, other: u32) -> Option<Self> {\n                if let Some(result) = self.get().checked_pow(other) {\n                    // SAFETY:\n                    // - `checked_pow` returns `None` on overflow/underflow\n                    // - `self` is non-zero\n                    // - the only way to get zero from an exponentiation without overflow is\n                    //   for base to be zero\n                    //\n                    // So the result cannot be zero.\n                    Some(unsafe { Self::new_unchecked(result) })\n                } else {\n                    None\n                }\n            }\n\n            /// Raise non-zero value to an integer power.\n            #[doc = sign_dependent_expr!{\n                $signedness ?\n                if signed {\n                    concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MIN`] \",\n                                \"or [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")\n                }\n                if unsigned {\n                    concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")\n                }\n            }]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let three = NonZero::new(3\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let twenty_seven = NonZero::new(27\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(twenty_seven, three.saturating_pow(3));\n            /// assert_eq!(max, max.saturating_pow(3));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_pow(self, other: u32) -> Self {\n                // SAFETY:\n                // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,\n                //   all of which are non-zero\n                // - `self` is non-zero\n                // - the only way to get zero from an exponentiation without overflow is\n                //   for base to be zero\n                //\n                // So the result cannot be zero.\n                unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }\n            }\n        }\n\n        #[stable(feature = \"nonzero_parse\", since = \"1.35.0\")]\n        impl FromStr for NonZero<$Int> {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, Self::Err> {\n                Self::new(<$Int>::from_str_radix(src, 10)?)\n                    .ok_or(ParseIntError {\n                        kind: IntErrorKind::Zero\n                    })\n            }\n        }\n\n        nonzero_integer_signedness_dependent_impls!($signedness $Int);\n    };\n\n    (\n        Self = $Ty:ident,\n        Primitive = unsigned $Int:ident,\n        SignedPrimitive = $Sint:ident,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        $(,)?\n    ) => {\n        nonzero_integer! {\n            #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n            Self = $Ty,\n            Primitive = unsigned $Int,\n            SignedPrimitive = $Sint,\n            UnsignedPrimitive = $Int,\n            rot = $rot,\n            rot_op = $rot_op,\n            rot_result = $rot_result,\n            swap_op = $swap_op,\n            swapped = $swapped,\n            reversed = $reversed,\n            leading_zeros_test = concat!(stringify!($Int), \"::MAX\"),\n        }\n    };\n\n    (\n        Self = $Ty:ident,\n        Primitive = signed $Int:ident,\n        UnsignedPrimitive = $Uint:ident,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n    ) => {\n        nonzero_integer! {\n            #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\n            Self = $Ty,\n            Primitive = signed $Int,\n            SignedPrimitive = $Int,\n            UnsignedPrimitive = $Uint,\n            rot = $rot,\n            rot_op = $rot_op,\n            rot_result = $rot_result,\n            swap_op = $swap_op,\n            swapped = $swapped,\n            reversed = $reversed,\n            leading_zeros_test = concat!(\"-1\", stringify!($Int)),\n        }\n    };\n}"
    },
    {
      "callsite": "nonzero_integer! {\n    Self = NonZeroI8,\n    Primitive = signed i8,\n    UnsignedPrimitive = u8,\n    rot = 2,\n    rot_op = \"-0x7e\",\n    rot_result = \"0xa\",\n    swap_op = \"0x12\",\n    swapped = \"0x12\",\n    reversed = \"0x48\",\n}",
      "defsite": "macro_rules! nonzero_integer {\n    (\n        #[$stability:meta]\n        Self = $Ty:ident,\n        Primitive = $signedness:ident $Int:ident,\n        SignedPrimitive = $Sint:ty,\n        UnsignedPrimitive = $Uint:ty,\n\n        // Used in doc comments.\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        leading_zeros_test = $leading_zeros_test:expr,\n    ) => {\n        #[doc = sign_dependent_expr!{\n            $signedness ?\n            if signed {\n                concat!(\"An [`\", stringify!($Int), \"`] that is known not to equal zero.\")\n            }\n            if unsigned {\n                concat!(\"A [`\", stringify!($Int), \"`] that is known not to equal zero.\")\n            }\n        }]\n        ///\n        /// This enables some memory layout optimization.\n        #[doc = concat!(\"For example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\")]\n        ///\n        /// ```rust\n        #[doc = concat!(\"assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int), \">());\")]\n        /// ```\n        ///\n        /// # Layout\n        ///\n        #[doc = concat!(\"`\", stringify!($Ty), \"` is guaranteed to have the same layout and bit validity as `\", stringify!($Int), \"`\")]\n        /// with the exception that `0` is not a valid instance.\n        #[doc = concat!(\"`Option<\", stringify!($Ty), \">` is guaranteed to be compatible with `\", stringify!($Int), \"`,\")]\n        /// including in FFI.\n        ///\n        /// Thanks to the [null pointer optimization],\n        #[doc = concat!(\"`\", stringify!($Ty), \"` and `Option<\", stringify!($Ty), \">`\")]\n        /// are guaranteed to have the same size and alignment:\n        ///\n        /// ```\n        #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(size_of::<\", stringify!($Ty), \">(), size_of::<Option<\", stringify!($Ty), \">>());\")]\n        #[doc = concat!(\"assert_eq!(align_of::<\", stringify!($Ty), \">(), align_of::<Option<\", stringify!($Ty), \">>());\")]\n        /// ```\n        ///\n        /// [null pointer optimization]: crate::option#representation\n        #[$stability]\n        pub type $Ty = NonZero<$Int>;\n\n        impl NonZero<$Int> {\n            /// The size of this non-zero integer type in bits.\n            ///\n            #[doc = concat!(\"This value is equal to [`\", stringify!($Int), \"::BITS`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            #[doc = concat!(\"assert_eq!(NonZero::<\", stringify!($Int), \">::BITS, \", stringify!($Int), \"::BITS);\")]\n            /// ```\n            #[stable(feature = \"nonzero_bits\", since = \"1.67.0\")]\n            pub const BITS: u32 = <$Int>::BITS;\n\n            /// Returns the number of leading zeros in the binary representation of `self`.\n            ///\n            /// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::<\", stringify!($Int), \">::new(\", $leading_zeros_test, \")?;\")]\n            ///\n            /// assert_eq!(n.leading_zeros(), 0);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[rustc_const_stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn leading_zeros(self) -> u32 {\n                // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.\n                unsafe {\n                    intrinsics::ctlz_nonzero(self.get() as $Uint)\n                }\n            }\n\n            /// Returns the number of trailing zeros in the binary representation\n            /// of `self`.\n            ///\n            /// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::<\", stringify!($Int), \">::new(0b0101000)?;\")]\n            ///\n            /// assert_eq!(n.trailing_zeros(), 3);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[rustc_const_stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn trailing_zeros(self) -> u32 {\n                // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.\n                unsafe {\n                    intrinsics::cttz_nonzero(self.get() as $Uint)\n                }\n            }\n\n            /// Returns `self` with only the most significant bit set.\n            ///\n            /// # Example\n            ///\n            /// ```\n            /// #![feature(isolate_most_least_significant_one)]\n            ///\n            /// # use core::num::NonZero;\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b_01100100)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b_01000000)?;\")]\n            ///\n            /// assert_eq!(a.isolate_most_significant_one(), b);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn isolate_most_significant_one(self) -> Self {\n                let n = self.get() & (((1 as $Int) << (<$Int>::BITS - 1)).wrapping_shr(self.leading_zeros()));\n\n                // SAFETY:\n                // `self` is non-zero, so masking to preserve only the most\n                // significant set bit will result in a non-zero `n`.\n                unsafe { NonZero::new_unchecked(n) }\n            }\n\n            /// Returns `self` with only the least significant bit set.\n            ///\n            /// # Example\n            ///\n            /// ```\n            /// #![feature(isolate_most_least_significant_one)]\n            ///\n            /// # use core::num::NonZero;\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b_01100100)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b_00000100)?;\")]\n            ///\n            /// assert_eq!(a.isolate_least_significant_one(), b);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn isolate_least_significant_one(self) -> Self {\n                let n = self.get();\n                let n = n & n.wrapping_neg();\n\n                // SAFETY: `self` is non-zero, so `self` with only its least\n                // significant set bit will remain non-zero.\n                unsafe { NonZero::new_unchecked(n) }\n            }\n\n            /// Returns the number of ones in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b100_0000)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b100_0011)?;\")]\n            ///\n            /// assert_eq!(a.count_ones(), NonZero::new(1)?);\n            /// assert_eq!(b.count_ones(), NonZero::new(3)?);\n            /// # Some(())\n            /// # }\n            /// ```\n            ///\n            #[stable(feature = \"non_zero_count_ones\", since = \"1.86.0\")]\n            #[rustc_const_stable(feature = \"non_zero_count_ones\", since = \"1.86.0\")]\n            #[doc(alias = \"popcount\")]\n            #[doc(alias = \"popcnt\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() > 0)]\n            pub const fn count_ones(self) -> NonZero<u32> {\n                // SAFETY:\n                // `self` is non-zero, which means it has at least one bit set, which means\n                // that the result of `count_ones` is non-zero.\n                unsafe { NonZero::new_unchecked(self.get().count_ones()) }\n            }\n\n            /// Shifts the bits to the left by a specified amount, `n`,\n            /// wrapping the truncated bits to the end of the resulting integer.\n            ///\n            /// Please note this isn't the same operation as the `<<` shifting operator!\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $rot_op, stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let m = NonZero::new(\", $rot_result, \")?;\")]\n            ///\n            #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() != 0)]\n            #[ensures(|result| result.rotate_right(n).get() == old(self).get())]\n            pub const fn rotate_left(self, n: u32) -> Self {\n                let result = self.get().rotate_left(n);\n                // SAFETY: Rotating bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Shifts the bits to the right by a specified amount, `n`,\n            /// wrapping the truncated bits to the beginning of the resulting\n            /// integer.\n            ///\n            /// Please note this isn't the same operation as the `>>` shifting operator!\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $rot_result, stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let m = NonZero::new(\", $rot_op, \")?;\")]\n            ///\n            #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() != 0)]\n            #[ensures(|result| result.rotate_left(n).get() == old(self).get())]\n            pub const fn rotate_right(self, n: u32) -> Self {\n                let result = self.get().rotate_right(n);\n                // SAFETY: Rotating bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Reverses the byte order of the integer.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $swap_op, stringify!($Int), \")?;\")]\n            /// let m = n.swap_bytes();\n            ///\n            #[doc = concat!(\"assert_eq!(m, NonZero::new(\", $swapped, \")?);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn swap_bytes(self) -> Self {\n                let result = self.get().swap_bytes();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n            /// second least-significant bit becomes second most-significant bit, etc.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $swap_op, stringify!($Int), \")?;\")]\n            /// let m = n.reverse_bits();\n            ///\n            #[doc = concat!(\"assert_eq!(m, NonZero::new(\", $reversed, \")?);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn reverse_bits(self) -> Self {\n                let result = self.get().reverse_bits();\n                // SAFETY: Reversing bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts an integer from big endian to the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_be(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_be(n), n.swap_bytes())\")]\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use]\n            #[inline(always)]\n            pub const fn from_be(x: Self) -> Self {\n                let result = $Int::from_be(x.get());\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts an integer from little endian to the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_le(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_le(n), n.swap_bytes())\")]\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use]\n            #[inline(always)]\n            pub const fn from_le(x: Self) -> Self {\n                let result = $Int::from_le(x.get());\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts `self` to big endian from the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            ///     assert_eq!(n.to_be(), n)\n            /// } else {\n            ///     assert_eq!(n.to_be(), n.swap_bytes())\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn to_be(self) -> Self {\n                let result = self.get().to_be();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts `self` to little endian from the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            ///     assert_eq!(n.to_le(), n)\n            /// } else {\n            ///     assert_eq!(n.to_le(), n.swap_bytes())\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn to_le(self) -> Self {\n                let result = self.get().to_le();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            nonzero_integer_signedness_dependent_methods! {\n                Primitive = $signedness $Int,\n                SignedPrimitive = $Sint,\n                UnsignedPrimitive = $Uint,\n            }\n\n            /// Multiplies two non-zero integers together.\n            /// Checks for overflow and returns [`None`] on overflow.\n            /// As a consequence, the result cannot wrap to zero.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(Some(four), two.checked_mul(two));\n            /// assert_eq!(None, max.checked_mul(two));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn checked_mul(self, other: Self) -> Option<Self> {\n                if let Some(result) = self.get().checked_mul(other.get()) {\n                    // SAFETY:\n                    // - `checked_mul` returns `None` on overflow\n                    // - `self` and `other` are non-zero\n                    // - the only way to get zero from a multiplication without overflow is for one\n                    //   of the sides to be zero\n                    //\n                    // So the result cannot be zero.\n                    Some(unsafe { Self::new_unchecked(result) })\n                } else {\n                    None\n                }\n            }\n\n            /// Multiplies two non-zero integers together.\n            #[doc = concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(four, two.saturating_mul(two));\n            /// assert_eq!(max, four.saturating_mul(max));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_mul(self, other: Self) -> Self {\n                // SAFETY:\n                // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,\n                //   all of which are non-zero\n                // - `self` and `other` are non-zero\n                // - the only way to get zero from a multiplication without overflow is for one\n                //   of the sides to be zero\n                //\n                // So the result cannot be zero.\n                unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }\n            }\n\n            /// Multiplies two non-zero integers together,\n            /// assuming overflow cannot occur.\n            /// Overflow is unchecked, and it is undefined behavior to overflow\n            /// *even if the result would wrap to a non-zero value*.\n            /// The behavior is undefined as soon as\n            #[doc = sign_dependent_expr!{\n                $signedness ?\n                if signed {\n                    concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`, \",\n                            \"or `self * rhs < \", stringify!($Int), \"::MIN`.\")\n                }\n                if unsigned {\n                    concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`.\")\n                }\n            }]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_ops)]\n            ///\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            ///\n            /// assert_eq!(four, unsafe { two.unchecked_mul(two) });\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            #[requires({\n                self.get().checked_mul(other.get()).is_some()\n            })]\n            #[ensures(|result: &Self| {\n                self.get().checked_mul(other.get()).is_some_and(|product| product == result.get())\n            })]\n            pub const unsafe fn unchecked_mul(self, other: Self) -> Self {\n                // SAFETY: The caller ensures there is no overflow.\n                unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }\n            }\n\n            /// Raises non-zero value to an integer power.\n            /// Checks for overflow and returns [`None`] on overflow.\n            /// As a consequence, the result cannot wrap to zero.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let three = NonZero::new(3\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let twenty_seven = NonZero::new(27\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let half_max = NonZero::new(\", stringify!($Int), \"::MAX / 2)?;\")]\n            ///\n            /// assert_eq!(Some(twenty_seven), three.checked_pow(3));\n            /// assert_eq!(None, half_max.checked_pow(3));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn checked_pow(self, other: u32) -> Option<Self> {\n                if let Some(result) = self.get().checked_pow(other) {\n                    // SAFETY:\n                    // - `checked_pow` returns `None` on overflow/underflow\n                    // - `self` is non-zero\n                    // - the only way to get zero from an exponentiation without overflow is\n                    //   for base to be zero\n                    //\n                    // So the result cannot be zero.\n                    Some(unsafe { Self::new_unchecked(result) })\n                } else {\n                    None\n                }\n            }\n\n            /// Raise non-zero value to an integer power.\n            #[doc = sign_dependent_expr!{\n                $signedness ?\n                if signed {\n                    concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MIN`] \",\n                                \"or [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")\n                }\n                if unsigned {\n                    concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")\n                }\n            }]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let three = NonZero::new(3\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let twenty_seven = NonZero::new(27\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(twenty_seven, three.saturating_pow(3));\n            /// assert_eq!(max, max.saturating_pow(3));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_pow(self, other: u32) -> Self {\n                // SAFETY:\n                // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,\n                //   all of which are non-zero\n                // - `self` is non-zero\n                // - the only way to get zero from an exponentiation without overflow is\n                //   for base to be zero\n                //\n                // So the result cannot be zero.\n                unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }\n            }\n        }\n\n        #[stable(feature = \"nonzero_parse\", since = \"1.35.0\")]\n        impl FromStr for NonZero<$Int> {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, Self::Err> {\n                Self::new(<$Int>::from_str_radix(src, 10)?)\n                    .ok_or(ParseIntError {\n                        kind: IntErrorKind::Zero\n                    })\n            }\n        }\n\n        nonzero_integer_signedness_dependent_impls!($signedness $Int);\n    };\n\n    (\n        Self = $Ty:ident,\n        Primitive = unsigned $Int:ident,\n        SignedPrimitive = $Sint:ident,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        $(,)?\n    ) => {\n        nonzero_integer! {\n            #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n            Self = $Ty,\n            Primitive = unsigned $Int,\n            SignedPrimitive = $Sint,\n            UnsignedPrimitive = $Int,\n            rot = $rot,\n            rot_op = $rot_op,\n            rot_result = $rot_result,\n            swap_op = $swap_op,\n            swapped = $swapped,\n            reversed = $reversed,\n            leading_zeros_test = concat!(stringify!($Int), \"::MAX\"),\n        }\n    };\n\n    (\n        Self = $Ty:ident,\n        Primitive = signed $Int:ident,\n        UnsignedPrimitive = $Uint:ident,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n    ) => {\n        nonzero_integer! {\n            #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\n            Self = $Ty,\n            Primitive = signed $Int,\n            SignedPrimitive = $Int,\n            UnsignedPrimitive = $Uint,\n            rot = $rot,\n            rot_op = $rot_op,\n            rot_result = $rot_result,\n            swap_op = $swap_op,\n            swapped = $swapped,\n            reversed = $reversed,\n            leading_zeros_test = concat!(\"-1\", stringify!($Int)),\n        }\n    };\n}"
    }
  ],
  "callees": [
    "21711908612579563914872185813592704681",
    "1363736816890242968813291297505934676086",
    "1096154568935207292118411765173724766739",
    "1615780015787215128316594883786605832883",
    "1363736816890242968813291297505934676086",
    "40063093336585792095766602796070126518",
    "4210014628989957347484966718734559295",
    "1363736816890242968813291297505934676086",
    "32379270059602019354235921731882813982",
    "56302926392345337717408510197239954979",
    "162904158373319495369070442937212273978",
    "11879697526668758218117833999951598353",
    "145493908791982296621902181110000221268",
    "569006077262986796812405551728371512007",
    "1531529736665207119716166291560277808459",
    "589599466487462365011430963401962118509",
    "173804791060645997939431648088044898019",
    "345779094652510990013028497657958621628",
    "87917181078797516101814801417554460859",
    "633647834542374266612707027049512022895",
    "697460064680243425913637757097126534899",
    "57271910509607564957449146075388127590",
    "491501190642785328215657853710567654624",
    "963445940455787412316298237032570014032",
    "45755338440053891812429711640309937578",
    "117083133034458006019709376097028492273",
    "1214258652200928387411644436693302022198",
    "116838725589658364762125035485285727797",
    "543262562578205611814193723889232631679",
    "52447312959119204751725989402363811285",
    "178740761294011342347851287405474276941",
    "1363736816890242968813291297505934676086",
    "133438993749786418975081779688101424321",
    "1363736816890242968813291297505934676086",
    "1399429456846979953611102041165781521260",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "124505100155499374672517322928734740357",
    "17564752812027543017921499519819593186",
    "415843772060095450495024404503354748",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "141734674420942826793676645643806909910",
    "1449958889715960797216832526184590351740",
    "1405688574831102906613841440741292834949",
    "1363736816890242968813291297505934676086",
    "102681047625715816715891697912487007516",
    "1456038200519160613311076457066716778749",
    "1363736816890242968813291297505934676086",
    "3631011255984099811723442155502233758",
    "107434598387902432754329628792529310410",
    "126856515018227567717268281677679773089",
    "1541892164474739153210412766107034883087",
    "1363736816890242968813291297505934676086",
    "114307678585105788705826351831663929507",
    "36516702880102455035412356603021119879",
    "66230658810213716923364242359817003494",
    "758521721130535942311471025828986597656",
    "1061164724759219763815645675397447440252",
    "87403439848434419247064420115731773013",
    "1363736816890242968813291297505934676086",
    "1557257459089412723814481849913677699848",
    "1252490680533338683910412060151507734433",
    "1749354356376422432110307264409629560948",
    "1258466857914554525112404871973680747085",
    "44257266364374505814542935723980878695",
    "483065282508714011512484774123351954088",
    "14903543624694794243644002717478558678",
    "110497420964184345517185892364398759782",
    "967906768493376431218217451737112282259",
    "120545667060787152649831833770488558658",
    "35398161789749681612681774609204698030",
    "1179015178765463762414234671921766134145",
    "174685213766893048749650677724114385749",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "85954746138896127215759194079554738885",
    "147140364761497764245859604611097836389",
    "1596895408968513533410088921895846228595",
    "1363736816890242968813291297505934676086",
    "623639168654963913411684007357416775607",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "47199191733691449547172525385406110161",
    "1045310264982455842316057249879093988914",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1316970106710505483515384541553369764410",
    "47323665595455568617290020941376774286",
    "141650019703345949717516048586848171301",
    "115294443576414182704230118141076863162",
    "117180827392012273508876188211897901",
    "33648701090774792381476499826703911309",
    "17059090463224209834835470382370244130",
    "1390948765080590250516343632946970173132",
    "302040922402546323014383629325615453738",
    "104780260797238568438940055849532063423",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "11139495935450220752286966752445431093",
    "25768524018977866517055903022448790318",
    "1363736816890242968813291297505934676086",
    "111425599901702694743874629435682172347",
    "10411882274122721321347434438360460579",
    "714811817540972740211524868124730226803",
    "182193223584779598874454481824447992605",
    "1329845230409163288212548289525672875535",
    "80772345035046942210372022594843481570",
    "109763229663154342343123224747831634619",
    "47278574192031232971799194590021398469",
    "84909938954906103112758184730426842057",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "16824420916691935049705640393259467449",
    "561445107989240208511361370086377379752",
    "43065787078031739421302414489234141137",
    "141422989953676177975345808590037882245",
    "599811874247088556214270119820779031432",
    "116307730265010107496063883445928110555",
    "51249814573059736397300350198312706573",
    "14314158248731667467224830801301140817",
    "20556606504130694934441291267858631687",
    "63343181121905511768887728585050322379",
    "1740349853341161241318022375811744789656",
    "163420631485670102514812722236596958075",
    "117866791398837999916729913240660212602",
    "78937725557049865865312472258624739921",
    "24965143184079381448082111781766640478",
    "120187458746217755377061356638344375303",
    "979929479181667570414120095459269589167",
    "26018933144073124403117386256735640375",
    "146047412284994450699670763407526667493",
    "370986840755973263713704597144407313708",
    "1269044022939676954011330908751210391833",
    "1814608415178812336916584953075633412492",
    "5155095549190106808117025562379125071",
    "231144133455543717611650225582136294816",
    "658338601979133096511997313224278252199",
    "279139698799614514916515091634607686006",
    "1386932868725969591817741044941664680589",
    "1614019611353877008011078295776030189782",
    "122529376138248236262181364630884265848",
    "168808893922624482353144964771536079081",
    "1373954867253511233510412862011267463900",
    "118312983481738621787939326110261417317",
    "1443801087974407715313972555121628268092",
    "55549683683119533987529308576431567352",
    "353836335514715551415901371272464802770",
    "1259853796123792531010116020849677170944",
    "11663475863125548442297136621169599847",
    "694680042487375838617016048567631445241",
    "1469238626115971997416556324389651615960",
    "772065526016577495817057948738175729677",
    "164222581612569613775862371766786294469",
    "168545836479171427075036933182194130275",
    "1245138925531671967011772485621443291799",
    "84531025305994381986874028925223812083",
    "1767855557361537621413279623076098939355",
    "1737790711272917069411654923375177111580",
    "92012921366381513263854354353760013598",
    "107365534946901948286099583667090509800",
    "1712898201300478840215074793236064467963",
    "1067675883129992420314174327751912045205",
    "7832507060962758874697651425918563686",
    "1363736816890242968813291297505934676086",
    "55437864283997130525290213251785829081",
    "3732847027464893713631125486321117411",
    "474883547691872444716131290265871971552",
    "151815060531445846803530289828923336292",
    "41969636245051235474420490048321019734",
    "4630340726512669156878430125770402386",
    "357176471955646296310888565522772121043",
    "20358335917806342173469037020013160778",
    "59784951958023534311340742558790816074",
    "114853118776980240128508846708169247001",
    "748883521171844223517017220441817346988",
    "1461745429986084010034901226572810240",
    "161003650625398914518944455314788757627",
    "375485108047544468212954122974188100514",
    "1259350752486802697010822022220260946961",
    "173105439367020071767957153438588951894",
    "164769300933020566656262923669273525158",
    "841346702487865802717731804342903065853",
    "290360310864386898714327273451929980463",
    "1617054938297627622011998382328717871744",
    "1187394330470290540315609612625104918416",
    "643349473068727846115780678007450923004",
    "1196638383615410162910723134175805433641",
    "1182371843420022111010336901757313084440",
    "26064680123257945312537992217601395168",
    "1801932849287312231112662193894546046488",
    "13796074939706337624507826801091410480",
    "844957821118050201712037424530049556280",
    "94922797404227066110182963288288755980",
    "1290129509806421189411347835193128335421",
    "1440950763975467621710982502069073665218",
    "115914492802736206513942422914514650180",
    "10472345935978673833158369420689244465",
    "590329942313453995443993872612632776",
    "124585850382406476533630795656715220155",
    "58004076551979108867624014250612795185",
    "315331140686166457616644577557668814534",
    "392414261785278668815725499572289607221",
    "57879252225118024599041161508222342189",
    "13877762789521041542129457574643169972",
    "39733537437022171613682062970386769295",
    "116482898840396402477616122367703643717",
    "126012008154782159615214827713093461635",
    "176742512093848468045239021356424772729",
    "1332220011502853693912113825838893369096",
    "489491009154422080613291037190739219235",
    "172988202723925134796567682468931265149",
    "161899346824042420066809545955353317373",
    "142848115973206406239372863350872744477",
    "121437425240318612285099463628436266366",
    "158788300439364078868929174883737501237",
    "862746525473562901814208597568406058076",
    "18807870376557811914137072961455205803",
    "1363736816890242968813291297505934676086",
    "1549869736248796694614142541046834936124",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "841904668883726495316837415609641023349",
    "1258931108755458209614962827106116332072",
    "53589810041120365110998933211304468616",
    "1243847030362955698517207199029174369810",
    "105125143701458073564296455695110349394",
    "25930241974724637292994171257021210872",
    "617554482545947003412104686554524783687",
    "1445917162577882149418297081791436471284",
    "849628185942532211610194183090257053256",
    "152018209062913109616942758022114057971",
    "14289085791843058303972699274315536239",
    "772849497340941696512651691449279859789",
    "172651811582921907362991207281968133556",
    "55767955768979135724569809046456107380",
    "138498210655847367337117318085891081738",
    "602553655434272852810568520159081802816",
    "118399811559831053152713406198401957826",
    "37177017281071971897146112828522083495",
    "12843798981703387312528981449504705678",
    "258383674090471065712097594685693339627",
    "16219137135012567795854520876341648395",
    "1110994844594451591212495732224461740413",
    "102887121523905452179262747329207775596",
    "703663108277374327010040438608357482834",
    "18025038300022165797237903038339257643",
    "1100495660517602822510660091708953776518",
    "261114641164087560416314538374841383619",
    "104831405656903467145249333363974848645",
    "166731958795390711014401438738375660172",
    "170643549057433678244294044399486155477",
    "45778466392467191607407869613497036936",
    "928576257219350686410540489380463230637",
    "316650073974070898314677646691025099244",
    "699677282037119441912902108102153124040",
    "82172937758979852922952239791072303378",
    "440548634769728996212603275541854349848",
    "58610947851065178096877308904752748129",
    "11646453575295718315251820797250120902",
    "180824515799235861855048294605620195261",
    "6920580184232348336779953785783275216",
    "10280076113730517359836576566793155285",
    "1341558659220454468114614057400541737257",
    "134444069993780397564703136863158148716",
    "1281311138712451019216655529596617870816",
    "1694562113052794749410144451898650894237",
    "4869154787378134257815739629728386905",
    "23263425687593823605436039540654199623",
    "1265976456585539210516529077192093398642",
    "115773568660767031455181763448941131845",
    "136032794974893814259994759472454752644",
    "432839679267479096014829068154253700423",
    "1794599000442827535116488920139961158750",
    "2986389593417097136138451070897405411",
    "120554772527146371477803731781472626688",
    "1575180643816959680013764123585909653935",
    "39498763786986515562043840216548811868",
    "1301552843662473815815562437677364454669",
    "25269069644916694782526525713115896132",
    "705720955307329014517734924079983333105",
    "106194760576608812086033306050055808545",
    "26709420718515964610399689521027368728",
    "647229011481470722711384925118784833376",
    "195916256607314082811658914690236691420",
    "781603672758780177711142029625885084089",
    "491291023697495753013211284803811616795",
    "184353680265586730536158755300629755859",
    "150805697079257168915708122934999652421",
    "19032683183423540915807324370118535654",
    "843102896095261732816452208300794916411",
    "183304351666724829317590170706630038849",
    "169017152061146820209827866672499117723",
    "148575031114542006631514846264054548534",
    "1775677520341811851814469906126811626471",
    "116738536460889801267781784641205834958",
    "335215210776670050614472036033464965023",
    "63316748377020640678862326185202615069",
    "31390187068039156922254347795038548724",
    "1365351597739011160412231277592213691479",
    "62964906474134410292844024784991518817",
    "591163883570913488917341250007887670228",
    "1191898201809378325315295870108407566549",
    "1180283320154936987317687023111507811148",
    "1313672206338891747615103280559224089796",
    "96372891677808677613400092139271508855",
    "28615990301751085456623670194523588843",
    "934375696446284627516563118665690549226",
    "90717827950038266317724794688744091509",
    "374600997420842104113073418159306638921",
    "676158778818239148118032927577101369525",
    "20465072737965727702865968861132587689",
    "164270848150013505114031889181489753537",
    "15152045824856044406894168005740738415",
    "1619664696269114311311148142649633607940",
    "132338405727806576551962422346647404382",
    "148942728659230088417108897615339309934",
    "39540448515855064678826919862848152559",
    "1138206188600112614014052369198511966956",
    "1444520060167597438013590316361883534441",
    "840327692597851529715494429944416660710",
    "110592357029254507637069415658458618835",
    "659668705778703132618263658943022009102",
    "104042909831277084814695630352375939457",
    "151694591507088409946921766244030956793",
    "199204638009217392510037902431469110881",
    "145447226859878511083700582225257315850",
    "50060506762358864813111719587773515328",
    "183861757727510342134448172129871973284",
    "105672144727691370147417363250736312873",
    "484471573878144096018004521534736974390",
    "1709809215670154039418099455961948399924",
    "96916315473583579836508686922498622791",
    "565703400213878621116612569146298479102",
    "28736061727494506023412962124683958890",
    "33266587737904114784644542366524180286",
    "334303462732756290216309246141683003630",
    "21719508563266996657990482115758623513",
    "66698550878882944999797753749781566130",
    "1060448573230263915014803683681339895296",
    "58110682308819786796654183007581184910",
    "1454902756454700245417169407534621781519",
    "1302514623760732210917631482165556335973",
    "1028023859496283824714006082102994000183",
    "1375602339865304183616456573312626826122",
    "1107283495849277278117296354366898453379",
    "277270871561828570218406540162843059579",
    "13445532662779670761228880372488293329",
    "1262939944460148277811000139254508406606",
    "139679375284959323487025069545409596711",
    "18715316072765276746430930647862132791",
    "111607676992080912514849326215626188409",
    "156699801464166307163042354284108788791",
    "22866183673949532009302817089247357249",
    "481760318323362098310716245514364463126",
    "64610587145495125376527745759424960225",
    "1224955055955126069915106408301904372143",
    "3079032817560176158247747105618414518",
    "153961383230565385603558291194734136711",
    "1363736816890242968813291297505934676086",
    "126141077251671387694770399036796691982",
    "182972684513709302288440602073677891408",
    "46951060227140590465148676449871328723",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "757582883714685463901852637522961818",
    "126692834448097932228994692025940173998",
    "25558485697757400065874176408609551720",
    "3070792398821344367711524405851230424",
    "1309835973007280609915569531429584049128",
    "1168250850099297564614674330731516573335",
    "1363736816890242968813291297505934676086",
    "258015149311769650815595893692783623165",
    "511478505957911151817582639665615596786",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "72206699492837620961391515713423967445",
    "13755615706890703333392644145431563331",
    "159756182951594195141958974558316251741",
    "125503965774672678587505966790704230026",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "66706820410345849277836174571153878427",
    "56280834011826648107990160430231866711",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "410539056495057654816027084297333494253",
    "77174816795140902716242581103966137591",
    "2789128693349703173502163395333061757",
    "166633686087748340273888470960266707358",
    "803349082160475719615953068480273372134",
    "94056652019881819791956374760214426656",
    "754759722796109215815456571656250183671",
    "1759901199729611034616971071765351824769",
    "1713539753654745329215868145254478021527",
    "617092763968904127517665973127834451336",
    "127855099164131056444917757662188434041",
    "949395388449823663510769715854278378985",
    "1104235390298522963816456402510698856634",
    "911776701760282171617604846768629435744",
    "1775737194777331674985764993211109601",
    "182534260348495718753381397354609581701",
    "4934620328571622263466073158373293264",
    "12648906865206745938310425055021489000",
    "146974890213594219449252497930155406314",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "174687280503843252966785365579092840489",
    "175571384913906199332529456767936114324",
    "30538736193800974802435154402903504258",
    "114738990432469285116290634385075634137",
    "15983849791221256564812498585385603744",
    "1079004244994411241413554978492739965599",
    "82091519569599138729539588385833891722",
    "1043753670404697738110369474677413471996",
    "13319693877906475969745999911508592033",
    "1803080631077045177915667721738419071984",
    "1840089712819150440011289622865836852783",
    "156130332443363785142369276941490088427",
    "1363736816890242968813291297505934676086",
    "69113001718728000933280786850497169271",
    "685067228267738706816520200651034208821",
    "806886716273422490012922041462466388021",
    "27923647172126753103299190047630517613",
    "101529499612274583310256215612263406146",
    "1530284227476743347713341144208972169947",
    "47867114697845434864733977363775125036",
    "690191742356000119711662071594594489591",
    "2359618996072093344825228041002286558",
    "1809343474275607681211888501461793289939",
    "28165847745982066288778377828776142451",
    "88493681086475254713711651785051145947",
    "191955226679272286116324456769319086740",
    "82869399406577355236900753945207284521",
    "1312337259679107324810632236067710137987",
    "1281491428722655105812293039240564558174",
    "1003330821210552932912035065246129125121",
    "179654496502614639316000517910785552386",
    "81865490382594657408046274180724905068",
    "166919050687909314661017061178177074704",
    "121719316555113793862003739913395039268",
    "1378841877187097314016728178981803040846",
    "143855658971075482716496001174473796264",
    "774656650382130508918215221937405910597",
    "87921322259985553812333634501742816676",
    "49735939736064522815836904066037473747",
    "1371444395219499039416884212293696836317",
    "137858276920179648721963909130383298377",
    "600212582708984139817168672437512081975",
    "179055790507985182579992344567348443326",
    "995177949111625568612353687436321299644",
    "5310558452957964718858737086270628046",
    "1363736816890242968813291297505934676086",
    "1791498998900760371016093261305107956284",
    "3564196776402835410996067600986058440",
    "15167305530142968353259369112121275803",
    "1363736816890242968813291297505934676086",
    "45819503778375231969038300244556098990",
    "11275800218733998915358478622531324152",
    "1875738746069546053588724721861696954",
    "1363736816890242968813291297505934676086",
    "1425886142144039943111129160147777313265",
    "20475840513559464912888937342908332014",
    "103529232425067372948580977297303381856",
    "500039049531792023414807911624995133090",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "1363736816890242968813291297505934676086",
    "999550419794171197017667664885549974755",
    "1363736816890242968813291297505934676086",
    "106681772045087936513629764546266919219",
    "638878529771811441416671099064984594214",
    "4939948683197044415599526564423792146",
    "135531080111925582411467416475571761960",
    "802603331907130014710293248879007229107",
    "1793199026846464691616255721034512928348",
    "121973516639670562835557836045994389718",
    "113814366055626271438047374284421353461",
    "138774632689772549819578629668035245923",
    "158338167874674576194838212405987326951",
    "90175179397242369455372712796954544135",
    "550150895960312460312176584159342455723",
    "3060735069095531695579360726350017976",
    "156558724737321886766153526308848840146",
    "478505109661826463711850093418602871650",
    "7839859953712079114640771271960005865",
    "1137271765924114987514947403158445640283",
    "393974833682574441515290398983271504453",
    "182908810388331326478630133303460182053",
    "180126912453652104473132457509626900161",
    "1149265318701628438811160570489210589004",
    "1624379938933529147317881339677401093926",
    "1473335491240830543017777776437787647078",
    "399232661239117480517401994520839366833",
    "1366691609966069760614771012231218686545",
    "165260604638305226342101042842060873588",
    "34478597508049401479557782585707843723"
  ]
}
