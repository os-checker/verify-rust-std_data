{
  "file": "core/src/num/nonzero.rs",
  "name": "num::nonzero::NonZero::<u32>::ilog10",
  "hash": "2830435581104507596322521885669213948",
  "hash_direct": "252743411643958682812906279902820510083",
  "src": "pub const fn ilog10(self) -> u32 {\n            super::int_log10::$Int(self.get())\n        }",
  "macro_backtrace": [
    {
      "callsite": "nonzero_integer_signedness_dependent_methods! {\n                Primitive = $signedness $Int,\n                SignedPrimitive = $Sint,\n                UnsignedPrimitive = $Uint,\n            }",
      "defsite": "macro_rules! nonzero_integer_signedness_dependent_methods {\n    // Associated items for unsigned nonzero types only.\n    (\n        Primitive = unsigned $Int:ident,\n        SignedPrimitive = $Sint:ty,\n        UnsignedPrimitive = $Uint:ty,\n    ) => {\n        /// The smallest value that can be represented by this non-zero\n        /// integer type, 1.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        #[doc = concat!(\"assert_eq!(NonZero::<\", stringify!($Int), \">::MIN.get(), 1\", stringify!($Int), \");\")]\n        /// ```\n        #[stable(feature = \"nonzero_min_max\", since = \"1.70.0\")]\n        pub const MIN: Self = Self::new(1).unwrap();\n\n        /// The largest value that can be represented by this non-zero\n        /// integer type,\n        #[doc = concat!(\"equal to [`\", stringify!($Int), \"::MAX`].\")]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        #[doc = concat!(\"assert_eq!(NonZero::<\", stringify!($Int), \">::MAX.get(), \", stringify!($Int), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"nonzero_min_max\", since = \"1.70.0\")]\n        pub const MAX: Self = Self::new(<$Int>::MAX).unwrap();\n\n        /// Adds an unsigned integer to a non-zero value.\n        /// Checks for overflow and returns [`None`] on overflow.\n        /// As a consequence, the result cannot wrap to zero.\n        ///\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let one = NonZero::new(1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n        ///\n        /// assert_eq!(Some(two), one.checked_add(1));\n        /// assert_eq!(None, max.checked_add(1));\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, other: $Int) -> Option<Self> {\n            if let Some(result) = self.get().checked_add(other) {\n                // SAFETY:\n                // - `checked_add` returns `None` on overflow\n                // - `self` is non-zero\n                // - the only way to get zero from an addition without overflow is for both\n                //   sides to be zero\n                //\n                // So the result cannot be zero.\n                Some(unsafe { Self::new_unchecked(result) })\n            } else {\n                None\n            }\n        }\n\n        /// Adds an unsigned integer to a non-zero value.\n        #[doc = concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let one = NonZero::new(1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n        ///\n        /// assert_eq!(two, one.saturating_add(1));\n        /// assert_eq!(max, max.saturating_add(1));\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add(self, other: $Int) -> Self {\n            // SAFETY:\n            // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero\n            // - `self` is non-zero\n            // - the only way to get zero from an addition without overflow is for both\n            //   sides to be zero\n            //\n            // So the result cannot be zero.\n            unsafe { Self::new_unchecked(self.get().saturating_add(other)) }\n        }\n\n        /// Adds an unsigned integer to a non-zero value,\n        /// assuming overflow cannot occur.\n        /// Overflow is unchecked, and it is undefined behavior to overflow\n        /// *even if the result would wrap to a non-zero value*.\n        /// The behavior is undefined as soon as\n        #[doc = concat!(\"`self + rhs > \", stringify!($Int), \"::MAX`.\")]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(nonzero_ops)]\n        ///\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let one = NonZero::new(1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n        ///\n        /// assert_eq!(two, unsafe { one.unchecked_add(1) });\n        /// # Some(())\n        /// # }\n        /// ```\n        #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[requires({\n            self.get().checked_add(other).is_some()\n        })]\n        #[ensures(|result: &Self| {\n            // Postcondition: the result matches the expected addition\n            self.get().checked_add(other).is_some_and(|sum| sum == result.get())\n        })]\n        pub const unsafe fn unchecked_add(self, other: $Int) -> Self {\n            // SAFETY: The caller ensures there is no overflow.\n            unsafe { Self::new_unchecked(self.get().unchecked_add(other)) }\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        /// Checks for overflow and returns [`None`]\n        /// if the next power of two is greater than the typeâ€™s maximum value.\n        /// As a consequence, the result cannot wrap to zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let three = NonZero::new(3\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n        ///\n        /// assert_eq!(Some(two), two.checked_next_power_of_two() );\n        /// assert_eq!(Some(four), three.checked_next_power_of_two() );\n        /// assert_eq!(None, max.checked_next_power_of_two() );\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            if let Some(nz) = self.get().checked_next_power_of_two() {\n                // SAFETY: The next power of two is positive\n                // and overflow is checked.\n                Some(unsafe { Self::new_unchecked(nz) })\n            } else {\n                None\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// This is the same operation as\n        #[doc = concat!(\"[`\", stringify!($Int), \"::ilog2`],\")]\n        /// except that it has no failure cases to worry about\n        /// since this value can never be zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"assert_eq!(NonZero::new(7\", stringify!($Int), \")?.ilog2(), 2);\")]\n        #[doc = concat!(\"assert_eq!(NonZero::new(8\", stringify!($Int), \")?.ilog2(), 3);\")]\n        #[doc = concat!(\"assert_eq!(NonZero::new(9\", stringify!($Int), \")?.ilog2(), 3);\")]\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn ilog2(self) -> u32 {\n            Self::BITS - 1 - self.leading_zeros()\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// This is the same operation as\n        #[doc = concat!(\"[`\", stringify!($Int), \"::ilog10`],\")]\n        /// except that it has no failure cases to worry about\n        /// since this value can never be zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"assert_eq!(NonZero::new(99\", stringify!($Int), \")?.ilog10(), 1);\")]\n        #[doc = concat!(\"assert_eq!(NonZero::new(100\", stringify!($Int), \")?.ilog10(), 2);\")]\n        #[doc = concat!(\"assert_eq!(NonZero::new(101\", stringify!($Int), \")?.ilog10(), 2);\")]\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn ilog10(self) -> u32 {\n            super::int_log10::$Int(self.get())\n        }\n\n        /// Calculates the midpoint (average) between `self` and `rhs`.\n        ///\n        /// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a\n        /// sufficiently-large signed integral type. This implies that the result is\n        /// always rounded towards negative infinity and that no overflow will ever occur.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let one = NonZero::new(1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n        ///\n        /// assert_eq!(one.midpoint(four), two);\n        /// assert_eq!(four.midpoint(one), two);\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"num_midpoint\", since = \"1.85.0\")]\n        #[rustc_const_stable(feature = \"num_midpoint\", since = \"1.85.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[doc(alias = \"average_floor\")]\n        #[doc(alias = \"average\")]\n        #[inline]\n        pub const fn midpoint(self, rhs: Self) -> Self {\n            // SAFETY: The only way to get `0` with midpoint is to have two opposite or\n            // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because\n            // of the unsignedness of this number and also because `Self` is guaranteed to\n            // never being 0.\n            unsafe { Self::new_unchecked(self.get().midpoint(rhs.get())) }\n        }\n\n        /// Returns `true` if and only if `self == (1 << k)` for some `k`.\n        ///\n        /// On many architectures, this function can perform better than `is_power_of_two()`\n        /// on the underlying integer type, as special handling of zero can be avoided.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let eight = NonZero::new(8\", stringify!($Int), \")?;\")]\n        /// assert!(eight.is_power_of_two());\n        #[doc = concat!(\"let ten = NonZero::new(10\", stringify!($Int), \")?;\")]\n        /// assert!(!ten.is_power_of_two());\n        /// # Some(())\n        /// # }\n        /// ```\n        #[must_use]\n        #[stable(feature = \"nonzero_is_power_of_two\", since = \"1.59.0\")]\n        #[rustc_const_stable(feature = \"nonzero_is_power_of_two\", since = \"1.59.0\")]\n        #[inline]\n        pub const fn is_power_of_two(self) -> bool {\n            // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.\n            // On the basic x86-64 target, this saves 3 instructions for the zero check.\n            // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction\n            // compared to the `POPCNT` implementation on the underlying integer type.\n\n            intrinsics::ctpop(self.get()) < 2\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let ten = NonZero::new(10\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let three = NonZero::new(3\", stringify!($Int), \")?;\")]\n        ///\n        /// assert_eq!(ten.isqrt(), three);\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = self.get().isqrt();\n\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never cause\n            // the output to decrease. Thus, since the input for nonzero\n            // unsigned integers has a lower bound of 1, the lower bound of the\n            // results will be sqrt(1), which is 1, so a result can't be zero.\n            unsafe { Self::new_unchecked(result) }\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        ///\n        #[doc = concat!(\"let n = NonZero::<\", stringify!($Int), \">::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), NonZero::new(-1\", stringify!($Sint), \").unwrap());\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> NonZero<$Sint> {\n            // SAFETY: `self.get()` can't be zero\n            unsafe { NonZero::new_unchecked(self.get().cast_signed()) }\n        }\n    };\n\n    // Associated items for signed nonzero types only.\n    (\n        Primitive = signed $Int:ident,\n        SignedPrimitive = $Sint:ty,\n        UnsignedPrimitive = $Uint:ty,\n    ) => {\n        /// The smallest value that can be represented by this non-zero\n        /// integer type,\n        #[doc = concat!(\"equal to [`\", stringify!($Int), \"::MIN`].\")]\n        ///\n        /// Note: While most integer types are defined for every whole\n        /// number between `MIN` and `MAX`, signed non-zero integers are\n        /// a special case. They have a \"gap\" at 0.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        #[doc = concat!(\"assert_eq!(NonZero::<\", stringify!($Int), \">::MIN.get(), \", stringify!($Int), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"nonzero_min_max\", since = \"1.70.0\")]\n        pub const MIN: Self = Self::new(<$Int>::MIN).unwrap();\n\n        /// The largest value that can be represented by this non-zero\n        /// integer type,\n        #[doc = concat!(\"equal to [`\", stringify!($Int), \"::MAX`].\")]\n        ///\n        /// Note: While most integer types are defined for every whole\n        /// number between `MIN` and `MAX`, signed non-zero integers are\n        /// a special case. They have a \"gap\" at 0.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        #[doc = concat!(\"assert_eq!(NonZero::<\", stringify!($Int), \">::MAX.get(), \", stringify!($Int), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"nonzero_min_max\", since = \"1.70.0\")]\n        pub const MAX: Self = Self::new(<$Int>::MAX).unwrap();\n\n        /// Computes the absolute value of self.\n        #[doc = concat!(\"See [`\", stringify!($Int), \"::abs`]\")]\n        /// for documentation on overflow behavior.\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos = NonZero::new(1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg = NonZero::new(-1\", stringify!($Int), \")?;\")]\n        ///\n        /// assert_eq!(pos, pos.abs());\n        /// assert_eq!(pos, neg.abs());\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs(self) -> Self {\n            // SAFETY: This cannot overflow to zero.\n            unsafe { Self::new_unchecked(self.get().abs()) }\n        }\n\n        /// Checked absolute value.\n        /// Checks for overflow and returns [`None`] if\n        #[doc = concat!(\"`self == NonZero::<\", stringify!($Int), \">::MIN`.\")]\n        /// The result cannot be zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos = NonZero::new(1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg = NonZero::new(-1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let min = NonZero::new(\", stringify!($Int), \"::MIN)?;\")]\n        ///\n        /// assert_eq!(Some(pos), neg.checked_abs());\n        /// assert_eq!(None, min.checked_abs());\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_abs(self) -> Option<Self> {\n            if let Some(nz) = self.get().checked_abs() {\n                // SAFETY: absolute value of nonzero cannot yield zero values.\n                Some(unsafe { Self::new_unchecked(nz) })\n            } else {\n                None\n            }\n        }\n\n        /// Computes the absolute value of self,\n        /// with overflow information, see\n        #[doc = concat!(\"[`\", stringify!($Int), \"::overflowing_abs`].\")]\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos = NonZero::new(1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg = NonZero::new(-1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let min = NonZero::new(\", stringify!($Int), \"::MIN)?;\")]\n        ///\n        /// assert_eq!((pos, false), pos.overflowing_abs());\n        /// assert_eq!((pos, false), neg.overflowing_abs());\n        /// assert_eq!((min, true), min.overflowing_abs());\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_abs(self) -> (Self, bool) {\n            let (nz, flag) = self.get().overflowing_abs();\n            (\n                // SAFETY: absolute value of nonzero cannot yield zero values.\n                unsafe { Self::new_unchecked(nz) },\n                flag,\n            )\n        }\n\n        /// Saturating absolute value, see\n        #[doc = concat!(\"[`\", stringify!($Int), \"::saturating_abs`].\")]\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos = NonZero::new(1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg = NonZero::new(-1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let min = NonZero::new(\", stringify!($Int), \"::MIN)?;\")]\n        #[doc = concat!(\"let min_plus = NonZero::new(\", stringify!($Int), \"::MIN + 1)?;\")]\n        #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n        ///\n        /// assert_eq!(pos, pos.saturating_abs());\n        /// assert_eq!(pos, neg.saturating_abs());\n        /// assert_eq!(max, min.saturating_abs());\n        /// assert_eq!(max, min_plus.saturating_abs());\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_abs(self) -> Self {\n            // SAFETY: absolute value of nonzero cannot yield zero values.\n            unsafe { Self::new_unchecked(self.get().saturating_abs()) }\n        }\n\n        /// Wrapping absolute value, see\n        #[doc = concat!(\"[`\", stringify!($Int), \"::wrapping_abs`].\")]\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos = NonZero::new(1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg = NonZero::new(-1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let min = NonZero::new(\", stringify!($Int), \"::MIN)?;\")]\n        #[doc = concat!(\"# let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n        ///\n        /// assert_eq!(pos, pos.wrapping_abs());\n        /// assert_eq!(pos, neg.wrapping_abs());\n        /// assert_eq!(min, min.wrapping_abs());\n        /// assert_eq!(max, (-max).wrapping_abs());\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_abs(self) -> Self {\n            // SAFETY: absolute value of nonzero cannot yield zero values.\n            unsafe { Self::new_unchecked(self.get().wrapping_abs()) }\n        }\n\n        /// Computes the absolute value of self\n        /// without any wrapping or panicking.\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let u_pos = NonZero::new(1\", stringify!($Uint), \")?;\")]\n        #[doc = concat!(\"let i_pos = NonZero::new(1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let i_neg = NonZero::new(-1\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let i_min = NonZero::new(\", stringify!($Int), \"::MIN)?;\")]\n        #[doc = concat!(\"let u_max = NonZero::new(\", stringify!($Uint), \"::MAX / 2 + 1)?;\")]\n        ///\n        /// assert_eq!(u_pos, i_pos.unsigned_abs());\n        /// assert_eq!(u_pos, i_neg.unsigned_abs());\n        /// assert_eq!(u_max, i_min.unsigned_abs());\n        /// # Some(())\n        /// # }\n        /// ```\n        #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unsigned_abs(self) -> NonZero<$Uint> {\n            // SAFETY: absolute value of nonzero cannot yield zero values.\n            unsafe { NonZero::new_unchecked(self.get().unsigned_abs()) }\n        }\n\n        /// Returns `true` if `self` is positive and `false` if the\n        /// number is negative.\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos_five = NonZero::new(5\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg_five = NonZero::new(-5\", stringify!($Int), \")?;\")]\n        ///\n        /// assert!(pos_five.is_positive());\n        /// assert!(!neg_five.is_positive());\n        /// # Some(())\n        /// # }\n        /// ```\n        #[must_use]\n        #[inline]\n        #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        pub const fn is_positive(self) -> bool {\n            self.get().is_positive()\n        }\n\n        /// Returns `true` if `self` is negative and `false` if the\n        /// number is positive.\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos_five = NonZero::new(5\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg_five = NonZero::new(-5\", stringify!($Int), \")?;\")]\n        ///\n        /// assert!(neg_five.is_negative());\n        /// assert!(!pos_five.is_negative());\n        /// # Some(())\n        /// # }\n        /// ```\n        #[must_use]\n        #[inline]\n        #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        pub const fn is_negative(self) -> bool {\n            self.get().is_negative()\n        }\n\n        /// Checked negation. Computes `-self`,\n        #[doc = concat!(\"returning `None` if `self == NonZero::<\", stringify!($Int), \">::MIN`.\")]\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos_five = NonZero::new(5\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg_five = NonZero::new(-5\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let min = NonZero::new(\", stringify!($Int), \"::MIN)?;\")]\n        ///\n        /// assert_eq!(pos_five.checked_neg(), Some(neg_five));\n        /// assert_eq!(min.checked_neg(), None);\n        /// # Some(())\n        /// # }\n        /// ```\n        #[inline]\n        #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        pub const fn checked_neg(self) -> Option<Self> {\n            if let Some(result) = self.get().checked_neg() {\n                // SAFETY: negation of nonzero cannot yield zero values.\n                return Some(unsafe { Self::new_unchecked(result) });\n            }\n            None\n        }\n\n        /// Negates self, overflowing if this is equal to the minimum value.\n        ///\n        #[doc = concat!(\"See [`\", stringify!($Int), \"::overflowing_neg`]\")]\n        /// for documentation on overflow behavior.\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos_five = NonZero::new(5\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg_five = NonZero::new(-5\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let min = NonZero::new(\", stringify!($Int), \"::MIN)?;\")]\n        ///\n        /// assert_eq!(pos_five.overflowing_neg(), (neg_five, false));\n        /// assert_eq!(min.overflowing_neg(), (min, true));\n        /// # Some(())\n        /// # }\n        /// ```\n        #[inline]\n        #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            let (result, overflow) = self.get().overflowing_neg();\n            // SAFETY: negation of nonzero cannot yield zero values.\n            ((unsafe { Self::new_unchecked(result) }), overflow)\n        }\n\n        /// Saturating negation. Computes `-self`,\n        #[doc = concat!(\"returning [`NonZero::<\", stringify!($Int), \">::MAX`]\")]\n        #[doc = concat!(\"if `self == NonZero::<\", stringify!($Int), \">::MIN`\")]\n        /// instead of overflowing.\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos_five = NonZero::new(5\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg_five = NonZero::new(-5\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let min = NonZero::new(\", stringify!($Int), \"::MIN)?;\")]\n        #[doc = concat!(\"let min_plus_one = NonZero::new(\", stringify!($Int), \"::MIN + 1)?;\")]\n        #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n        ///\n        /// assert_eq!(pos_five.saturating_neg(), neg_five);\n        /// assert_eq!(min.saturating_neg(), max);\n        /// assert_eq!(max.saturating_neg(), min_plus_one);\n        /// # Some(())\n        /// # }\n        /// ```\n        #[inline]\n        #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        pub const fn saturating_neg(self) -> Self {\n            if let Some(result) = self.checked_neg() {\n                return result;\n            }\n            Self::MAX\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n        /// of the type.\n        ///\n        #[doc = concat!(\"See [`\", stringify!($Int), \"::wrapping_neg`]\")]\n        /// for documentation on overflow behavior.\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        /// #\n        /// # fn main() { test().unwrap(); }\n        /// # fn test() -> Option<()> {\n        #[doc = concat!(\"let pos_five = NonZero::new(5\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let neg_five = NonZero::new(-5\", stringify!($Int), \")?;\")]\n        #[doc = concat!(\"let min = NonZero::new(\", stringify!($Int), \"::MIN)?;\")]\n        ///\n        /// assert_eq!(pos_five.wrapping_neg(), neg_five);\n        /// assert_eq!(min.wrapping_neg(), min);\n        /// # Some(())\n        /// # }\n        /// ```\n        #[inline]\n        #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        pub const fn wrapping_neg(self) -> Self {\n            let result = self.get().wrapping_neg();\n            // SAFETY: negation of nonzero cannot yield zero values.\n            unsafe { Self::new_unchecked(result) }\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as an unsigned integer of the same size.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::num::NonZero;\n        ///\n        #[doc = concat!(\"let n = NonZero::new(-1\", stringify!($Int), \").unwrap();\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_unsigned(), NonZero::<\", stringify!($Uint), \">::MAX);\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_unsigned(self) -> NonZero<$Uint> {\n            // SAFETY: `self.get()` can't be zero\n            unsafe { NonZero::new_unchecked(self.get().cast_unsigned()) }\n        }\n\n    };\n}"
    },
    {
      "callsite": "nonzero_integer! {\n            #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n            Self = $Ty,\n            Primitive = unsigned $Int,\n            SignedPrimitive = $Sint,\n            UnsignedPrimitive = $Int,\n            rot = $rot,\n            rot_op = $rot_op,\n            rot_result = $rot_result,\n            swap_op = $swap_op,\n            swapped = $swapped,\n            reversed = $reversed,\n            leading_zeros_test = concat!(stringify!($Int), \"::MAX\"),\n        }",
      "defsite": "macro_rules! nonzero_integer {\n    (\n        #[$stability:meta]\n        Self = $Ty:ident,\n        Primitive = $signedness:ident $Int:ident,\n        SignedPrimitive = $Sint:ty,\n        UnsignedPrimitive = $Uint:ty,\n\n        // Used in doc comments.\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        leading_zeros_test = $leading_zeros_test:expr,\n    ) => {\n        #[doc = sign_dependent_expr!{\n            $signedness ?\n            if signed {\n                concat!(\"An [`\", stringify!($Int), \"`] that is known not to equal zero.\")\n            }\n            if unsigned {\n                concat!(\"A [`\", stringify!($Int), \"`] that is known not to equal zero.\")\n            }\n        }]\n        ///\n        /// This enables some memory layout optimization.\n        #[doc = concat!(\"For example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\")]\n        ///\n        /// ```rust\n        #[doc = concat!(\"assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int), \">());\")]\n        /// ```\n        ///\n        /// # Layout\n        ///\n        #[doc = concat!(\"`\", stringify!($Ty), \"` is guaranteed to have the same layout and bit validity as `\", stringify!($Int), \"`\")]\n        /// with the exception that `0` is not a valid instance.\n        #[doc = concat!(\"`Option<\", stringify!($Ty), \">` is guaranteed to be compatible with `\", stringify!($Int), \"`,\")]\n        /// including in FFI.\n        ///\n        /// Thanks to the [null pointer optimization],\n        #[doc = concat!(\"`\", stringify!($Ty), \"` and `Option<\", stringify!($Ty), \">`\")]\n        /// are guaranteed to have the same size and alignment:\n        ///\n        /// ```\n        #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(size_of::<\", stringify!($Ty), \">(), size_of::<Option<\", stringify!($Ty), \">>());\")]\n        #[doc = concat!(\"assert_eq!(align_of::<\", stringify!($Ty), \">(), align_of::<Option<\", stringify!($Ty), \">>());\")]\n        /// ```\n        ///\n        /// [null pointer optimization]: crate::option#representation\n        #[$stability]\n        pub type $Ty = NonZero<$Int>;\n\n        impl NonZero<$Int> {\n            /// The size of this non-zero integer type in bits.\n            ///\n            #[doc = concat!(\"This value is equal to [`\", stringify!($Int), \"::BITS`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            #[doc = concat!(\"assert_eq!(NonZero::<\", stringify!($Int), \">::BITS, \", stringify!($Int), \"::BITS);\")]\n            /// ```\n            #[stable(feature = \"nonzero_bits\", since = \"1.67.0\")]\n            pub const BITS: u32 = <$Int>::BITS;\n\n            /// Returns the number of leading zeros in the binary representation of `self`.\n            ///\n            /// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::<\", stringify!($Int), \">::new(\", $leading_zeros_test, \")?;\")]\n            ///\n            /// assert_eq!(n.leading_zeros(), 0);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[rustc_const_stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn leading_zeros(self) -> u32 {\n                // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.\n                unsafe {\n                    intrinsics::ctlz_nonzero(self.get() as $Uint)\n                }\n            }\n\n            /// Returns the number of trailing zeros in the binary representation\n            /// of `self`.\n            ///\n            /// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::<\", stringify!($Int), \">::new(0b0101000)?;\")]\n            ///\n            /// assert_eq!(n.trailing_zeros(), 3);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[rustc_const_stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn trailing_zeros(self) -> u32 {\n                // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.\n                unsafe {\n                    intrinsics::cttz_nonzero(self.get() as $Uint)\n                }\n            }\n\n            /// Returns `self` with only the most significant bit set.\n            ///\n            /// # Example\n            ///\n            /// ```\n            /// #![feature(isolate_most_least_significant_one)]\n            ///\n            /// # use core::num::NonZero;\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b_01100100)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b_01000000)?;\")]\n            ///\n            /// assert_eq!(a.isolate_most_significant_one(), b);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn isolate_most_significant_one(self) -> Self {\n                let n = self.get() & (((1 as $Int) << (<$Int>::BITS - 1)).wrapping_shr(self.leading_zeros()));\n\n                // SAFETY:\n                // `self` is non-zero, so masking to preserve only the most\n                // significant set bit will result in a non-zero `n`.\n                unsafe { NonZero::new_unchecked(n) }\n            }\n\n            /// Returns `self` with only the least significant bit set.\n            ///\n            /// # Example\n            ///\n            /// ```\n            /// #![feature(isolate_most_least_significant_one)]\n            ///\n            /// # use core::num::NonZero;\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b_01100100)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b_00000100)?;\")]\n            ///\n            /// assert_eq!(a.isolate_least_significant_one(), b);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn isolate_least_significant_one(self) -> Self {\n                let n = self.get();\n                let n = n & n.wrapping_neg();\n\n                // SAFETY: `self` is non-zero, so `self` with only its least\n                // significant set bit will remain non-zero.\n                unsafe { NonZero::new_unchecked(n) }\n            }\n\n            /// Returns the number of ones in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b100_0000)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b100_0011)?;\")]\n            ///\n            /// assert_eq!(a.count_ones(), NonZero::new(1)?);\n            /// assert_eq!(b.count_ones(), NonZero::new(3)?);\n            /// # Some(())\n            /// # }\n            /// ```\n            ///\n            #[stable(feature = \"non_zero_count_ones\", since = \"1.86.0\")]\n            #[rustc_const_stable(feature = \"non_zero_count_ones\", since = \"1.86.0\")]\n            #[doc(alias = \"popcount\")]\n            #[doc(alias = \"popcnt\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() > 0)]\n            pub const fn count_ones(self) -> NonZero<u32> {\n                // SAFETY:\n                // `self` is non-zero, which means it has at least one bit set, which means\n                // that the result of `count_ones` is non-zero.\n                unsafe { NonZero::new_unchecked(self.get().count_ones()) }\n            }\n\n            /// Shifts the bits to the left by a specified amount, `n`,\n            /// wrapping the truncated bits to the end of the resulting integer.\n            ///\n            /// Please note this isn't the same operation as the `<<` shifting operator!\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $rot_op, stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let m = NonZero::new(\", $rot_result, \")?;\")]\n            ///\n            #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() != 0)]\n            #[ensures(|result| result.rotate_right(n).get() == old(self).get())]\n            pub const fn rotate_left(self, n: u32) -> Self {\n                let result = self.get().rotate_left(n);\n                // SAFETY: Rotating bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Shifts the bits to the right by a specified amount, `n`,\n            /// wrapping the truncated bits to the beginning of the resulting\n            /// integer.\n            ///\n            /// Please note this isn't the same operation as the `>>` shifting operator!\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $rot_result, stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let m = NonZero::new(\", $rot_op, \")?;\")]\n            ///\n            #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() != 0)]\n            #[ensures(|result| result.rotate_left(n).get() == old(self).get())]\n            pub const fn rotate_right(self, n: u32) -> Self {\n                let result = self.get().rotate_right(n);\n                // SAFETY: Rotating bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Reverses the byte order of the integer.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $swap_op, stringify!($Int), \")?;\")]\n            /// let m = n.swap_bytes();\n            ///\n            #[doc = concat!(\"assert_eq!(m, NonZero::new(\", $swapped, \")?);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn swap_bytes(self) -> Self {\n                let result = self.get().swap_bytes();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n            /// second least-significant bit becomes second most-significant bit, etc.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $swap_op, stringify!($Int), \")?;\")]\n            /// let m = n.reverse_bits();\n            ///\n            #[doc = concat!(\"assert_eq!(m, NonZero::new(\", $reversed, \")?);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn reverse_bits(self) -> Self {\n                let result = self.get().reverse_bits();\n                // SAFETY: Reversing bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts an integer from big endian to the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_be(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_be(n), n.swap_bytes())\")]\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use]\n            #[inline(always)]\n            pub const fn from_be(x: Self) -> Self {\n                let result = $Int::from_be(x.get());\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts an integer from little endian to the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_le(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_le(n), n.swap_bytes())\")]\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use]\n            #[inline(always)]\n            pub const fn from_le(x: Self) -> Self {\n                let result = $Int::from_le(x.get());\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts `self` to big endian from the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            ///     assert_eq!(n.to_be(), n)\n            /// } else {\n            ///     assert_eq!(n.to_be(), n.swap_bytes())\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn to_be(self) -> Self {\n                let result = self.get().to_be();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts `self` to little endian from the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            ///     assert_eq!(n.to_le(), n)\n            /// } else {\n            ///     assert_eq!(n.to_le(), n.swap_bytes())\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn to_le(self) -> Self {\n                let result = self.get().to_le();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            nonzero_integer_signedness_dependent_methods! {\n                Primitive = $signedness $Int,\n                SignedPrimitive = $Sint,\n                UnsignedPrimitive = $Uint,\n            }\n\n            /// Multiplies two non-zero integers together.\n            /// Checks for overflow and returns [`None`] on overflow.\n            /// As a consequence, the result cannot wrap to zero.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(Some(four), two.checked_mul(two));\n            /// assert_eq!(None, max.checked_mul(two));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn checked_mul(self, other: Self) -> Option<Self> {\n                if let Some(result) = self.get().checked_mul(other.get()) {\n                    // SAFETY:\n                    // - `checked_mul` returns `None` on overflow\n                    // - `self` and `other` are non-zero\n                    // - the only way to get zero from a multiplication without overflow is for one\n                    //   of the sides to be zero\n                    //\n                    // So the result cannot be zero.\n                    Some(unsafe { Self::new_unchecked(result) })\n                } else {\n                    None\n                }\n            }\n\n            /// Multiplies two non-zero integers together.\n            #[doc = concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(four, two.saturating_mul(two));\n            /// assert_eq!(max, four.saturating_mul(max));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_mul(self, other: Self) -> Self {\n                // SAFETY:\n                // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,\n                //   all of which are non-zero\n                // - `self` and `other` are non-zero\n                // - the only way to get zero from a multiplication without overflow is for one\n                //   of the sides to be zero\n                //\n                // So the result cannot be zero.\n                unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }\n            }\n\n            /// Multiplies two non-zero integers together,\n            /// assuming overflow cannot occur.\n            /// Overflow is unchecked, and it is undefined behavior to overflow\n            /// *even if the result would wrap to a non-zero value*.\n            /// The behavior is undefined as soon as\n            #[doc = sign_dependent_expr!{\n                $signedness ?\n                if signed {\n                    concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`, \",\n                            \"or `self * rhs < \", stringify!($Int), \"::MIN`.\")\n                }\n                if unsigned {\n                    concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`.\")\n                }\n            }]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_ops)]\n            ///\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            ///\n            /// assert_eq!(four, unsafe { two.unchecked_mul(two) });\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            #[requires({\n                self.get().checked_mul(other.get()).is_some()\n            })]\n            #[ensures(|result: &Self| {\n                self.get().checked_mul(other.get()).is_some_and(|product| product == result.get())\n            })]\n            pub const unsafe fn unchecked_mul(self, other: Self) -> Self {\n                // SAFETY: The caller ensures there is no overflow.\n                unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }\n            }\n\n            /// Raises non-zero value to an integer power.\n            /// Checks for overflow and returns [`None`] on overflow.\n            /// As a consequence, the result cannot wrap to zero.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let three = NonZero::new(3\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let twenty_seven = NonZero::new(27\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let half_max = NonZero::new(\", stringify!($Int), \"::MAX / 2)?;\")]\n            ///\n            /// assert_eq!(Some(twenty_seven), three.checked_pow(3));\n            /// assert_eq!(None, half_max.checked_pow(3));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn checked_pow(self, other: u32) -> Option<Self> {\n                if let Some(result) = self.get().checked_pow(other) {\n                    // SAFETY:\n                    // - `checked_pow` returns `None` on overflow/underflow\n                    // - `self` is non-zero\n                    // - the only way to get zero from an exponentiation without overflow is\n                    //   for base to be zero\n                    //\n                    // So the result cannot be zero.\n                    Some(unsafe { Self::new_unchecked(result) })\n                } else {\n                    None\n                }\n            }\n\n            /// Raise non-zero value to an integer power.\n            #[doc = sign_dependent_expr!{\n                $signedness ?\n                if signed {\n                    concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MIN`] \",\n                                \"or [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")\n                }\n                if unsigned {\n                    concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")\n                }\n            }]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let three = NonZero::new(3\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let twenty_seven = NonZero::new(27\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(twenty_seven, three.saturating_pow(3));\n            /// assert_eq!(max, max.saturating_pow(3));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_pow(self, other: u32) -> Self {\n                // SAFETY:\n                // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,\n                //   all of which are non-zero\n                // - `self` is non-zero\n                // - the only way to get zero from an exponentiation without overflow is\n                //   for base to be zero\n                //\n                // So the result cannot be zero.\n                unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }\n            }\n        }\n\n        #[stable(feature = \"nonzero_parse\", since = \"1.35.0\")]\n        impl FromStr for NonZero<$Int> {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, Self::Err> {\n                Self::new(<$Int>::from_str_radix(src, 10)?)\n                    .ok_or(ParseIntError {\n                        kind: IntErrorKind::Zero\n                    })\n            }\n        }\n\n        nonzero_integer_signedness_dependent_impls!($signedness $Int);\n    };\n\n    (\n        Self = $Ty:ident,\n        Primitive = unsigned $Int:ident,\n        SignedPrimitive = $Sint:ident,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        $(,)?\n    ) => {\n        nonzero_integer! {\n            #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n            Self = $Ty,\n            Primitive = unsigned $Int,\n            SignedPrimitive = $Sint,\n            UnsignedPrimitive = $Int,\n            rot = $rot,\n            rot_op = $rot_op,\n            rot_result = $rot_result,\n            swap_op = $swap_op,\n            swapped = $swapped,\n            reversed = $reversed,\n            leading_zeros_test = concat!(stringify!($Int), \"::MAX\"),\n        }\n    };\n\n    (\n        Self = $Ty:ident,\n        Primitive = signed $Int:ident,\n        UnsignedPrimitive = $Uint:ident,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n    ) => {\n        nonzero_integer! {\n            #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\n            Self = $Ty,\n            Primitive = signed $Int,\n            SignedPrimitive = $Int,\n            UnsignedPrimitive = $Uint,\n            rot = $rot,\n            rot_op = $rot_op,\n            rot_result = $rot_result,\n            swap_op = $swap_op,\n            swapped = $swapped,\n            reversed = $reversed,\n            leading_zeros_test = concat!(\"-1\", stringify!($Int)),\n        }\n    };\n}"
    },
    {
      "callsite": "nonzero_integer! {\n    Self = NonZeroU32,\n    Primitive = unsigned u32,\n    SignedPrimitive = i32,\n    rot = 8,\n    rot_op = \"0x10000b3\",\n    rot_result = \"0xb301\",\n    swap_op = \"0x12345678\",\n    swapped = \"0x78563412\",\n    reversed = \"0x1e6a2c48\",\n}",
      "defsite": "macro_rules! nonzero_integer {\n    (\n        #[$stability:meta]\n        Self = $Ty:ident,\n        Primitive = $signedness:ident $Int:ident,\n        SignedPrimitive = $Sint:ty,\n        UnsignedPrimitive = $Uint:ty,\n\n        // Used in doc comments.\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        leading_zeros_test = $leading_zeros_test:expr,\n    ) => {\n        #[doc = sign_dependent_expr!{\n            $signedness ?\n            if signed {\n                concat!(\"An [`\", stringify!($Int), \"`] that is known not to equal zero.\")\n            }\n            if unsigned {\n                concat!(\"A [`\", stringify!($Int), \"`] that is known not to equal zero.\")\n            }\n        }]\n        ///\n        /// This enables some memory layout optimization.\n        #[doc = concat!(\"For example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\")]\n        ///\n        /// ```rust\n        #[doc = concat!(\"assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int), \">());\")]\n        /// ```\n        ///\n        /// # Layout\n        ///\n        #[doc = concat!(\"`\", stringify!($Ty), \"` is guaranteed to have the same layout and bit validity as `\", stringify!($Int), \"`\")]\n        /// with the exception that `0` is not a valid instance.\n        #[doc = concat!(\"`Option<\", stringify!($Ty), \">` is guaranteed to be compatible with `\", stringify!($Int), \"`,\")]\n        /// including in FFI.\n        ///\n        /// Thanks to the [null pointer optimization],\n        #[doc = concat!(\"`\", stringify!($Ty), \"` and `Option<\", stringify!($Ty), \">`\")]\n        /// are guaranteed to have the same size and alignment:\n        ///\n        /// ```\n        #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(size_of::<\", stringify!($Ty), \">(), size_of::<Option<\", stringify!($Ty), \">>());\")]\n        #[doc = concat!(\"assert_eq!(align_of::<\", stringify!($Ty), \">(), align_of::<Option<\", stringify!($Ty), \">>());\")]\n        /// ```\n        ///\n        /// [null pointer optimization]: crate::option#representation\n        #[$stability]\n        pub type $Ty = NonZero<$Int>;\n\n        impl NonZero<$Int> {\n            /// The size of this non-zero integer type in bits.\n            ///\n            #[doc = concat!(\"This value is equal to [`\", stringify!($Int), \"::BITS`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            #[doc = concat!(\"assert_eq!(NonZero::<\", stringify!($Int), \">::BITS, \", stringify!($Int), \"::BITS);\")]\n            /// ```\n            #[stable(feature = \"nonzero_bits\", since = \"1.67.0\")]\n            pub const BITS: u32 = <$Int>::BITS;\n\n            /// Returns the number of leading zeros in the binary representation of `self`.\n            ///\n            /// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::<\", stringify!($Int), \">::new(\", $leading_zeros_test, \")?;\")]\n            ///\n            /// assert_eq!(n.leading_zeros(), 0);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[rustc_const_stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn leading_zeros(self) -> u32 {\n                // SAFETY: since `self` cannot be zero, it is safe to call `ctlz_nonzero`.\n                unsafe {\n                    intrinsics::ctlz_nonzero(self.get() as $Uint)\n                }\n            }\n\n            /// Returns the number of trailing zeros in the binary representation\n            /// of `self`.\n            ///\n            /// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::<\", stringify!($Int), \">::new(0b0101000)?;\")]\n            ///\n            /// assert_eq!(n.trailing_zeros(), 3);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[rustc_const_stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn trailing_zeros(self) -> u32 {\n                // SAFETY: since `self` cannot be zero, it is safe to call `cttz_nonzero`.\n                unsafe {\n                    intrinsics::cttz_nonzero(self.get() as $Uint)\n                }\n            }\n\n            /// Returns `self` with only the most significant bit set.\n            ///\n            /// # Example\n            ///\n            /// ```\n            /// #![feature(isolate_most_least_significant_one)]\n            ///\n            /// # use core::num::NonZero;\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b_01100100)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b_01000000)?;\")]\n            ///\n            /// assert_eq!(a.isolate_most_significant_one(), b);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn isolate_most_significant_one(self) -> Self {\n                let n = self.get() & (((1 as $Int) << (<$Int>::BITS - 1)).wrapping_shr(self.leading_zeros()));\n\n                // SAFETY:\n                // `self` is non-zero, so masking to preserve only the most\n                // significant set bit will result in a non-zero `n`.\n                unsafe { NonZero::new_unchecked(n) }\n            }\n\n            /// Returns `self` with only the least significant bit set.\n            ///\n            /// # Example\n            ///\n            /// ```\n            /// #![feature(isolate_most_least_significant_one)]\n            ///\n            /// # use core::num::NonZero;\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b_01100100)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b_00000100)?;\")]\n            ///\n            /// assert_eq!(a.isolate_least_significant_one(), b);\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn isolate_least_significant_one(self) -> Self {\n                let n = self.get();\n                let n = n & n.wrapping_neg();\n\n                // SAFETY: `self` is non-zero, so `self` with only its least\n                // significant set bit will remain non-zero.\n                unsafe { NonZero::new_unchecked(n) }\n            }\n\n            /// Returns the number of ones in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let a = NonZero::<\", stringify!($Int), \">::new(0b100_0000)?;\")]\n            #[doc = concat!(\"let b = NonZero::<\", stringify!($Int), \">::new(0b100_0011)?;\")]\n            ///\n            /// assert_eq!(a.count_ones(), NonZero::new(1)?);\n            /// assert_eq!(b.count_ones(), NonZero::new(3)?);\n            /// # Some(())\n            /// # }\n            /// ```\n            ///\n            #[stable(feature = \"non_zero_count_ones\", since = \"1.86.0\")]\n            #[rustc_const_stable(feature = \"non_zero_count_ones\", since = \"1.86.0\")]\n            #[doc(alias = \"popcount\")]\n            #[doc(alias = \"popcnt\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() > 0)]\n            pub const fn count_ones(self) -> NonZero<u32> {\n                // SAFETY:\n                // `self` is non-zero, which means it has at least one bit set, which means\n                // that the result of `count_ones` is non-zero.\n                unsafe { NonZero::new_unchecked(self.get().count_ones()) }\n            }\n\n            /// Shifts the bits to the left by a specified amount, `n`,\n            /// wrapping the truncated bits to the end of the resulting integer.\n            ///\n            /// Please note this isn't the same operation as the `<<` shifting operator!\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $rot_op, stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let m = NonZero::new(\", $rot_result, \")?;\")]\n            ///\n            #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() != 0)]\n            #[ensures(|result| result.rotate_right(n).get() == old(self).get())]\n            pub const fn rotate_left(self, n: u32) -> Self {\n                let result = self.get().rotate_left(n);\n                // SAFETY: Rotating bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Shifts the bits to the right by a specified amount, `n`,\n            /// wrapping the truncated bits to the beginning of the resulting\n            /// integer.\n            ///\n            /// Please note this isn't the same operation as the `>>` shifting operator!\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $rot_result, stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let m = NonZero::new(\", $rot_op, \")?;\")]\n            ///\n            #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            #[ensures(|result| result.get() != 0)]\n            #[ensures(|result| result.rotate_left(n).get() == old(self).get())]\n            pub const fn rotate_right(self, n: u32) -> Self {\n                let result = self.get().rotate_right(n);\n                // SAFETY: Rotating bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Reverses the byte order of the integer.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $swap_op, stringify!($Int), \")?;\")]\n            /// let m = n.swap_bytes();\n            ///\n            #[doc = concat!(\"assert_eq!(m, NonZero::new(\", $swapped, \")?);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn swap_bytes(self) -> Self {\n                let result = self.get().swap_bytes();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n            /// second least-significant bit becomes second most-significant bit, etc.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(\", $swap_op, stringify!($Int), \")?;\")]\n            /// let m = n.reverse_bits();\n            ///\n            #[doc = concat!(\"assert_eq!(m, NonZero::new(\", $reversed, \")?);\")]\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn reverse_bits(self) -> Self {\n                let result = self.get().reverse_bits();\n                // SAFETY: Reversing bits preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts an integer from big endian to the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_be(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_be(n), n.swap_bytes())\")]\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use]\n            #[inline(always)]\n            pub const fn from_be(x: Self) -> Self {\n                let result = $Int::from_be(x.get());\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts an integer from little endian to the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            #[doc = concat!(\"use std::num::\", stringify!($Ty), \";\")]\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_le(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(\", stringify!($Ty), \"::from_le(n), n.swap_bytes())\")]\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use]\n            #[inline(always)]\n            pub const fn from_le(x: Self) -> Self {\n                let result = $Int::from_le(x.get());\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts `self` to big endian from the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            ///     assert_eq!(n.to_be(), n)\n            /// } else {\n            ///     assert_eq!(n.to_be(), n.swap_bytes())\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn to_be(self) -> Self {\n                let result = self.get().to_be();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            /// Converts `self` to little endian from the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_bitwise)]\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let n = NonZero::new(0x1A\", stringify!($Int), \")?;\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            ///     assert_eq!(n.to_le(), n)\n            /// } else {\n            ///     assert_eq!(n.to_le(), n.swap_bytes())\n            /// }\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_bitwise\", issue = \"128281\")]\n            #[must_use = \"this returns the result of the operation, \\\n                        without modifying the original\"]\n            #[inline(always)]\n            pub const fn to_le(self) -> Self {\n                let result = self.get().to_le();\n                // SAFETY: Shuffling bytes preserves the property int > 0.\n                unsafe { Self::new_unchecked(result) }\n            }\n\n            nonzero_integer_signedness_dependent_methods! {\n                Primitive = $signedness $Int,\n                SignedPrimitive = $Sint,\n                UnsignedPrimitive = $Uint,\n            }\n\n            /// Multiplies two non-zero integers together.\n            /// Checks for overflow and returns [`None`] on overflow.\n            /// As a consequence, the result cannot wrap to zero.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(Some(four), two.checked_mul(two));\n            /// assert_eq!(None, max.checked_mul(two));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn checked_mul(self, other: Self) -> Option<Self> {\n                if let Some(result) = self.get().checked_mul(other.get()) {\n                    // SAFETY:\n                    // - `checked_mul` returns `None` on overflow\n                    // - `self` and `other` are non-zero\n                    // - the only way to get zero from a multiplication without overflow is for one\n                    //   of the sides to be zero\n                    //\n                    // So the result cannot be zero.\n                    Some(unsafe { Self::new_unchecked(result) })\n                } else {\n                    None\n                }\n            }\n\n            /// Multiplies two non-zero integers together.\n            #[doc = concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(four, two.saturating_mul(two));\n            /// assert_eq!(max, four.saturating_mul(max));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_mul(self, other: Self) -> Self {\n                // SAFETY:\n                // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,\n                //   all of which are non-zero\n                // - `self` and `other` are non-zero\n                // - the only way to get zero from a multiplication without overflow is for one\n                //   of the sides to be zero\n                //\n                // So the result cannot be zero.\n                unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }\n            }\n\n            /// Multiplies two non-zero integers together,\n            /// assuming overflow cannot occur.\n            /// Overflow is unchecked, and it is undefined behavior to overflow\n            /// *even if the result would wrap to a non-zero value*.\n            /// The behavior is undefined as soon as\n            #[doc = sign_dependent_expr!{\n                $signedness ?\n                if signed {\n                    concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`, \",\n                            \"or `self * rhs < \", stringify!($Int), \"::MIN`.\")\n                }\n                if unsigned {\n                    concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`.\")\n                }\n            }]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(nonzero_ops)]\n            ///\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let two = NonZero::new(2\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let four = NonZero::new(4\", stringify!($Int), \")?;\")]\n            ///\n            /// assert_eq!(four, unsafe { two.unchecked_mul(two) });\n            /// # Some(())\n            /// # }\n            /// ```\n            #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            #[requires({\n                self.get().checked_mul(other.get()).is_some()\n            })]\n            #[ensures(|result: &Self| {\n                self.get().checked_mul(other.get()).is_some_and(|product| product == result.get())\n            })]\n            pub const unsafe fn unchecked_mul(self, other: Self) -> Self {\n                // SAFETY: The caller ensures there is no overflow.\n                unsafe { Self::new_unchecked(self.get().unchecked_mul(other.get())) }\n            }\n\n            /// Raises non-zero value to an integer power.\n            /// Checks for overflow and returns [`None`] on overflow.\n            /// As a consequence, the result cannot wrap to zero.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let three = NonZero::new(3\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let twenty_seven = NonZero::new(27\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let half_max = NonZero::new(\", stringify!($Int), \"::MAX / 2)?;\")]\n            ///\n            /// assert_eq!(Some(twenty_seven), three.checked_pow(3));\n            /// assert_eq!(None, half_max.checked_pow(3));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn checked_pow(self, other: u32) -> Option<Self> {\n                if let Some(result) = self.get().checked_pow(other) {\n                    // SAFETY:\n                    // - `checked_pow` returns `None` on overflow/underflow\n                    // - `self` is non-zero\n                    // - the only way to get zero from an exponentiation without overflow is\n                    //   for base to be zero\n                    //\n                    // So the result cannot be zero.\n                    Some(unsafe { Self::new_unchecked(result) })\n                } else {\n                    None\n                }\n            }\n\n            /// Raise non-zero value to an integer power.\n            #[doc = sign_dependent_expr!{\n                $signedness ?\n                if signed {\n                    concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MIN`] \",\n                                \"or [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")\n                }\n                if unsigned {\n                    concat!(\"Return [`NonZero::<\", stringify!($Int), \">::MAX`] on overflow.\")\n                }\n            }]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// # use std::num::NonZero;\n            /// #\n            /// # fn main() { test().unwrap(); }\n            /// # fn test() -> Option<()> {\n            #[doc = concat!(\"let three = NonZero::new(3\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let twenty_seven = NonZero::new(27\", stringify!($Int), \")?;\")]\n            #[doc = concat!(\"let max = NonZero::new(\", stringify!($Int), \"::MAX)?;\")]\n            ///\n            /// assert_eq!(twenty_seven, three.saturating_pow(3));\n            /// assert_eq!(max, max.saturating_pow(3));\n            /// # Some(())\n            /// # }\n            /// ```\n            #[stable(feature = \"nonzero_checked_ops\", since = \"1.64.0\")]\n            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_pow(self, other: u32) -> Self {\n                // SAFETY:\n                // - `saturating_pow` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,\n                //   all of which are non-zero\n                // - `self` is non-zero\n                // - the only way to get zero from an exponentiation without overflow is\n                //   for base to be zero\n                //\n                // So the result cannot be zero.\n                unsafe { Self::new_unchecked(self.get().saturating_pow(other)) }\n            }\n        }\n\n        #[stable(feature = \"nonzero_parse\", since = \"1.35.0\")]\n        impl FromStr for NonZero<$Int> {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, Self::Err> {\n                Self::new(<$Int>::from_str_radix(src, 10)?)\n                    .ok_or(ParseIntError {\n                        kind: IntErrorKind::Zero\n                    })\n            }\n        }\n\n        nonzero_integer_signedness_dependent_impls!($signedness $Int);\n    };\n\n    (\n        Self = $Ty:ident,\n        Primitive = unsigned $Int:ident,\n        SignedPrimitive = $Sint:ident,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        $(,)?\n    ) => {\n        nonzero_integer! {\n            #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n            Self = $Ty,\n            Primitive = unsigned $Int,\n            SignedPrimitive = $Sint,\n            UnsignedPrimitive = $Int,\n            rot = $rot,\n            rot_op = $rot_op,\n            rot_result = $rot_result,\n            swap_op = $swap_op,\n            swapped = $swapped,\n            reversed = $reversed,\n            leading_zeros_test = concat!(stringify!($Int), \"::MAX\"),\n        }\n    };\n\n    (\n        Self = $Ty:ident,\n        Primitive = signed $Int:ident,\n        UnsignedPrimitive = $Uint:ident,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n    ) => {\n        nonzero_integer! {\n            #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\n            Self = $Ty,\n            Primitive = signed $Int,\n            SignedPrimitive = $Int,\n            UnsignedPrimitive = $Uint,\n            rot = $rot,\n            rot_op = $rot_op,\n            rot_result = $rot_result,\n            swap_op = $swap_op,\n            swapped = $swapped,\n            reversed = $reversed,\n            leading_zeros_test = concat!(\"-1\", stringify!($Int)),\n        }\n    };\n}"
    }
  ],
  "callees": [
    "469731897247902151615947250155763551554",
    "36892355048508255759761394875650662945",
    "153953568740411547842071076677083183613"
  ]
}
