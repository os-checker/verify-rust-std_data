{
  "file": "core/src/num/mod.rs",
  "name": "num::<impl u128>::midpoint",
  "hash": "1339968946229866764617084945979056956395",
  "hash_direct": "1110681381079059192513787252568561678553",
  "src": "pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {\n            // Use the well known branchless algorithm from Hacker's Delight to compute\n            // `(a + b) / 2` without overflowing: `((a ^ b) >> 1) + (a & b)`.\n            ((self ^ rhs) >> 1) + (self & rhs)\n        }",
  "macro_backtrace": [
    {
      "callsite": "midpoint_impl! { u128, unsigned }",
      "defsite": "macro_rules! midpoint_impl {\n    ($SelfT:ty, unsigned) => {\n        /// Calculates the midpoint (average) between `self` and `rhs`.\n        ///\n        /// `midpoint(a, b)` is `(a + b) / 2` as if it were performed in a\n        /// sufficiently-large unsigned integral type. This implies that the result is\n        /// always rounded towards zero and that no overflow will ever occur.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(4), 2);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".midpoint(4), 2);\")]\n        /// ```\n        #[stable(feature = \"num_midpoint\", since = \"1.85.0\")]\n        #[rustc_const_stable(feature = \"num_midpoint\", since = \"1.85.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[doc(alias = \"average_floor\")]\n        #[doc(alias = \"average\")]\n        #[inline]\n        pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {\n            // Use the well known branchless algorithm from Hacker's Delight to compute\n            // `(a + b) / 2` without overflowing: `((a ^ b) >> 1) + (a & b)`.\n            ((self ^ rhs) >> 1) + (self & rhs)\n        }\n    };\n    ($SelfT:ty, signed) => {\n        /// Calculates the midpoint (average) between `self` and `rhs`.\n        ///\n        /// `midpoint(a, b)` is `(a + b) / 2` as if it were performed in a\n        /// sufficiently-large signed integral type. This implies that the result is\n        /// always rounded towards zero and that no overflow will ever occur.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(4), 2);\")]\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").midpoint(2), 0);\")]\n        #[doc = concat!(\"assert_eq!((-7\", stringify!($SelfT), \").midpoint(0), -3);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(-7), -3);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(7), 3);\")]\n        /// ```\n        #[stable(feature = \"num_midpoint_signed\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"num_midpoint_signed\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[doc(alias = \"average_floor\")]\n        #[doc(alias = \"average_ceil\")]\n        #[doc(alias = \"average\")]\n        #[inline]\n        pub const fn midpoint(self, rhs: Self) -> Self {\n            // Use the well known branchless algorithm from Hacker's Delight to compute\n            // `(a + b) / 2` without overflowing: `((a ^ b) >> 1) + (a & b)`.\n            let t = ((self ^ rhs) >> 1) + (self & rhs);\n            // Except that it fails for integers whose sum is an odd negative number as\n            // their floor is one less than their average. So we adjust the result.\n            t + (if t < 0 { 1 } else { 0 } & (self ^ rhs))\n        }\n    };\n    ($SelfT:ty, $WideT:ty, unsigned) => {\n        /// Calculates the midpoint (average) between `self` and `rhs`.\n        ///\n        /// `midpoint(a, b)` is `(a + b) / 2` as if it were performed in a\n        /// sufficiently-large unsigned integral type. This implies that the result is\n        /// always rounded towards zero and that no overflow will ever occur.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(4), 2);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".midpoint(4), 2);\")]\n        /// ```\n        #[stable(feature = \"num_midpoint\", since = \"1.85.0\")]\n        #[rustc_const_stable(feature = \"num_midpoint\", since = \"1.85.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[doc(alias = \"average_floor\")]\n        #[doc(alias = \"average\")]\n        #[inline]\n        pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {\n            ((self as $WideT + rhs as $WideT) / 2) as $SelfT\n        }\n    };\n    ($SelfT:ty, $WideT:ty, signed) => {\n        /// Calculates the midpoint (average) between `self` and `rhs`.\n        ///\n        /// `midpoint(a, b)` is `(a + b) / 2` as if it were performed in a\n        /// sufficiently-large signed integral type. This implies that the result is\n        /// always rounded towards zero and that no overflow will ever occur.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(4), 2);\")]\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").midpoint(2), 0);\")]\n        #[doc = concat!(\"assert_eq!((-7\", stringify!($SelfT), \").midpoint(0), -3);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(-7), -3);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(7), 3);\")]\n        /// ```\n        #[stable(feature = \"num_midpoint_signed\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"num_midpoint_signed\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[doc(alias = \"average_floor\")]\n        #[doc(alias = \"average_ceil\")]\n        #[doc(alias = \"average\")]\n        #[inline]\n        pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {\n            ((self as $WideT + rhs as $WideT) / 2) as $SelfT\n        }\n    };\n}"
    }
  ]
}
