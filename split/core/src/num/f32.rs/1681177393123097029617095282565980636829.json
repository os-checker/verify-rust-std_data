{
  "file": "core/src/num/f32.rs",
  "name": "f32::<impl f32>::next_down",
  "hash": "1681177393123097029617095282565980636829",
  "hash_direct": "26884425506113425235876052964781342712",
  "src": "pub const fn next_down(self) -> Self {\n        // Some targets violate Rust's assumption of IEEE semantics, e.g. by flushing\n        // denormals to zero. This is in general unsound and unsupported, but here\n        // we do our best to still produce the correct result on such targets.\n        let bits = self.to_bits();\n        if self.is_nan() || bits == Self::NEG_INFINITY.to_bits() {\n            return self;\n        }\n\n        let abs = bits & !Self::SIGN_MASK;\n        let next_bits = if abs == 0 {\n            Self::NEG_TINY_BITS\n        } else if bits == abs {\n            bits - 1\n        } else {\n            bits + 1\n        };\n        Self::from_bits(next_bits)\n    }",
  "callees": [
    "141416729681063873945734553097119310337",
    "110174298608622596992026438568283617550",
    "1280257502160233765816408910554470634604"
  ]
}
