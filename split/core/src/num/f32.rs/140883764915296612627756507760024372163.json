{
  "file": "core/src/num/f32.rs",
  "name": "f32::<impl f32>::midpoint",
  "hash": "140883764915296612627756507760024372163",
  "hash_direct": "85217247370125007245214753479295177853",
  "src": "pub const fn midpoint(self, other: f32) -> f32 {\n        cfg_select! {\n            // Allow faster implementation that have known good 64-bit float\n            // implementations. Falling back to the branchy code on targets that don't\n            // have 64-bit hardware floats or buggy implementations.\n            // https://github.com/rust-lang/rust/pull/121062#issuecomment-2123408114\n            any(\n                target_arch = \"x86_64\",\n                target_arch = \"aarch64\",\n                all(any(target_arch = \"riscv32\", target_arch = \"riscv64\"), target_feature = \"d\"),\n                all(target_arch = \"loongarch64\", target_feature = \"d\"),\n                all(target_arch = \"arm\", target_feature = \"vfp2\"),\n                target_arch = \"wasm32\",\n                target_arch = \"wasm64\",\n            ) => {\n                ((self as f64 + other as f64) / 2.0) as f32\n            }\n            _ => {\n                const HI: f32 = f32::MAX / 2.;\n\n                let (a, b) = (self, other);\n                let abs_a = a.abs();\n                let abs_b = b.abs();\n\n                if abs_a <= HI && abs_b <= HI {\n                    // Overflow is impossible\n                    (a + b) / 2.\n                } else {\n                    (a / 2.) + (b / 2.)\n                }\n            }\n        }\n    }"
}
