{
  "file": "core/src/num/f32.rs",
  "name": "f32::<impl f32>::midpoint",
  "hash": "205085219078663623013179679713939177738",
  "hash_direct": "1021659532900344417615074042738361432483",
  "src": "pub const fn midpoint(self, other: f32) -> f32 {\n        cfg_select! {\n            // Allow faster implementation that have known good 64-bit float\n            // implementations. Falling back to the branchy code on targets that don't\n            // have 64-bit hardware floats or buggy implementations.\n            // https://github.com/rust-lang/rust/pull/121062#issuecomment-2123408114\n            any(\n                target_arch = \"x86_64\",\n                target_arch = \"aarch64\",\n                all(any(target_arch = \"riscv32\", target_arch = \"riscv64\"), target_feature = \"d\"),\n                all(target_arch = \"loongarch64\", target_feature = \"d\"),\n                all(target_arch = \"arm\", target_feature = \"vfp2\"),\n                target_arch = \"wasm32\",\n                target_arch = \"wasm64\",\n            ) => {\n                ((self as f64 + other as f64) / 2.0) as f32\n            }\n            _ => {\n                const LO: f32 = f32::MIN_POSITIVE * 2.;\n                const HI: f32 = f32::MAX / 2.;\n\n                let (a, b) = (self, other);\n                let abs_a = a.abs();\n                let abs_b = b.abs();\n\n                if abs_a <= HI && abs_b <= HI {\n                    // Overflow is impossible\n                    (a + b) / 2.\n                } else if abs_a < LO {\n                    // Not safe to halve `a` (would underflow)\n                    a + (b / 2.)\n                } else if abs_b < LO {\n                    // Not safe to halve `b` (would underflow)\n                    (a / 2.) + b\n                } else {\n                    // Safe to halve `a` and `b`\n                    (a / 2.) + (b / 2.)\n                }\n            }\n        }\n    }"
}
