{
  "file": "core/src/marker/variance.rs",
  "name": "<marker::variance::PhantomInvariant<&()> as cmp::Ord>::cmp",
  "hash": "5742215401560407750786050075025697427",
  "hash_direct": "165124107043594600343094499442531444667",
  "src": "fn cmp(&self, _: &Self) -> Ordering {\n                Ordering::Equal\n            }",
  "macro_backtrace": [
    {
      "callsite": "phantom_type! {\n    /// Zero-sized type used to mark a type parameter as covariant.\n    ///\n    /// Types used as part of the return value from a function are covariant. If the type is _also_\n    /// passed as a parameter then it is [invariant][PhantomInvariant]. See [the reference][1] for\n    /// more information.\n    ///\n    /// [1]: https://doc.rust-lang.org/stable/reference/subtyping.html#variance\n    ///\n    /// Note: If `T` is otherwise contravariant or invariant, the resulting type is invariant.\n    ///\n    /// ## Layout\n    ///\n    /// For all `T`, the following are guaranteed:\n    /// * `size_of::<PhantomCovariant<T>>() == 0`\n    /// * `align_of::<PhantomCovariant<T>>() == 1`\n    #[rustc_pub_transparent]\n    #[repr(transparent)]\n    pub struct PhantomCovariant<T>(PhantomData<fn() -> T>);\n    /// Zero-sized type used to mark a type parameter as contravariant.\n    ///\n    /// Types passed as arguments to a function are contravariant. If the type is _also_ part of the\n    /// return value from a function then it is [invariant][PhantomInvariant]. See [the\n    /// reference][1] for more information.\n    ///\n    /// [1]: https://doc.rust-lang.org/stable/reference/subtyping.html#variance\n    ///\n    /// Note: If `T` is otherwise covariant or invariant, the resulting type is invariant.\n    ///\n    /// ## Layout\n    ///\n    /// For all `T`, the following are guaranteed:\n    /// * `size_of::<PhantomContravariant<T>>() == 0`\n    /// * `align_of::<PhantomContravariant<T>>() == 1`\n    #[rustc_pub_transparent]\n    #[repr(transparent)]\n    pub struct PhantomContravariant<T>(PhantomData<fn(T)>);\n    /// Zero-sized type used to mark a type parameter as invariant.\n    ///\n    /// Types that are both passed as an argument _and_ used as part of the return value from a\n    /// function are invariant. See [the reference][1] for more information.\n    ///\n    /// [1]: https://doc.rust-lang.org/stable/reference/subtyping.html#variance\n    ///\n    /// ## Layout\n    ///\n    /// For all `T`, the following are guaranteed:\n    /// * `size_of::<PhantomInvariant<T>>() == 0`\n    /// * `align_of::<PhantomInvariant<T>>() == 1`\n    #[rustc_pub_transparent]\n    #[repr(transparent)]\n    pub struct PhantomInvariant<T>(PhantomData<fn(T) -> T>);\n}",
      "defsite": "macro_rules! phantom_type {\n    ($(\n        $(#[$attr:meta])*\n        pub struct $name:ident <$t:ident> ($($inner:tt)*);\n    )*) => {$(\n        $(#[$attr])*\n        pub struct $name<$t>($($inner)*) where $t: ?Sized;\n\n        impl<T> $name<T>\n            where T: ?Sized\n        {\n            /// Constructs a new instance of the variance marker.\n            pub const fn new() -> Self {\n                Self(PhantomData)\n            }\n        }\n\n        impl<T> self::sealed::Sealed for $name<T> where T: ?Sized {\n            const VALUE: Self = Self::new();\n        }\n        impl<T> Variance for $name<T> where T: ?Sized {}\n\n        impl<T> Default for $name<T>\n            where T: ?Sized\n        {\n            fn default() -> Self {\n                Self(PhantomData)\n            }\n        }\n\n        impl<T> fmt::Debug for $name<T>\n            where T: ?Sized\n        {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                write!(f, \"{}<{}>\", stringify!($name), type_name::<T>())\n            }\n        }\n\n        impl<T> Clone for $name<T>\n            where T: ?Sized\n        {\n            fn clone(&self) -> Self {\n                *self\n            }\n        }\n\n        impl<T> Copy for $name<T> where T: ?Sized {}\n\n        impl<T> PartialEq for $name<T>\n            where T: ?Sized\n        {\n            fn eq(&self, _: &Self) -> bool {\n                true\n            }\n        }\n\n        impl<T> Eq for $name<T> where T: ?Sized {}\n\n        impl<T> PartialOrd for $name<T>\n            where T: ?Sized\n        {\n            fn partial_cmp(&self, _: &Self) -> Option<Ordering> {\n                Some(Ordering::Equal)\n            }\n        }\n\n        impl<T> Ord for $name<T>\n            where T: ?Sized\n        {\n            fn cmp(&self, _: &Self) -> Ordering {\n                Ordering::Equal\n            }\n        }\n\n        impl<T> Hash for $name<T>\n            where T: ?Sized\n        {\n            fn hash<H: Hasher>(&self, _: &mut H) {}\n        }\n    )*};\n}"
    }
  ]
}
