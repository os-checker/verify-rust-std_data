{
  "file": "core/src/net/parser.rs",
  "name": "net::parser::Parser::<'_>::read_number::<u16>::{closure#0}",
  "hash": "47082651431100567229467765560101718455",
  "hash_direct": "71097626424408167309755453324578538657",
  "src": "move |p| {\n            let mut digit_count = 0;\n            let has_leading_zero = p.peek_char() == Some('0');\n\n            // If max_digits.is_some(), then we are parsing a `u8` or `u16` and\n            // don't need to use checked arithmetic since it fits within a `u32`.\n            let result = if let Some(max_digits) = max_digits {\n                // u32::MAX = 4_294_967_295u32, which is 10 digits long.\n                // `max_digits` must be less than 10 to not overflow a `u32`.\n                debug_assert!(max_digits < 10);\n\n                let mut result = 0_u32;\n                while let Some(digit) = p.read_atomically(|p| p.read_char()?.to_digit(radix)) {\n                    result *= radix;\n                    result += digit;\n                    digit_count += 1;\n\n                    if digit_count > max_digits {\n                        return None;\n                    }\n                }\n\n                result.try_into().ok()\n            } else {\n                let mut result = T::ZERO;\n\n                while let Some(digit) = p.read_atomically(|p| p.read_char()?.to_digit(radix)) {\n                    result = result.checked_mul(radix)?;\n                    result = result.checked_add(digit)?;\n                    digit_count += 1;\n                }\n\n                Some(result)\n            };\n\n            if digit_count == 0 {\n                None\n            } else if !allow_zero_prefix && has_leading_zero && digit_count > 1 {\n                None\n            } else {\n                result\n            }\n        }",
  "callees": [
    "511962504776047044912646038885098500692",
    "85573708867003773503727706164971877350",
    "15518699560175228058918609018343356989",
    "162595735811016098284970758574536707617",
    "10978774793629687985652421476673626725",
    "258820287469578611817448591488600041899",
    "588974892899239543415856878986124229421",
    "690438059002452523915046149102377829082",
    "985534027864289666414136581042057138480",
    "1839338930402506290912118824178795638624",
    "44421782838203085223217897581467993698",
    "1496059028021580695016992067514637295596",
    "1760603734772611044013409924435323435039",
    "12788322730890622296594960141845489092",
    "1090802516613202497515360573503366486326",
    "1593816907297385618710307221619963429327",
    "133395867933411993249488719191102551312",
    "66856531302908524713415658213605967079",
    "115091716786889683547916242610714266789",
    "1386896460222873658110366429505227560805",
    "1508557820869042035017329617948728186885",
    "303127917241666984113380325134893912788",
    "60869249937273539602008894281350951915",
    "11394109588989514066836781073732518434",
    "1206804965956081593213843103055931360059",
    "62522805592676016269642550063448762286",
    "1424839172046310268011085042199237354602",
    "533978393061650897214741362182416016139",
    "90434442550312736906949358693105215038",
    "1507457419509717148718386372359226764513",
    "107750154537374038185532791974515303762",
    "1113032932815665948217565294476098756403",
    "41505289739977656509611396154325757795",
    "243931809744896974812513529918607549579",
    "1752989996936949203916036071159051010960",
    "9415230033719881551100479702541278001",
    "135710756291504804587550868687823101358",
    "150567892505730402506580299695654398474",
    "1817215089507823436616338053904223106794",
    "132216090387111466077274355354934980437",
    "362063923325643096717377828351042387428",
    "21617172818475739555230285502389437314",
    "78204921097721474912957416123615891283"
  ]
}
